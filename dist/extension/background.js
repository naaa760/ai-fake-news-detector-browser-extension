"use strict";(()=>{var lt=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(r,o)=>(typeof require<"u"?require:r)[o]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var Ur={};var hh=Object.create,Jr=Object.defineProperty,fh=Object.getOwnPropertyDescriptor,gh=Object.getOwnPropertyNames,mh=Object.getPrototypeOf,bh=Object.prototype.hasOwnProperty,yh=(e=>typeof lt<"u"?lt:typeof Proxy<"u"?new Proxy(e,{get:(r,o)=>(typeof lt<"u"?lt:r)[o]}):e)(function(e){if(typeof lt<"u")return lt.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),I=(e,r)=>()=>(e&&(r=e(e=0)),r),ne=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),mr=(e,r)=>{for(var o in r)Jr(e,o,{get:r[o],enumerable:!0})},Zu=(e,r,o,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let p of gh(r))!bh.call(e,p)&&p!==o&&Jr(e,p,{get:()=>r[p],enumerable:!(s=fh(r,p))||s.enumerable});return e},It=(e,r,o)=>(o=e!=null?hh(mh(e)):{},Zu(r||!e||!e.__esModule?Jr(o,"default",{value:e,enumerable:!0}):o,e)),Gr=e=>Zu(Jr({},"__esModule",{value:!0}),e),zt,Ze,dr,ba,Go,Ho=I(()=>{"use strict";zt=new Map,Ze=[],dr=(e,r,o)=>{if(r&&typeof r.init=="function"&&typeof r.createInferenceSessionHandler=="function"){let s=zt.get(e);if(s===void 0)zt.set(e,{backend:r,priority:o});else{if(s.priority>o)return;if(s.priority===o&&s.backend!==r)throw new Error(`cannot register backend "${e}" using priority ${o}`)}if(o>=0){let p=Ze.indexOf(e);p!==-1&&Ze.splice(p,1);for(let l=0;l<Ze.length;l++)if(zt.get(Ze[l]).priority<=o){Ze.splice(l,0,e);return}Ze.push(e)}return}throw new TypeError("not a valid backend")},ba=async e=>{let r=zt.get(e);if(!r)return"backend not found.";if(r.initialized)return r.backend;if(r.aborted)return r.error;{let o=!!r.initPromise;try{return o||(r.initPromise=r.backend.init(e)),await r.initPromise,r.initialized=!0,r.backend}catch(s){return o||(r.error=`${s}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},Go=async e=>{let r=e.executionProviders||[],o=r.map(a=>typeof a=="string"?a:a.name),s=o.length===0?Ze:o,p,l=[],c=new Set;for(let a of s){let t=await ba(a);typeof t=="string"?l.push({name:a,err:t}):(p||(p=t),p===t&&c.add(a))}if(!p)throw new Error(`no available backend found. ERR: ${l.map(a=>`[${a.name}] ${a.err}`).join(", ")}`);for(let{name:a,err:t}of l)o.includes(a)&&console.warn(`removing requested execution provider "${a}" from session options because it is not available: ${t}`);let n=r.filter(a=>c.has(typeof a=="string"?a:a.name));return[p,new Proxy(e,{get:(a,t)=>t==="executionProviders"?n:Reflect.get(a,t)})]}}),wh=I(()=>{"use strict";Ho()}),Ju,vh=I(()=>{"use strict";Ju="1.20.1"}),yn,De,Yu=I(()=>{"use strict";vh(),yn="warning",De={wasm:{},webgl:{},webgpu:{},versions:{common:Ju},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);yn=e}},get logLevel(){return yn}},Object.defineProperty(De,"logLevel",{enumerable:!0})}),j,xh=I(()=>{"use strict";Yu(),j=De}),Qu,el,Th=I(()=>{"use strict";Qu=(e,r)=>{let o=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);o.width=e.dims[3],o.height=e.dims[2];let s=o.getContext("2d");if(s!=null){let p,l;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(p=e.dims[2],l=e.dims[3]):(p=e.dims[3],l=e.dims[2]);let c=r?.format!==void 0?r.format:"RGB",n=r?.norm,a,t;n===void 0||n.mean===void 0?a=[255,255,255,255]:typeof n.mean=="number"?a=[n.mean,n.mean,n.mean,n.mean]:(a=[n.mean[0],n.mean[1],n.mean[2],0],n.mean[3]!==void 0&&(a[3]=n.mean[3])),n===void 0||n.bias===void 0?t=[0,0,0,0]:typeof n.bias=="number"?t=[n.bias,n.bias,n.bias,n.bias]:(t=[n.bias[0],n.bias[1],n.bias[2],0],n.bias[3]!==void 0&&(t[3]=n.bias[3]));let u=l*p,i=0,d=u,h=u*2,m=-1;c==="RGBA"?(i=0,d=u,h=u*2,m=u*3):c==="RGB"?(i=0,d=u,h=u*2):c==="RBG"&&(i=0,h=u,d=u*2);for(let b=0;b<l;b++)for(let x=0;x<p;x++){let E=(e.data[i++]-t[0])*a[0],w=(e.data[d++]-t[1])*a[1],S=(e.data[h++]-t[2])*a[2],$=m===-1?255:(e.data[m++]-t[3])*a[3];s.fillStyle="rgba("+E+","+w+","+S+","+$+")",s.fillRect(x,b,1,1)}if("toDataURL"in o)return o.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},el=(e,r)=>{let o=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(o!=null){let p,l,c;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(p=e.dims[2],l=e.dims[1],c=e.dims[3]):(p=e.dims[3],l=e.dims[2],c=e.dims[1]);let n=r!==void 0&&r.format!==void 0?r.format:"RGB",a=r?.norm,t,u;a===void 0||a.mean===void 0?t=[255,255,255,255]:typeof a.mean=="number"?t=[a.mean,a.mean,a.mean,a.mean]:(t=[a.mean[0],a.mean[1],a.mean[2],255],a.mean[3]!==void 0&&(t[3]=a.mean[3])),a===void 0||a.bias===void 0?u=[0,0,0,0]:typeof a.bias=="number"?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(u[3]=a.bias[3]));let i=l*p;if(r!==void 0&&(r.format!==void 0&&c===4&&r.format!=="RGBA"||c===3&&r.format!=="RGB"&&r.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,h=0,m=1,b=2,x=3,E=0,w=i,S=i*2,$=-1;n==="RGBA"?(E=0,w=i,S=i*2,$=i*3):n==="RGB"?(E=0,w=i,S=i*2):n==="RBG"&&(E=0,S=i,w=i*2),s=o.createImageData(p,l);for(let F=0;F<l*p;h+=d,m+=d,b+=d,x+=d,F++)s.data[h]=(e.data[E++]-u[0])*t[0],s.data[m]=(e.data[w++]-u[1])*t[1],s.data[b]=(e.data[S++]-u[2])*t[2],s.data[x]=$===-1?255:(e.data[$++]-u[3])*t[3]}else throw new Error("Can not access image data");return s}}),kr,tl,rl,nl,ol,il,_h=I(()=>{"use strict";qo(),kr=(e,r)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(r.height===void 0||r.width===void 0)throw new Error("Image height and width must be defined");if(r.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:o,width:s}=r,p=r.norm??{mean:255,bias:0},l,c;typeof p.mean=="number"?l=[p.mean,p.mean,p.mean,p.mean]:l=[p.mean[0],p.mean[1],p.mean[2],p.mean[3]??255],typeof p.bias=="number"?c=[p.bias,p.bias,p.bias,p.bias]:c=[p.bias[0],p.bias[1],p.bias[2],p.bias[3]??0];let n=r.format!==void 0?r.format:"RGBA",a=r.tensorFormat!==void 0&&r.tensorFormat!==void 0?r.tensorFormat:"RGB",t=o*s,u=a==="RGBA"?new Float32Array(t*4):new Float32Array(t*3),i=4,d=0,h=1,m=2,b=3,x=0,E=t,w=t*2,S=-1;n==="RGB"&&(i=3,d=0,h=1,m=2,b=-1),a==="RGBA"?S=t*3:a==="RBG"?(x=0,w=t,E=t*2):a==="BGR"&&(w=0,E=t,x=t*2);for(let $=0;$<t;$++,d+=i,m+=i,h+=i,b+=i)u[x++]=(e[d]+c[0])/l[0],u[E++]=(e[h]+c[1])/l[1],u[w++]=(e[m]+c[2])/l[2],S!==-1&&b!==-1&&(u[S++]=(e[b]+c[3])/l[3]);return a==="RGBA"?new Ie("float32",u,[1,4,o,s]):new Ie("float32",u,[1,3,o,s])},tl=async(e,r)=>{let o=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,p=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,l=typeof e=="string",c,n=r??{},a=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},t=u=>typeof HTMLCanvasElement<"u"&&u instanceof HTMLCanvasElement||u instanceof OffscreenCanvas?u.getContext("2d"):null;if(o){let u=a();u.width=e.width,u.height=e.height;let i=t(u);if(i!=null){let d=e.height,h=e.width;if(r!==void 0&&r.resizedHeight!==void 0&&r.resizedWidth!==void 0&&(d=r.resizedHeight,h=r.resizedWidth),r!==void 0){if(n=r,r.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");n.tensorFormat="RGBA",n.height=d,n.width=h}else n.tensorFormat="RGBA",n.height=d,n.width=h;i.drawImage(e,0,0),c=i.getImageData(0,0,h,d).data}else throw new Error("Can not access image data")}else if(s){let u,i;if(r!==void 0&&r.resizedWidth!==void 0&&r.resizedHeight!==void 0?(u=r.resizedHeight,i=r.resizedWidth):(u=e.height,i=e.width),r!==void 0&&(n=r),n.format="RGBA",n.height=u,n.width=i,r!==void 0){let d=a();d.width=i,d.height=u;let h=t(d);if(h!=null)h.putImageData(e,0,0),c=h.getImageData(0,0,i,u).data;else throw new Error("Can not access image data")}else c=e.data}else if(p){if(r===void 0)throw new Error("Please provide image config with format for Imagebitmap");let u=a();u.width=e.width,u.height=e.height;let i=t(u);if(i!=null){let d=e.height,h=e.width;return i.drawImage(e,0,0,h,d),c=i.getImageData(0,0,h,d).data,n.height=d,n.width=h,kr(c,n)}else throw new Error("Can not access image data")}else{if(l)return new Promise((u,i)=>{let d=a(),h=t(d);if(!e||!h)return i();let m=new Image;m.crossOrigin="Anonymous",m.src=e,m.onload=()=>{d.width=m.width,d.height=m.height,h.drawImage(m,0,0,d.width,d.height);let b=h.getImageData(0,0,d.width,d.height);n.height=d.height,n.width=d.width,u(kr(b.data,n))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(c!==void 0)return kr(c,n);throw new Error("Input data provided is not supported - aborted tensor creation")},rl=(e,r)=>{let{width:o,height:s,download:p,dispose:l}=r,c=[1,s,o,4];return new Ie({location:"texture",type:"float32",texture:e,dims:c,download:p,dispose:l})},nl=(e,r)=>{let{dataType:o,dims:s,download:p,dispose:l}=r;return new Ie({location:"gpu-buffer",type:o??"float32",gpuBuffer:e,dims:s,download:p,dispose:l})},ol=(e,r)=>{let{dataType:o,dims:s,download:p,dispose:l}=r;return new Ie({location:"ml-tensor",type:o??"float32",mlTensor:e,dims:s,download:p,dispose:l})},il=(e,r,o)=>new Ie({location:"cpu-pinned",type:e,data:r,dims:o??[r.length]})}),mt,Qt,wn,al,Sh=I(()=>{"use strict";mt=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Qt=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),wn=!1,al=()=>{if(!wn){wn=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,r=typeof BigUint64Array<"u"&&BigUint64Array.from,o=typeof Float16Array<"u"&&Float16Array.from;e&&(mt.set("int64",BigInt64Array),Qt.set(BigInt64Array,"int64")),r&&(mt.set("uint64",BigUint64Array),Qt.set(BigUint64Array,"uint64")),o?(mt.set("float16",Float16Array),Qt.set(Float16Array,"float16")):mt.set("float16",Uint16Array)}}}),sl,ul,Oh=I(()=>{"use strict";qo(),sl=e=>{let r=1;for(let o=0;o<e.length;o++){let s=e[o];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${o}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${s}`);r*=s}return r},ul=(e,r)=>{switch(e.location){case"cpu":return new Ie(e.type,e.data,r);case"cpu-pinned":return new Ie({location:"cpu-pinned",data:e.data,type:e.type,dims:r});case"texture":return new Ie({location:"texture",texture:e.texture,type:e.type,dims:r});case"gpu-buffer":return new Ie({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:r});case"ml-tensor":return new Ie({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:r});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),Ie,qo=I(()=>{"use strict";Th(),_h(),Sh(),Oh(),Ie=class{constructor(e,r,o){al();let s,p;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,s=e.type,p=e.dims,e.location){case"cpu-pinned":{let c=mt.get(s);if(!c)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(e.data instanceof c))throw new TypeError(`buffer should be of type ${c.name}`);this.cpuData=e.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let c,n;if(typeof e=="string")if(s=e,n=o,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");c=r}else{let a=mt.get(e);if(a===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16"&&a===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${a.name} as data.`);e==="uint64"||e==="int64"?c=a.from(r,BigInt):c=a.from(r)}else if(r instanceof a)c=r;else if(r instanceof Uint8ClampedArray)if(e==="uint8")c=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${s} tensor's data must be type of ${a}`)}else if(n=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let a=typeof e[0];if(a==="string")s="string",c=e;else if(a==="boolean")s="bool",c=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${a}.`)}else if(e instanceof Uint8ClampedArray)s="uint8",c=Uint8Array.from(e);else{let a=Qt.get(e.constructor);if(a===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);s=a,c=e}if(n===void 0)n=[c.length];else if(!Array.isArray(n))throw new TypeError("A tensor's dims must be a number array");p=n,this.cpuData=c,this.dataLocation="cpu"}let l=sl(p);if(this.cpuData&&l!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(l/2)===this.cpuData.length))throw new Error(`Tensor's size(${l}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=p,this.size=l}static async fromImage(e,r){return tl(e,r)}static fromTexture(e,r){return rl(e,r)}static fromGpuBuffer(e,r){return nl(e,r)}static fromMLTensor(e,r){return ol(e,r)}static fromPinnedBuffer(e,r,o){return il(e,r,o)}toDataURL(e){return Qu(this,e)}toImageData(e){return el(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return ul(this,e)}}}),fe,Wo=I(()=>{"use strict";qo(),fe=Ie}),so,vn,Pt,At,ll=I(()=>{"use strict";Yu(),so=(e,r)=>{(typeof De.trace>"u"?!De.wasm.trace:!De.trace)||console.timeStamp(`${e}::ORT::${r}`)},vn=(e,r)=>{let o=new Error().stack?.split(/\r\n|\r|\n/g)||[],s=!1;for(let p=0;p<o.length;p++){if(s&&!o[p].includes("TRACE_FUNC")){let l=`FUNC_${e}::${o[p].trim().split(" ")[1]}`;r&&(l+=`::${r}`),so("CPU",l);return}o[p].includes("TRACE_FUNC")&&(s=!0)}},Pt=e=>{(typeof De.trace>"u"?!De.wasm.trace:!De.trace)||vn("BEGIN",e)},At=e=>{(typeof De.trace>"u"?!De.wasm.trace:!De.trace)||vn("END",e)}}),pl,Eh=I(()=>{"use strict";Ho(),Wo(),ll(),pl=class cl{constructor(r){this.handler=r}async run(r,o,s){Pt();let p={},l={};if(typeof r!="object"||r===null||r instanceof fe||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof o=="object"){if(o===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(o instanceof fe)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(o)){if(o.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(let t of o){if(typeof t!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(t)===-1)throw new RangeError(`'fetches' contains invalid output name: ${t}.`);p[t]=null}if(typeof s=="object"&&s!==null)l=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let t=!1,u=Object.getOwnPropertyNames(o);for(let i of this.outputNames)if(u.indexOf(i)!==-1){let d=o[i];(d===null||d instanceof fe)&&(t=!0,c=!1,p[i]=d)}if(t){if(typeof s=="object"&&s!==null)l=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else l=o}}else if(typeof o<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof r[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(c)for(let t of this.outputNames)p[t]=null;let n=await this.handler.run(r,p,l),a={};for(let t in n)if(Object.hasOwnProperty.call(n,t)){let u=n[t];u instanceof fe?a[t]=u:a[t]=new fe(u.type,u.data,u.dims)}return At(),a}async release(){return this.handler.dispose()}static async create(r,o,s,p){Pt();let l,c={};if(typeof r=="string"){if(l=r,typeof o=="object"&&o!==null)c=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(l=r,typeof o=="object"&&o!==null)c=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer){let u=r,i=0,d=r.byteLength;if(typeof o=="object"&&o!==null)c=o;else if(typeof o=="number"){if(i=o,!Number.isSafeInteger(i))throw new RangeError("'byteOffset' must be an integer.");if(i<0||i>=u.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${u.byteLength}).`);if(d=r.byteLength-i,typeof s=="number"){if(d=s,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||i+d>u.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${u.byteLength-i}].`);if(typeof p=="object"&&p!==null)c=p;else if(typeof p<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof o<"u")throw new TypeError("'options' must be an object.");l=new Uint8Array(u,i,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[n,a]=await Go(c),t=await n.createInferenceSessionHandler(l,a);return At(),new cl(t)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Yr,Ih=I(()=>{"use strict";Eh(),Yr=pl}),Ph=I(()=>{"use strict"}),Ah=I(()=>{"use strict"}),$h=I(()=>{"use strict"}),Dh=I(()=>{"use strict"}),ya,dl,Nh=I(()=>{"use strict";Ho(),Wo(),ya="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",dl=class hl{constructor(r,o,s){this.handler=r,this.hasOptimizerModel=o,this.hasEvalModel=s}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(r,o){let s=r.evalModel||"",p=r.optimizerModel||"",l=o||{},[c,n]=await Go(l);if(c.createTrainingSessionHandler){let a=await c.createTrainingSessionHandler(r.checkpointState,r.trainModel,s,p,n);return new hl(a,!!r.optimizerModel,!!r.evalModel)}else throw new Error(ya)}typeNarrowingForRunStep(r,o,s,p,l){let c={},n={};if(typeof s!="object"||s===null||s instanceof fe||Array.isArray(s))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof p=="object"){if(p===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(p instanceof fe)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(p)){if(p.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let t of p){if(typeof t!="string")throw new TypeError("'fetches' must be a string array or an object.");if(o.indexOf(t)===-1)throw new RangeError(`'fetches' contains invalid output name: ${t}.`);c[t]=null}if(typeof l=="object"&&l!==null)n=l;else if(typeof l<"u")throw new TypeError("'options' must be an object.")}else{let t=!1,u=Object.getOwnPropertyNames(p);for(let i of o)if(u.indexOf(i)!==-1){let d=p[i];(d===null||d instanceof fe)&&(t=!0,a=!1,c[i]=d)}if(t){if(typeof l=="object"&&l!==null)n=l;else if(typeof l<"u")throw new TypeError("'options' must be an object.")}else n=p}}else if(typeof p<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of r)if(typeof s[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let t of o)c[t]=null;return[c,n]}convertHandlerReturnTypeToMapOfTensors(r){let o={};for(let s in r)if(Object.hasOwnProperty.call(r,s)){let p=r[s];p instanceof fe?o[s]=p:o[s]=new fe(p.type,p.data,p.dims)}return o}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(r,o,s){let[p,l]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,r,o,s),c=await this.handler.runTrainStep(r,p,l);return this.convertHandlerReturnTypeToMapOfTensors(c)}async runOptimizerStep(r){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(r||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(r,o,s){if(this.hasEvalModel){let[p,l]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,r,o,s),c=await this.handler.runEvalStep(r,p,l);return this.convertHandlerReturnTypeToMapOfTensors(c)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(r=!0){return this.handler.getParametersSize(r)}async loadParametersBuffer(r,o=!0){let s=await this.getParametersSize(o);if(r.length!==4*s)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(r,o)}async getContiguousParameters(r=!0){return this.handler.getContiguousParameters(r)}async release(){return this.handler.dispose()}}}),fl,kh=I(()=>{"use strict";Nh(),fl=dl}),gl={};mr(gl,{InferenceSession:()=>Yr,TRACE:()=>so,TRACE_FUNC_BEGIN:()=>Pt,TRACE_FUNC_END:()=>At,Tensor:()=>fe,TrainingSession:()=>fl,env:()=>j,registerBackend:()=>dr});var ze=I(()=>{"use strict";wh(),xh(),Ih(),Wo(),Ph(),Ah(),ll(),$h(),Dh(),kh()});function bt(e,r,o,s){if(r===void 0)return Fh(e);if(o===void 0)Fr(e,r,1);else if(typeof o=="number"&&s===void 0)Fr(e,r,o);else if(typeof o=="string"&&s===void 0)Fr(e,o,1,r);else if(typeof o=="string"&&typeof s=="number")Fr(e,o,s,r);else throw new TypeError("input is valid")}function Fh(e){return{verbose:bt.verbose.bind(null,e),info:bt.info.bind(null,e),warning:bt.warning.bind(null,e),error:bt.error.bind(null,e),fatal:bt.fatal.bind(null,e)}}function Fr(e,r,o,s){let p=Et[s||""]||Et[""];uo[e]<uo[p.minimalSeverity]||(p.logDateTime&&(r=`${new Date().toISOString()}|${r}`),p.logSourceLocation,ml[p.provider].log(e,r,s))}var wa,va,uo,ml,xn,Et,ee,Tn,_n,bl,Ut,Re=I(()=>{"use strict";wa=class{log(e,r,o){}},va=class{log(e,r,o){console.log(`${this.color(e)} ${o?"\x1B[35m"+o+"\x1B[0m ":""}${r}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},uo={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},ml={none:new wa,console:new va},xn={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Et={"":xn},(e=>{function r(t,u){e("verbose",t,u)}e.verbose=r;function o(t,u){e("info",t,u)}e.info=o;function s(t,u){e("warning",t,u)}e.warning=s;function p(t,u){e("error",t,u)}e.error=p;function l(t,u){e("fatal",t,u)}e.fatal=l;function c(t){Et={},n("",t||{})}e.reset=c;function n(t,u){if(t==="*")c(u);else{let i=Et[t]||xn;Et[t]={provider:u.provider||i.provider,minimalSeverity:u.minimalSeverity||i.minimalSeverity,logDateTime:u.logDateTime===void 0?i.logDateTime:u.logDateTime,logSourceLocation:u.logSourceLocation===void 0?i.logSourceLocation:u.logSourceLocation}}}e.set=n;function a(t){let u={};t.logLevel&&(u.minimalSeverity=t.logLevel),n("",u)}e.setWithEnv=a})(bt||={}),ee=bt,Tn=class{constructor(e,r,o,s,p,l){this.category=e,this.name=r,this.startTime=o,this.endCallback=s,this.timer=p,this.ctx=l}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},_n=class{constructor(e,r,o,s){this.category=e,this.name=r,this.startTime=o,this.endTime=s}},bl=class{constructor(e,r,o){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=r===void 0?10:r,this._flushIntervalInMilliseconds=o===void 0?5e3:o}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=Ut(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,r,o,s){let p=this._started?this.begin(e,r,s):void 0,l=!1,c=o();if(c&&typeof c.then=="function")return l=!0,new Promise((n,a)=>{c.then(async t=>{p&&await p.end(),n(t)},async t=>{p&&await p.end(),a(t)})});if(!l&&p){let n=p.end();if(n&&typeof n.then=="function")return new Promise((a,t)=>{n.then(()=>{a(c)},u=>{t(u)})})}return c}begin(e,r,o){if(!this._started)throw new Error("profiler is not started yet");if(o===void 0){let s=Ut();return this.flush(s),new Tn(e,r,s,p=>this.endSync(p))}else{let s=o.beginTimer();return new Tn(e,r,0,async p=>this.end(p),s,o)}}async end(e){let r=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new _n(e.category,e.name,e.startTime,r)),this.flush(r))}endSync(e){let r=Ut();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new _n(e.category,e.name,e.startTime,r)),this.flush(r))}logOneEvent(e){ee.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let r=this._flushPointer;this._flushPointer<r+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=Ut()}}get started(){return this._started}},Ut=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Ch(e,r,o){for(let s of o){let p=s[0],l=s[1],c=s[2],n=s[3],a=s[4];if(e.opType===p){for(let t of r)if((t.domain===l||t.domain==="ai.onnx"&&l==="")&&Lh(t.version,c))return{opImpl:n,opInit:a}}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${r.map(s=>`${s.domain||"ai.onnx"} v${s.version}`).join(", ")}`)}function Lh(e,r){if(r.endsWith("+")){let o=Number.parseInt(r.substring(0,r.length-1),10);return!isNaN(o)&&o<=e}else if(r.split("-").length===2){let o=r.split("-"),s=Number.parseInt(o[0],10),p=Number.parseInt(o[1],10);return!isNaN(s)&&!isNaN(p)&&s<=e&&e<=p}else return Number.parseInt(r,10)===e}var Rh=I(()=>{"use strict"}),jh=ne(e=>{"use strict";e.__esModule=!0;var r=function(){function o(s){if(!s)throw new TypeError("Invalid argument; `value` has no value.");this.value=o.EMPTY,s&&o.isGuid(s)&&(this.value=s)}return o.isGuid=function(s){var p=s.toString();return s&&(s instanceof o||o.validator.test(p))},o.create=function(){return new o([o.gen(2),o.gen(1),o.gen(1),o.gen(1),o.gen(3)].join("-"))},o.createEmpty=function(){return new o("emptyguid")},o.parse=function(s){return new o(s)},o.raw=function(){return[o.gen(2),o.gen(1),o.gen(1),o.gen(1),o.gen(3)].join("-")},o.gen=function(s){for(var p="",l=0;l<s;l++)p+=((1+Math.random())*65536|0).toString(16).substring(1);return p},o.prototype.equals=function(s){return o.isGuid(s)&&this.value===s.toString()},o.prototype.isEmpty=function(){return this.value===o.EMPTY},o.prototype.toString=function(){return this.value},o.prototype.toJSON=function(){return{value:this.value}},o.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),o.EMPTY="00000000-0000-0000-0000-000000000000",o}();e.Guid=r});function W(e,r,o){this.low=e|0,this.high=r|0,this.unsigned=!!o}function de(e){return(e&&e.__isLong__)===!0}function xa(e){var r=Math.clz32(e&-e);return e?31-r:r}function pt(e,r){var o,s,p;return r?(e>>>=0,(p=0<=e&&e<256)&&(s=po[e],s)?s:(o=M(e,0,!0),p&&(po[e]=o),o)):(e|=0,(p=-128<=e&&e<128)&&(s=lo[e],s)?s:(o=M(e,e<0?-1:0,!1),p&&(lo[e]=o),o))}function ke(e,r){if(isNaN(e))return r?Be:Ne;if(r){if(e<0)return Be;if(e>=co)return go}else{if(e<=-ho)return me;if(e+1>=ho)return fo}return e<0?ke(-e,r).neg():M(e%yt|0,e/yt|0,r)}function M(e,r,o){return new W(e,r,o)}function Xo(e,r,o){if(e.length===0)throw Error("empty string");if(typeof r=="number"?(o=r,r=!1):r=!!r,e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return r?Be:Ne;if(o=o||10,o<2||36<o)throw RangeError("radix");var s;if((s=e.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Xo(e.substring(1),r,o).neg();for(var p=ke(ur(o,8)),l=Ne,c=0;c<e.length;c+=8){var n=Math.min(8,e.length-c),a=parseInt(e.substring(c,c+n),o);if(n<8){var t=ke(ur(o,n));l=l.mul(t).add(ke(a))}else l=l.mul(p),l=l.add(ke(a))}return l.unsigned=r,l}function Le(e,r){return typeof e=="number"?ke(e,r):typeof e=="string"?Xo(e,r):M(e.low,e.high,typeof r=="boolean"?r:e.unsigned)}var _e,lo,po,ur,Sn,Ta,yt,co,ho,On,Ne,Be,ct,En,Cr,fo,go,me,A,tt,yl=I(()=>{_e=null;try{_e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}W.prototype.__isLong__,Object.defineProperty(W.prototype,"__isLong__",{value:!0}),W.isLong=de,lo={},po={},W.fromInt=pt,W.fromNumber=ke,W.fromBits=M,ur=Math.pow,W.fromString=Xo,W.fromValue=Le,Sn=65536,Ta=1<<24,yt=Sn*Sn,co=yt*yt,ho=co/2,On=pt(Ta),Ne=pt(0),W.ZERO=Ne,Be=pt(0,!0),W.UZERO=Be,ct=pt(1),W.ONE=ct,En=pt(1,!0),W.UONE=En,Cr=pt(-1),W.NEG_ONE=Cr,fo=M(-1,2147483647,!1),W.MAX_VALUE=fo,go=M(-1,-1,!0),W.MAX_UNSIGNED_VALUE=go,me=M(0,-2147483648,!1),W.MIN_VALUE=me,A=W.prototype,A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*yt+(this.low>>>0):this.high*yt+(this.low>>>0)},A.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(me)){var r=ke(e),o=this.div(r),s=o.mul(r).sub(this);return o.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var p=ke(ur(e,6),this.unsigned),l=this,c="";;){var n=l.div(p),a=l.sub(n.mul(p)).toInt()>>>0,t=a.toString(e);if(l=n,l.isZero())return t+c;for(;t.length<6;)t="0"+t;c=""+t+c}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(me)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,r=31;r>0&&!(e&1<<r);r--);return this.high!=0?r+33:r+1},A.isZero=function(){return this.high===0&&this.low===0},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(this.low&1)===1},A.isEven=function(){return(this.low&1)===0},A.equals=function(e){return de(e)||(e=Le(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low},A.eq=A.equals,A.notEquals=function(e){return!this.eq(e)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(e){return this.comp(e)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(e){return this.comp(e)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(e){return this.comp(e)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(e){return this.comp(e)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(e){if(de(e)||(e=Le(e)),this.eq(e))return 0;var r=this.isNegative(),o=e.isNegative();return r&&!o?-1:!r&&o?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(me)?me:this.not().add(ct)},A.neg=A.negate,A.add=function(e){de(e)||(e=Le(e));var r=this.high>>>16,o=this.high&65535,s=this.low>>>16,p=this.low&65535,l=e.high>>>16,c=e.high&65535,n=e.low>>>16,a=e.low&65535,t=0,u=0,i=0,d=0;return d+=p+a,i+=d>>>16,d&=65535,i+=s+n,u+=i>>>16,i&=65535,u+=o+c,t+=u>>>16,u&=65535,t+=r+l,t&=65535,M(i<<16|d,t<<16|u,this.unsigned)},A.subtract=function(e){return de(e)||(e=Le(e)),this.add(e.neg())},A.sub=A.subtract,A.multiply=function(e){if(this.isZero())return this;if(de(e)||(e=Le(e)),_e){var r=_e.mul(this.low,this.high,e.low,e.high);return M(r,_e.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?Be:Ne;if(this.eq(me))return e.isOdd()?me:Ne;if(e.eq(me))return this.isOdd()?me:Ne;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(On)&&e.lt(On))return ke(this.toNumber()*e.toNumber(),this.unsigned);var o=this.high>>>16,s=this.high&65535,p=this.low>>>16,l=this.low&65535,c=e.high>>>16,n=e.high&65535,a=e.low>>>16,t=e.low&65535,u=0,i=0,d=0,h=0;return h+=l*t,d+=h>>>16,h&=65535,d+=p*t,i+=d>>>16,d&=65535,d+=l*a,i+=d>>>16,d&=65535,i+=s*t,u+=i>>>16,i&=65535,i+=p*a,u+=i>>>16,i&=65535,i+=l*n,u+=i>>>16,i&=65535,u+=o*t+s*a+p*n+l*c,u&=65535,M(d<<16|h,u<<16|i,this.unsigned)},A.mul=A.multiply,A.divide=function(e){if(de(e)||(e=Le(e)),e.isZero())throw Error("division by zero");if(_e){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var r=(this.unsigned?_e.div_u:_e.div_s)(this.low,this.high,e.low,e.high);return M(r,_e.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Be:Ne;var o,s,p;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Be;if(e.gt(this.shru(1)))return En;p=Be}else{if(this.eq(me)){if(e.eq(ct)||e.eq(Cr))return me;if(e.eq(me))return ct;var l=this.shr(1);return o=l.div(e).shl(1),o.eq(Ne)?e.isNegative()?ct:Cr:(s=this.sub(e.mul(o)),p=o.add(s.div(e)),p)}else if(e.eq(me))return this.unsigned?Be:Ne;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();p=Ne}for(s=this;s.gte(e);){o=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var c=Math.ceil(Math.log(o)/Math.LN2),n=c<=48?1:ur(2,c-48),a=ke(o),t=a.mul(e);t.isNegative()||t.gt(s);)o-=n,a=ke(o,this.unsigned),t=a.mul(e);a.isZero()&&(a=ct),p=p.add(a),s=s.sub(t)}return p},A.div=A.divide,A.modulo=function(e){if(de(e)||(e=Le(e)),_e){var r=(this.unsigned?_e.rem_u:_e.rem_s)(this.low,this.high,e.low,e.high);return M(r,_e.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return M(~this.low,~this.high,this.unsigned)},A.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},A.clz=A.countLeadingZeros,A.countTrailingZeros=function(){return this.low?xa(this.low):xa(this.high)+32},A.ctz=A.countTrailingZeros,A.and=function(e){return de(e)||(e=Le(e)),M(this.low&e.low,this.high&e.high,this.unsigned)},A.or=function(e){return de(e)||(e=Le(e)),M(this.low|e.low,this.high|e.high,this.unsigned)},A.xor=function(e){return de(e)||(e=Le(e)),M(this.low^e.low,this.high^e.high,this.unsigned)},A.shiftLeft=function(e){return de(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?M(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):M(0,this.low<<e-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(e){return de(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?M(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):M(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(e){return de(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?M(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?M(this.high,0,this.unsigned):M(this.high>>>e-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.rotateLeft=function(e){var r;return de(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?M(this.high,this.low,this.unsigned):e<32?(r=32-e,M(this.low<<e|this.high>>>r,this.high<<e|this.low>>>r,this.unsigned)):(e-=32,r=32-e,M(this.high<<e|this.low>>>r,this.low<<e|this.high>>>r,this.unsigned))},A.rotl=A.rotateLeft,A.rotateRight=function(e){var r;return de(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?M(this.high,this.low,this.unsigned):e<32?(r=32-e,M(this.high<<r|this.low>>>e,this.low<<r|this.high>>>e,this.unsigned)):(e-=32,r=32-e,M(this.low<<r|this.high>>>e,this.high<<r|this.low>>>e,this.unsigned))},A.rotr=A.rotateRight,A.toSigned=function(){return this.unsigned?M(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:M(this.low,this.high,!0)},A.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var e=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]},A.toBytesBE=function(){var e=this.high,r=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,r>>>24,r>>>16&255,r>>>8&255,r&255]},W.fromBytes=function(e,r,o){return o?W.fromBytesLE(e,r):W.fromBytesBE(e,r)},W.fromBytesLE=function(e,r){return new W(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,r)},W.fromBytesBE=function(e,r){return new W(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],r)},tt=W}),T,Ko=I(()=>{T={},T.Offset,T.Table,T.SIZEOF_SHORT=2,T.SIZEOF_INT=4,T.FILE_IDENTIFIER_LENGTH=4,T.SIZE_PREFIX_LENGTH=4,T.Encoding={UTF8_BYTES:1,UTF16_STRING:2},T.int32=new Int32Array(2),T.float32=new Float32Array(T.int32.buffer),T.float64=new Float64Array(T.int32.buffer),T.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,T.Long=function(e,r){this.low=e|0,this.high=r|0},T.Long.create=function(e,r){return e==0&&r==0?T.Long.ZERO:new T.Long(e,r)},T.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},T.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},T.Long.ZERO=new T.Long(0,0),T.Builder=function(e){if(e)var r=e;else var r=1024;this.bb=T.ByteBuffer.allocate(r),this.space=r,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},T.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},T.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},T.Builder.prototype.dataBuffer=function(){return this.bb},T.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},T.Builder.prototype.prep=function(e,r){e>this.minalign&&(this.minalign=e);for(var o=~(this.bb.capacity()-this.space+r)+1&e-1;this.space<o+e+r;){var s=this.bb.capacity();this.bb=T.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(o)},T.Builder.prototype.pad=function(e){for(var r=0;r<e;r++)this.bb.writeInt8(--this.space,0)},T.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},T.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},T.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},T.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},T.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},T.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},T.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},T.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},T.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},T.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},T.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},T.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},T.Builder.prototype.addFieldInt8=function(e,r,o){(this.force_defaults||r!=o)&&(this.addInt8(r),this.slot(e))},T.Builder.prototype.addFieldInt16=function(e,r,o){(this.force_defaults||r!=o)&&(this.addInt16(r),this.slot(e))},T.Builder.prototype.addFieldInt32=function(e,r,o){(this.force_defaults||r!=o)&&(this.addInt32(r),this.slot(e))},T.Builder.prototype.addFieldInt64=function(e,r,o){(this.force_defaults||!r.equals(o))&&(this.addInt64(r),this.slot(e))},T.Builder.prototype.addFieldFloat32=function(e,r,o){(this.force_defaults||r!=o)&&(this.addFloat32(r),this.slot(e))},T.Builder.prototype.addFieldFloat64=function(e,r,o){(this.force_defaults||r!=o)&&(this.addFloat64(r),this.slot(e))},T.Builder.prototype.addFieldOffset=function(e,r,o){(this.force_defaults||r!=o)&&(this.addOffset(r),this.slot(e))},T.Builder.prototype.addFieldStruct=function(e,r,o){r!=o&&(this.nested(r),this.slot(e))},T.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},T.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},T.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},T.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},T.Builder.growByteBuffer=function(e){var r=e.capacity();if(r&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var o=r<<1,s=T.ByteBuffer.allocate(o);return s.setPosition(o-r),s.bytes().set(e.bytes(),o-r),s},T.Builder.prototype.addOffset=function(e){this.prep(T.SIZEOF_INT,0),this.writeInt32(this.offset()-e+T.SIZEOF_INT)},T.Builder.prototype.startObject=function(e){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=e;for(var r=0;r<e;r++)this.vtable[r]=0;this.isNested=!0,this.object_start=this.offset()},T.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),r=this.vtable_in_use-1;r>=0&&this.vtable[r]==0;r--);for(var o=r+1;r>=0;r--)this.addInt16(this.vtable[r]!=0?e-this.vtable[r]:0);var s=2;this.addInt16(e-this.object_start);var p=(o+s)*T.SIZEOF_SHORT;this.addInt16(p);var l=0,c=this.space;e:for(r=0;r<this.vtables.length;r++){var n=this.bb.capacity()-this.vtables[r];if(p==this.bb.readInt16(n)){for(var a=T.SIZEOF_SHORT;a<p;a+=T.SIZEOF_SHORT)if(this.bb.readInt16(c+a)!=this.bb.readInt16(n+a))continue e;l=this.vtables[r];break}}return l?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,l-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},T.Builder.prototype.finish=function(e,r,o){var s=o?T.SIZE_PREFIX_LENGTH:0;if(r){var p=r;if(this.prep(this.minalign,T.SIZEOF_INT+T.FILE_IDENTIFIER_LENGTH+s),p.length!=T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+T.FILE_IDENTIFIER_LENGTH);for(var l=T.FILE_IDENTIFIER_LENGTH-1;l>=0;l--)this.writeInt8(p.charCodeAt(l))}this.prep(this.minalign,T.SIZEOF_INT+s),this.addOffset(e),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},T.Builder.prototype.finishSizePrefixed=function(e,r){this.finish(e,r,!0)},T.Builder.prototype.requiredField=function(e,r){var o=this.bb.capacity()-e,s=o-this.bb.readInt32(o),p=this.bb.readInt16(s+r)!=0;if(!p)throw new Error("FlatBuffers: field "+r+" must be set")},T.Builder.prototype.startVector=function(e,r,o){this.notNested(),this.vector_num_elems=r,this.prep(T.SIZEOF_INT,e*r),this.prep(o,e*r)},T.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},T.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var r=e;else for(var r=[],o=0;o<e.length;){var s,p=e.charCodeAt(o++);if(p<55296||p>=56320)s=p;else{var l=e.charCodeAt(o++);s=(p<<10)+l+-56613888}s<128?r.push(s):(s<2048?r.push(s>>6&31|192):(s<65536?r.push(s>>12&15|224):r.push(s>>18&7|240,s>>12&63|128),r.push(s>>6&63|128)),r.push(s&63|128))}this.addInt8(0),this.startVector(1,r.length,1),this.bb.setPosition(this.space-=r.length);for(var o=0,c=this.space,n=this.bb.bytes();o<r.length;o++)n[c++]=r[o];return this.endVector()},T.Builder.prototype.createLong=function(e,r){return T.Long.create(e,r)},T.ByteBuffer=function(e){this.bytes_=e,this.position_=0},T.ByteBuffer.allocate=function(e){return new T.ByteBuffer(new Uint8Array(e))},T.ByteBuffer.prototype.clear=function(){this.position_=0},T.ByteBuffer.prototype.bytes=function(){return this.bytes_},T.ByteBuffer.prototype.position=function(){return this.position_},T.ByteBuffer.prototype.setPosition=function(e){this.position_=e},T.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},T.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},T.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},T.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},T.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},T.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},T.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},T.ByteBuffer.prototype.readInt64=function(e){return new T.Long(this.readInt32(e),this.readInt32(e+4))},T.ByteBuffer.prototype.readUint64=function(e){return new T.Long(this.readUint32(e),this.readUint32(e+4))},T.ByteBuffer.prototype.readFloat32=function(e){return T.int32[0]=this.readInt32(e),T.float32[0]},T.ByteBuffer.prototype.readFloat64=function(e){return T.int32[T.isLittleEndian?0:1]=this.readInt32(e),T.int32[T.isLittleEndian?1:0]=this.readInt32(e+4),T.float64[0]},T.ByteBuffer.prototype.writeInt8=function(e,r){this.bytes_[e]=r},T.ByteBuffer.prototype.writeUint8=function(e,r){this.bytes_[e]=r},T.ByteBuffer.prototype.writeInt16=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8},T.ByteBuffer.prototype.writeUint16=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8},T.ByteBuffer.prototype.writeInt32=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8,this.bytes_[e+2]=r>>16,this.bytes_[e+3]=r>>24},T.ByteBuffer.prototype.writeUint32=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8,this.bytes_[e+2]=r>>16,this.bytes_[e+3]=r>>24},T.ByteBuffer.prototype.writeInt64=function(e,r){this.writeInt32(e,r.low),this.writeInt32(e+4,r.high)},T.ByteBuffer.prototype.writeUint64=function(e,r){this.writeUint32(e,r.low),this.writeUint32(e+4,r.high)},T.ByteBuffer.prototype.writeFloat32=function(e,r){T.float32[0]=r,this.writeInt32(e,T.int32[0])},T.ByteBuffer.prototype.writeFloat64=function(e,r){T.float64[0]=r,this.writeInt32(e,T.int32[T.isLittleEndian?0:1]),this.writeInt32(e+4,T.int32[T.isLittleEndian?1:0])},T.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+T.SIZEOF_INT+T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",r=0;r<T.FILE_IDENTIFIER_LENGTH;r++)e+=String.fromCharCode(this.readInt8(this.position_+T.SIZEOF_INT+r));return e},T.ByteBuffer.prototype.__offset=function(e,r){var o=e-this.readInt32(e);return r<this.readInt16(o)?this.readInt16(o+r):0},T.ByteBuffer.prototype.__union=function(e,r){return e.bb_pos=r+this.readInt32(r),e.bb=this,e},T.ByteBuffer.prototype.__string=function(e,r){e+=this.readInt32(e);var o=this.readInt32(e),s="",p=0;if(e+=T.SIZEOF_INT,r===T.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+o);for(;p<o;){var l,c=this.readUint8(e+p++);if(c<192)l=c;else{var n=this.readUint8(e+p++);if(c<224)l=(c&31)<<6|n&63;else{var a=this.readUint8(e+p++);if(c<240)l=(c&15)<<12|(n&63)<<6|a&63;else{var t=this.readUint8(e+p++);l=(c&7)<<18|(n&63)<<12|(a&63)<<6|t&63}}}l<65536?s+=String.fromCharCode(l):(l-=65536,s+=String.fromCharCode((l>>10)+55296,(l&1023)+56320))}return s},T.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},T.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+T.SIZEOF_INT},T.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},T.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+T.FILE_IDENTIFIER_LENGTH);for(var r=0;r<T.FILE_IDENTIFIER_LENGTH;r++)if(e.charCodeAt(r)!=this.readInt8(this.position_+T.SIZEOF_INT+r))return!1;return!0},T.ByteBuffer.prototype.createLong=function(e,r){return T.Long.create(e,r)}}),H,Qr=I(()=>{"use strict";Ko(),(e=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.UNDEFINED=0]="UNDEFINED",c[c.FLOAT=1]="FLOAT",c[c.INT=2]="INT",c[c.STRING=3]="STRING",c[c.TENSOR=4]="TENSOR",c[c.GRAPH=5]="GRAPH",c[c.FLOATS=6]="FLOATS",c[c.INTS=7]="INTS",c[c.STRINGS=8]="STRINGS",c[c.TENSORS=9]="TENSORS",c[c.GRAPHS=10]="GRAPHS",c[c.SPARSE_TENSOR=11]="SPARSE_TENSOR",c[c.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(l=p.AttributeType||={})})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.UNKNOWN=0]="UNKNOWN",c[c.VALUE=1]="VALUE",c[c.PARAM=2]="PARAM"))(l=p.DimensionValueType||={})})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.UNDEFINED=0]="UNDEFINED",c[c.FLOAT=1]="FLOAT",c[c.UINT8=2]="UINT8",c[c.INT8=3]="INT8",c[c.UINT16=4]="UINT16",c[c.INT16=5]="INT16",c[c.INT32=6]="INT32",c[c.INT64=7]="INT64",c[c.STRING=8]="STRING",c[c.BOOL=9]="BOOL",c[c.FLOAT16=10]="FLOAT16",c[c.DOUBLE=11]="DOUBLE",c[c.UINT32=12]="UINT32",c[c.UINT64=13]="UINT64",c[c.COMPLEX64=14]="COMPLEX64",c[c.COMPLEX128=15]="COMPLEX128",c[c.BFLOAT16=16]="BFLOAT16",c[c.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",c[c.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",c[c.FLOAT8E5M2=19]="FLOAT8E5M2",c[c.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(l=p.TensorDataType||={})})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.Primitive=0]="Primitive",c[c.Fused=1]="Fused"))(l=p.NodeType||={})})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.NONE=0]="NONE",c[c.tensor_type=1]="tensor_type",c[c.sequence_type=2]="sequence_type",c[c.map_type=3]="map_type"))(l=p.TypeInfoValue||={})})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsShape(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}dim(n,a){let t=this.bb.__offset(this.bb_pos,4);return t?(a||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,a){n.addFieldOffset(0,a,0)}static createDimVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startDimVector(n,a){n.startVector(4,a,4)}static endShape(n){return n.endObject()}static createShape(n,a){return l.startShape(n),l.addDim(n,a),l.endShape(n)}}p.Shape=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsDimension(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}value(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}denotation(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}static startDimension(n){n.startObject(2)}static addValue(n,a){n.addFieldOffset(0,a,0)}static addDenotation(n,a){n.addFieldOffset(1,a,0)}static endDimension(n){return n.endObject()}static createDimension(n,a,t){return l.startDimension(n),l.addValue(n,a),l.addDenotation(n,t),l.endDimension(n)}}p.Dimension=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsDimensionValue(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):0}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,a){n.addFieldInt8(0,a,0)}static addDimValue(n,a){n.addFieldInt64(1,a,n.createLong(0,0))}static addDimParam(n,a){n.addFieldOffset(2,a,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,a,t,u){return l.startDimensionValue(n),l.addDimType(n,a),l.addDimValue(n,t),l.addDimParam(n,u),l.endDimensionValue(n)}}p.DimensionValue=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTensorTypeAndShape(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}shape(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,a){n.addFieldInt32(0,a,0)}static addShape(n,a){n.addFieldOffset(1,a,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,a,t){return l.startTensorTypeAndShape(n),l.addElemType(n,a),l.addShape(n,t),l.endTensorTypeAndShape(n)}}p.TensorTypeAndShape=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsMapType(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}valueType(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,a){n.addFieldInt32(0,a,0)}static addValueType(n,a){n.addFieldOffset(1,a,0)}static endMapType(n){return n.endObject()}static createMapType(n,a,t){return l.startMapType(n),l.addKeyType(n,a),l.addValueType(n,t),l.endMapType(n)}}p.MapType=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSequenceType(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,a){n.addFieldOffset(0,a,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,a){return l.startSequenceType(n),l.addElemType(n,a),l.endSequenceType(n)}}p.SequenceType=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(n,a,t,u){return n.prep(4,12),n.writeInt32(u),n.writeInt32(t),n.writeInt32(a),n.offset()}}p.EdgeEnd=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsNodeEdge(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,a){let t=this.bb.__offset(this.bb_pos,6);return t?(a||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+t)+n*12,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,a){let t=this.bb.__offset(this.bb_pos,8);return t?(a||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+t)+n*12,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,a){n.addFieldInt32(0,a,0)}static addInputEdges(n,a){n.addFieldOffset(1,a,0)}static startInputEdgesVector(n,a){n.startVector(12,a,4)}static addOutputEdges(n,a){n.addFieldOffset(2,a,0)}static startOutputEdgesVector(n,a){n.startVector(12,a,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,a,t,u){return l.startNodeEdge(n),l.addNodeIndex(n,a),l.addInputEdges(n,t),l.addOutputEdges(n,u),l.endNodeEdge(n)}}p.NodeEdge=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsNode(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}domain(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__string(this.bb_pos+a,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):0}executionProviderType(n){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__string(this.bb_pos+a,n):null}inputs(n,a){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+n*4,a):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,a){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+n*4,a):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,a){let t=this.bb.__offset(this.bb_pos,24);return t?(a||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.readInt32(this.bb.__vector(this.bb_pos+a)+n*4):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,a){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+n*4,a):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addDomain(n,a){n.addFieldOffset(2,a,0)}static addSinceVersion(n,a){n.addFieldInt32(3,a,0)}static addIndex(n,a){n.addFieldInt32(4,a,0)}static addOpType(n,a){n.addFieldOffset(5,a,0)}static addType(n,a){n.addFieldInt32(6,a,0)}static addExecutionProviderType(n,a){n.addFieldOffset(7,a,0)}static addInputs(n,a){n.addFieldOffset(8,a,0)}static createInputsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startInputsVector(n,a){n.startVector(4,a,4)}static addOutputs(n,a){n.addFieldOffset(9,a,0)}static createOutputsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startOutputsVector(n,a){n.startVector(4,a,4)}static addAttributes(n,a){n.addFieldOffset(10,a,0)}static createAttributesVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startAttributesVector(n,a){n.startVector(4,a,4)}static addInputArgCounts(n,a){n.addFieldOffset(11,a,0)}static createInputArgCountsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addInt32(a[t]);return n.endVector()}static startInputArgCountsVector(n,a){n.startVector(4,a,4)}static addImplicitInputs(n,a){n.addFieldOffset(12,a,0)}static createImplicitInputsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startImplicitInputsVector(n,a){n.startVector(4,a,4)}static endNode(n){return n.endObject()}static createNode(n,a,t,u,i,d,h,m,b,x,E,w,S,$){return l.startNode(n),l.addName(n,a),l.addDocString(n,t),l.addDomain(n,u),l.addSinceVersion(n,i),l.addIndex(n,d),l.addOpType(n,h),l.addType(n,m),l.addExecutionProviderType(n,b),l.addInputs(n,x),l.addOutputs(n,E),l.addAttributes(n,w),l.addInputArgCounts(n,S),l.addImplicitInputs(n,$),l.endNode(n)}}p.Node=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsValueInfo(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}type(n){let a=this.bb.__offset(this.bb_pos,8);return a?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addType(n,a){n.addFieldOffset(2,a,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,a,t,u){return l.startValueInfo(n),l.addName(n,a),l.addDocString(n,t),l.addType(n,u),l.endValueInfo(n)}}p.ValueInfo=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTypeInfo(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):0}value(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__union(n,this.bb_pos+a):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,a){n.addFieldOffset(0,a,0)}static addValueType(n,a){n.addFieldInt8(1,a,0)}static addValue(n,a){n.addFieldOffset(2,a,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,a,t,u){return l.startTypeInfo(n),l.addDenotation(n,a),l.addValueType(n,t),l.addValue(n,u),l.endTypeInfo(n)}}p.TypeInfo=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsOperatorSetId(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,a){n.addFieldOffset(0,a,0)}static addVersion(n,a){n.addFieldInt64(1,a,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,a,t){return l.startOperatorSetId(n),l.addDomain(n,a),l.addVersion(n,t),l.endOperatorSetId(n)}}p.OperatorSetId=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTensor(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}dims(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}rawData(n){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint8(this.bb.__vector(this.bb_pos+a)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,a){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+n*4,a):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addDims(n,a){n.addFieldOffset(2,a,0)}static createDimsVector(n,a){n.startVector(8,a.length,8);for(let t=a.length-1;t>=0;t--)n.addInt64(a[t]);return n.endVector()}static startDimsVector(n,a){n.startVector(8,a,8)}static addDataType(n,a){n.addFieldInt32(3,a,0)}static addRawData(n,a){n.addFieldOffset(4,a,0)}static createRawDataVector(n,a){n.startVector(1,a.length,1);for(let t=a.length-1;t>=0;t--)n.addInt8(a[t]);return n.endVector()}static startRawDataVector(n,a){n.startVector(1,a,1)}static addStringData(n,a){n.addFieldOffset(5,a,0)}static createStringDataVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startStringDataVector(n,a){n.startVector(4,a,4)}static endTensor(n){return n.endObject()}static createTensor(n,a,t,u,i,d,h){return l.startTensor(n),l.addName(n,a),l.addDocString(n,t),l.addDims(n,u),l.addDataType(n,i),l.addRawData(n,d),l.addStringData(n,h),l.endTensor(n)}}p.Tensor=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSparseTensor(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}values(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}indices(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}dims(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,a){n.addFieldOffset(0,a,0)}static addIndices(n,a){n.addFieldOffset(1,a,0)}static addDims(n,a){n.addFieldOffset(2,a,0)}static createDimsVector(n,a){n.startVector(8,a.length,8);for(let t=a.length-1;t>=0;t--)n.addInt64(a[t]);return n.endVector()}static startDimsVector(n,a){n.startVector(8,a,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,a,t,u){return l.startSparseTensor(n),l.addValues(n,a),l.addIndices(n,t),l.addDims(n,u),l.endSparseTensor(n)}}p.SparseTensor=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsAttribute(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):0}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__string(this.bb_pos+a,n):null}t(n){let a=this.bb.__offset(this.bb_pos,16);return a?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}g(n){let a=this.bb.__offset(this.bb_pos,18);return a?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}floats(n){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.readFloat32(this.bb.__vector(this.bb_pos+a)+n*4):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,a){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+n*4,a):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,a){let t=this.bb.__offset(this.bb_pos,26);return t?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,a){let t=this.bb.__offset(this.bb_pos,28);return t?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addType(n,a){n.addFieldInt32(2,a,0)}static addF(n,a){n.addFieldFloat32(3,a,0)}static addI(n,a){n.addFieldInt64(4,a,n.createLong(0,0))}static addS(n,a){n.addFieldOffset(5,a,0)}static addT(n,a){n.addFieldOffset(6,a,0)}static addG(n,a){n.addFieldOffset(7,a,0)}static addFloats(n,a){n.addFieldOffset(8,a,0)}static createFloatsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addFloat32(a[t]);return n.endVector()}static startFloatsVector(n,a){n.startVector(4,a,4)}static addInts(n,a){n.addFieldOffset(9,a,0)}static createIntsVector(n,a){n.startVector(8,a.length,8);for(let t=a.length-1;t>=0;t--)n.addInt64(a[t]);return n.endVector()}static startIntsVector(n,a){n.startVector(8,a,8)}static addStrings(n,a){n.addFieldOffset(10,a,0)}static createStringsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startStringsVector(n,a){n.startVector(4,a,4)}static addTensors(n,a){n.addFieldOffset(11,a,0)}static createTensorsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startTensorsVector(n,a){n.startVector(4,a,4)}static addGraphs(n,a){n.addFieldOffset(12,a,0)}static createGraphsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startGraphsVector(n,a){n.startVector(4,a,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,a,t,u,i,d,h,m,b,x,E,w,S,$){return l.startAttribute(n),l.addName(n,a),l.addDocString(n,t),l.addType(n,u),l.addF(n,i),l.addI(n,d),l.addS(n,h),l.addT(n,m),l.addG(n,b),l.addFloats(n,x),l.addInts(n,E),l.addStrings(n,w),l.addTensors(n,S),l.addGraphs(n,$),l.endAttribute(n)}}p.Attribute=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsGraph(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,a){let t=this.bb.__offset(this.bb_pos,4);return t?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,a){let t=this.bb.__offset(this.bb_pos,6);return t?(a||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,a){let t=this.bb.__offset(this.bb_pos,8);return t?(a||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,a){let t=this.bb.__offset(this.bb_pos,12);return t?(a||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,a){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+n*4,a):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,a){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+n*4,a):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,a){let t=this.bb.__offset(this.bb_pos,18);return t?(a||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,a){n.addFieldOffset(0,a,0)}static createInitializersVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startInitializersVector(n,a){n.startVector(4,a,4)}static addNodeArgs(n,a){n.addFieldOffset(1,a,0)}static createNodeArgsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startNodeArgsVector(n,a){n.startVector(4,a,4)}static addNodes(n,a){n.addFieldOffset(2,a,0)}static createNodesVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startNodesVector(n,a){n.startVector(4,a,4)}static addMaxNodeIndex(n,a){n.addFieldInt32(3,a,0)}static addNodeEdges(n,a){n.addFieldOffset(4,a,0)}static createNodeEdgesVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startNodeEdgesVector(n,a){n.startVector(4,a,4)}static addInputs(n,a){n.addFieldOffset(5,a,0)}static createInputsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startInputsVector(n,a){n.startVector(4,a,4)}static addOutputs(n,a){n.addFieldOffset(6,a,0)}static createOutputsVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startOutputsVector(n,a){n.startVector(4,a,4)}static addSparseInitializers(n,a){n.addFieldOffset(7,a,0)}static createSparseInitializersVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startSparseInitializersVector(n,a){n.startVector(4,a,4)}static endGraph(n){return n.endObject()}static createGraph(n,a,t,u,i,d,h,m,b){return l.startGraph(n),l.addInitializers(n,a),l.addNodeArgs(n,t),l.addNodes(n,u),l.addMaxNodeIndex(n,i),l.addNodeEdges(n,d),l.addInputs(n,h),l.addOutputs(n,m),l.addSparseInitializers(n,b),l.endGraph(n)}}p.Graph=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsModel(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,a){let t=this.bb.__offset(this.bb_pos,6);return t?(a||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}producerVersion(n){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.__string(this.bb_pos+a,n):null}domain(n){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__string(this.bb_pos+a,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__string(this.bb_pos+a,n):null}graph(n){let a=this.bb.__offset(this.bb_pos,18);return a?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}graphDocString(n){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__string(this.bb_pos+a,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,a){n.addFieldInt64(0,a,n.createLong(0,0))}static addOpsetImport(n,a){n.addFieldOffset(1,a,0)}static createOpsetImportVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startOpsetImportVector(n,a){n.startVector(4,a,4)}static addProducerName(n,a){n.addFieldOffset(2,a,0)}static addProducerVersion(n,a){n.addFieldOffset(3,a,0)}static addDomain(n,a){n.addFieldOffset(4,a,0)}static addModelVersion(n,a){n.addFieldInt64(5,a,n.createLong(0,0))}static addDocString(n,a){n.addFieldOffset(6,a,0)}static addGraph(n,a){n.addFieldOffset(7,a,0)}static addGraphDocString(n,a){n.addFieldOffset(8,a,0)}static endModel(n){return n.endObject()}static createModel(n,a,t,u,i,d,h,m,b,x){return l.startModel(n),l.addIrVersion(n,a),l.addOpsetImport(n,t),l.addProducerName(n,u),l.addProducerVersion(n,i),l.addDomain(n,d),l.addModelVersion(n,h),l.addDocString(n,m),l.addGraph(n,b),l.addGraphDocString(n,x),l.endModel(n)}}p.Model=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsKernelCreateInfos(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb.__vector(this.bb_pos+a)+n*4):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,a){n.addFieldOffset(0,a,0)}static createNodeIndicesVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addInt32(a[t]);return n.endVector()}static startNodeIndicesVector(n,a){n.startVector(4,a,4)}static addKernelDefHashes(n,a){n.addFieldOffset(1,a,0)}static createKernelDefHashesVector(n,a){n.startVector(8,a.length,8);for(let t=a.length-1;t>=0;t--)n.addInt64(a[t]);return n.endVector()}static startKernelDefHashesVector(n,a){n.startVector(8,a,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,a,t){return l.startKernelCreateInfos(n),l.addNodeIndices(n,a),l.addKernelDefHashes(n,t),l.endKernelCreateInfos(n)}}p.KernelCreateInfos=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSubGraphSessionState(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}sessionState(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,a){n.addFieldOffset(0,a,0)}static addSessionState(n,a){n.addFieldOffset(1,a,0)}static endSubGraphSessionState(n){let a=n.endObject();return n.requiredField(a,4),a}static createSubGraphSessionState(n,a,t){return l.startSubGraphSessionState(n),l.addGraphId(n,a),l.addSessionState(n,t),l.endSubGraphSessionState(n)}}p.SubGraphSessionState=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSessionState(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}subGraphSessionStates(n,a){let t=this.bb.__offset(this.bb_pos,6);return t?(a||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+n*4),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,a){n.addFieldOffset(0,a,0)}static addSubGraphSessionStates(n,a){n.addFieldOffset(1,a,0)}static createSubGraphSessionStatesVector(n,a){n.startVector(4,a.length,4);for(let t=a.length-1;t>=0;t--)n.addOffset(a[t]);return n.endVector()}static startSubGraphSessionStatesVector(n,a){n.startVector(4,a,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,a,t){return l.startSessionState(n),l.addKernels(n,a),l.addSubGraphSessionStates(n,t),l.endSessionState(n)}}p.SessionState=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={}),(e=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsInferenceSession(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}model(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}sessionState(n){let a=this.bb.__offset(this.bb_pos,8);return a?(n||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,a){n.addFieldOffset(0,a,0)}static addModel(n,a){n.addFieldOffset(1,a,0)}static addSessionState(n,a){n.addFieldOffset(2,a,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,a){n.finish(a,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,a){n.finish(a,"ORTM",!0)}static createInferenceSession(n,a,t,u){return l.startInferenceSession(n),l.addOrtVersion(n,a),l.addModel(n,t),l.addSessionState(n,u),l.endInferenceSession(n)}}p.InferenceSession=l})(s=o.fbs||={})})(r=e.experimental||={})})(H||={})}),Bh=ne((e,r)=>{"use strict";r.exports=o;function o(s,p){for(var l=new Array(arguments.length-1),c=0,n=2,a=!0;n<arguments.length;)l[c++]=arguments[n++];return new Promise(function(t,u){l[c]=function(i){if(a)if(a=!1,i)u(i);else{for(var d=new Array(arguments.length-1),h=0;h<d.length;)d[h++]=arguments[h];t.apply(null,d)}};try{s.apply(p||null,l)}catch(i){a&&(a=!1,u(i))}})}}),Vh=ne(e=>{"use strict";var r=e;r.length=function(c){var n=c.length;if(!n)return 0;for(var a=0;--n%4>1&&c.charAt(n)==="=";)++a;return Math.ceil(c.length*3)/4-a};var o=new Array(64),s=new Array(123);for(p=0;p<64;)s[o[p]=p<26?p+65:p<52?p+71:p<62?p-4:p-59|43]=p++;var p;r.encode=function(c,n,a){for(var t=null,u=[],i=0,d=0,h;n<a;){var m=c[n++];switch(d){case 0:u[i++]=o[m>>2],h=(m&3)<<4,d=1;break;case 1:u[i++]=o[h|m>>4],h=(m&15)<<2,d=2;break;case 2:u[i++]=o[h|m>>6],u[i++]=o[m&63],d=0;break}i>8191&&((t||(t=[])).push(String.fromCharCode.apply(String,u)),i=0)}return d&&(u[i++]=o[h],u[i++]=61,d===1&&(u[i++]=61)),t?(i&&t.push(String.fromCharCode.apply(String,u.slice(0,i))),t.join("")):String.fromCharCode.apply(String,u.slice(0,i))};var l="invalid encoding";r.decode=function(c,n,a){for(var t=a,u=0,i,d=0;d<c.length;){var h=c.charCodeAt(d++);if(h===61&&u>1)break;if((h=s[h])===void 0)throw Error(l);switch(u){case 0:i=h,u=1;break;case 1:n[a++]=i<<2|(h&48)>>4,i=h,u=2;break;case 2:n[a++]=(i&15)<<4|(h&60)>>2,i=h,u=3;break;case 3:n[a++]=(i&3)<<6|h,u=0;break}}if(u===1)throw Error(l);return a-t},r.test=function(c){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(c)}}),Mh=ne((e,r)=>{"use strict";r.exports=o;function o(){this._listeners={}}o.prototype.on=function(s,p,l){return(this._listeners[s]||(this._listeners[s]=[])).push({fn:p,ctx:l||this}),this},o.prototype.off=function(s,p){if(s===void 0)this._listeners={};else if(p===void 0)this._listeners[s]=[];else for(var l=this._listeners[s],c=0;c<l.length;)l[c].fn===p?l.splice(c,1):++c;return this},o.prototype.emit=function(s){var p=this._listeners[s];if(p){for(var l=[],c=1;c<arguments.length;)l.push(arguments[c++]);for(c=0;c<p.length;)p[c].fn.apply(p[c++].ctx,l)}return this}}),zh=ne((e,r)=>{"use strict";r.exports=o(o);function o(n){return typeof Float32Array<"u"?function(){var a=new Float32Array([-0]),t=new Uint8Array(a.buffer),u=t[3]===128;function i(b,x,E){a[0]=b,x[E]=t[0],x[E+1]=t[1],x[E+2]=t[2],x[E+3]=t[3]}function d(b,x,E){a[0]=b,x[E]=t[3],x[E+1]=t[2],x[E+2]=t[1],x[E+3]=t[0]}n.writeFloatLE=u?i:d,n.writeFloatBE=u?d:i;function h(b,x){return t[0]=b[x],t[1]=b[x+1],t[2]=b[x+2],t[3]=b[x+3],a[0]}function m(b,x){return t[3]=b[x],t[2]=b[x+1],t[1]=b[x+2],t[0]=b[x+3],a[0]}n.readFloatLE=u?h:m,n.readFloatBE=u?m:h}():function(){function a(u,i,d,h){var m=i<0?1:0;if(m&&(i=-i),i===0)u(1/i>0?0:2147483648,d,h);else if(isNaN(i))u(2143289344,d,h);else if(i>34028234663852886e22)u((m<<31|2139095040)>>>0,d,h);else if(i<11754943508222875e-54)u((m<<31|Math.round(i/1401298464324817e-60))>>>0,d,h);else{var b=Math.floor(Math.log(i)/Math.LN2),x=Math.round(i*Math.pow(2,-b)*8388608)&8388607;u((m<<31|b+127<<23|x)>>>0,d,h)}}n.writeFloatLE=a.bind(null,s),n.writeFloatBE=a.bind(null,p);function t(u,i,d){var h=u(i,d),m=(h>>31)*2+1,b=h>>>23&255,x=h&8388607;return b===255?x?NaN:m*(1/0):b===0?m*1401298464324817e-60*x:m*Math.pow(2,b-150)*(x+8388608)}n.readFloatLE=t.bind(null,l),n.readFloatBE=t.bind(null,c)}(),typeof Float64Array<"u"?function(){var a=new Float64Array([-0]),t=new Uint8Array(a.buffer),u=t[7]===128;function i(b,x,E){a[0]=b,x[E]=t[0],x[E+1]=t[1],x[E+2]=t[2],x[E+3]=t[3],x[E+4]=t[4],x[E+5]=t[5],x[E+6]=t[6],x[E+7]=t[7]}function d(b,x,E){a[0]=b,x[E]=t[7],x[E+1]=t[6],x[E+2]=t[5],x[E+3]=t[4],x[E+4]=t[3],x[E+5]=t[2],x[E+6]=t[1],x[E+7]=t[0]}n.writeDoubleLE=u?i:d,n.writeDoubleBE=u?d:i;function h(b,x){return t[0]=b[x],t[1]=b[x+1],t[2]=b[x+2],t[3]=b[x+3],t[4]=b[x+4],t[5]=b[x+5],t[6]=b[x+6],t[7]=b[x+7],a[0]}function m(b,x){return t[7]=b[x],t[6]=b[x+1],t[5]=b[x+2],t[4]=b[x+3],t[3]=b[x+4],t[2]=b[x+5],t[1]=b[x+6],t[0]=b[x+7],a[0]}n.readDoubleLE=u?h:m,n.readDoubleBE=u?m:h}():function(){function a(u,i,d,h,m,b){var x=h<0?1:0;if(x&&(h=-h),h===0)u(0,m,b+i),u(1/h>0?0:2147483648,m,b+d);else if(isNaN(h))u(0,m,b+i),u(2146959360,m,b+d);else if(h>17976931348623157e292)u(0,m,b+i),u((x<<31|2146435072)>>>0,m,b+d);else{var E;if(h<22250738585072014e-324)E=h/5e-324,u(E>>>0,m,b+i),u((x<<31|E/4294967296)>>>0,m,b+d);else{var w=Math.floor(Math.log(h)/Math.LN2);w===1024&&(w=1023),E=h*Math.pow(2,-w),u(E*4503599627370496>>>0,m,b+i),u((x<<31|w+1023<<20|E*1048576&1048575)>>>0,m,b+d)}}}n.writeDoubleLE=a.bind(null,s,0,4),n.writeDoubleBE=a.bind(null,p,4,0);function t(u,i,d,h,m){var b=u(h,m+i),x=u(h,m+d),E=(x>>31)*2+1,w=x>>>20&2047,S=4294967296*(x&1048575)+b;return w===2047?S?NaN:E*(1/0):w===0?E*5e-324*S:E*Math.pow(2,w-1075)*(S+4503599627370496)}n.readDoubleLE=t.bind(null,l,0,4),n.readDoubleBE=t.bind(null,c,4,0)}(),n}function s(n,a,t){a[t]=n&255,a[t+1]=n>>>8&255,a[t+2]=n>>>16&255,a[t+3]=n>>>24}function p(n,a,t){a[t]=n>>>24,a[t+1]=n>>>16&255,a[t+2]=n>>>8&255,a[t+3]=n&255}function l(n,a){return(n[a]|n[a+1]<<8|n[a+2]<<16|n[a+3]<<24)>>>0}function c(n,a){return(n[a]<<24|n[a+1]<<16|n[a+2]<<8|n[a+3])>>>0}}),Uh=ne((exports,module)=>{"use strict";module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}}),Gh=ne(e=>{"use strict";var r=e;r.length=function(o){for(var s=0,p=0,l=0;l<o.length;++l)p=o.charCodeAt(l),p<128?s+=1:p<2048?s+=2:(p&64512)===55296&&(o.charCodeAt(l+1)&64512)===56320?(++l,s+=4):s+=3;return s},r.read=function(o,s,p){var l=p-s;if(l<1)return"";for(var c=null,n=[],a=0,t;s<p;)t=o[s++],t<128?n[a++]=t:t>191&&t<224?n[a++]=(t&31)<<6|o[s++]&63:t>239&&t<365?(t=((t&7)<<18|(o[s++]&63)<<12|(o[s++]&63)<<6|o[s++]&63)-65536,n[a++]=55296+(t>>10),n[a++]=56320+(t&1023)):n[a++]=(t&15)<<12|(o[s++]&63)<<6|o[s++]&63,a>8191&&((c||(c=[])).push(String.fromCharCode.apply(String,n)),a=0);return c?(a&&c.push(String.fromCharCode.apply(String,n.slice(0,a))),c.join("")):String.fromCharCode.apply(String,n.slice(0,a))},r.write=function(o,s,p){for(var l=p,c,n,a=0;a<o.length;++a)c=o.charCodeAt(a),c<128?s[p++]=c:c<2048?(s[p++]=c>>6|192,s[p++]=c&63|128):(c&64512)===55296&&((n=o.charCodeAt(a+1))&64512)===56320?(c=65536+((c&1023)<<10)+(n&1023),++a,s[p++]=c>>18|240,s[p++]=c>>12&63|128,s[p++]=c>>6&63|128,s[p++]=c&63|128):(s[p++]=c>>12|224,s[p++]=c>>6&63|128,s[p++]=c&63|128);return p-l}}),Hh=ne((e,r)=>{"use strict";r.exports=o;function o(s,p,l){var c=l||8192,n=c>>>1,a=null,t=c;return function(u){if(u<1||u>n)return s(u);t+u>c&&(a=s(c),t=0);var i=p.call(a,t,t+=u);return t&7&&(t=(t|7)+1),i}}}),qh=ne((e,r)=>{"use strict";r.exports=s;var o=wt();function s(n,a){this.lo=n>>>0,this.hi=a>>>0}var p=s.zero=new s(0,0);p.toNumber=function(){return 0},p.zzEncode=p.zzDecode=function(){return this},p.length=function(){return 1};var l=s.zeroHash="\0\0\0\0\0\0\0\0";s.fromNumber=function(n){if(n===0)return p;var a=n<0;a&&(n=-n);var t=n>>>0,u=(n-t)/4294967296>>>0;return a&&(u=~u>>>0,t=~t>>>0,++t>4294967295&&(t=0,++u>4294967295&&(u=0))),new s(t,u)},s.from=function(n){if(typeof n=="number")return s.fromNumber(n);if(o.isString(n))if(o.Long)n=o.Long.fromString(n);else return s.fromNumber(parseInt(n,10));return n.low||n.high?new s(n.low>>>0,n.high>>>0):p},s.prototype.toNumber=function(n){if(!n&&this.hi>>>31){var a=~this.lo+1>>>0,t=~this.hi>>>0;return a||(t=t+1>>>0),-(a+t*4294967296)}return this.lo+this.hi*4294967296},s.prototype.toLong=function(n){return o.Long?new o.Long(this.lo|0,this.hi|0,!!n):{low:this.lo|0,high:this.hi|0,unsigned:!!n}};var c=String.prototype.charCodeAt;s.fromHash=function(n){return n===l?p:new s((c.call(n,0)|c.call(n,1)<<8|c.call(n,2)<<16|c.call(n,3)<<24)>>>0,(c.call(n,4)|c.call(n,5)<<8|c.call(n,6)<<16|c.call(n,7)<<24)>>>0)},s.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},s.prototype.zzEncode=function(){var n=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^n)>>>0,this.lo=(this.lo<<1^n)>>>0,this},s.prototype.zzDecode=function(){var n=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^n)>>>0,this.hi=(this.hi>>>1^n)>>>0,this},s.prototype.length=function(){var n=this.lo,a=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return t===0?a===0?n<16384?n<128?1:2:n<2097152?3:4:a<16384?a<128?5:6:a<2097152?7:8:t<128?9:10}}),wt=ne(e=>{"use strict";var r=e;r.asPromise=Bh(),r.base64=Vh(),r.EventEmitter=Mh(),r.float=zh(),r.inquire=Uh(),r.utf8=Gh(),r.pool=Hh(),r.LongBits=qh(),r.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),r.global=r.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||e,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(p){return typeof p=="number"&&isFinite(p)&&Math.floor(p)===p},r.isString=function(p){return typeof p=="string"||p instanceof String},r.isObject=function(p){return p&&typeof p=="object"},r.isset=r.isSet=function(p,l){var c=p[l];return c!=null&&p.hasOwnProperty(l)?typeof c!="object"||(Array.isArray(c)?c.length:Object.keys(c).length)>0:!1},r.Buffer=function(){try{var p=r.inquire("buffer").Buffer;return p.prototype.utf8Write?p:null}catch{return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(p){return typeof p=="number"?r.Buffer?r._Buffer_allocUnsafe(p):new r.Array(p):r.Buffer?r._Buffer_from(p):typeof Uint8Array>"u"?p:new Uint8Array(p)},r.Array=typeof Uint8Array<"u"?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(p){return p?r.LongBits.from(p).toHash():r.LongBits.zeroHash},r.longFromHash=function(p,l){var c=r.LongBits.fromHash(p);return r.Long?r.Long.fromBits(c.lo,c.hi,l):c.toNumber(!!l)};function o(p,l,c){for(var n=Object.keys(l),a=0;a<n.length;++a)(p[n[a]]===void 0||!c)&&(p[n[a]]=l[n[a]]);return p}r.merge=o,r.lcFirst=function(p){return p.charAt(0).toLowerCase()+p.substring(1)};function s(p){function l(c,n){if(!(this instanceof l))return new l(c,n);Object.defineProperty(this,"message",{get:function(){return c}}),Error.captureStackTrace?Error.captureStackTrace(this,l):Object.defineProperty(this,"stack",{value:new Error().stack||""}),n&&o(this,n)}return l.prototype=Object.create(Error.prototype,{constructor:{value:l,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return p},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),l}r.newError=s,r.ProtocolError=s("ProtocolError"),r.oneOfGetter=function(p){for(var l={},c=0;c<p.length;++c)l[p[c]]=1;return function(){for(var n=Object.keys(this),a=n.length-1;a>-1;--a)if(l[n[a]]===1&&this[n[a]]!==void 0&&this[n[a]]!==null)return n[a]}},r.oneOfSetter=function(p){return function(l){for(var c=0;c<p.length;++c)p[c]!==l&&delete this[p[c]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var p=r.Buffer;if(!p){r._Buffer_from=r._Buffer_allocUnsafe=null;return}r._Buffer_from=p.from!==Uint8Array.from&&p.from||function(l,c){return new p(l,c)},r._Buffer_allocUnsafe=p.allocUnsafe||function(l){return new p(l)}}}),wl=ne((e,r)=>{"use strict";r.exports=u;var o=wt(),s,p=o.LongBits,l=o.base64,c=o.utf8;function n(w,S,$){this.fn=w,this.len=S,this.next=void 0,this.val=$}function a(){}function t(w){this.head=w.head,this.tail=w.tail,this.len=w.len,this.next=w.states}function u(){this.len=0,this.head=new n(a,0,0),this.tail=this.head,this.states=null}var i=function(){return o.Buffer?function(){return(u.create=function(){return new s})()}:function(){return new u}};u.create=i(),u.alloc=function(w){return new o.Array(w)},o.Array!==Array&&(u.alloc=o.pool(u.alloc,o.Array.prototype.subarray)),u.prototype._push=function(w,S,$){return this.tail=this.tail.next=new n(w,S,$),this.len+=S,this};function d(w,S,$){S[$]=w&255}function h(w,S,$){for(;w>127;)S[$++]=w&127|128,w>>>=7;S[$]=w}function m(w,S){this.len=w,this.next=void 0,this.val=S}m.prototype=Object.create(n.prototype),m.prototype.fn=h,u.prototype.uint32=function(w){return this.len+=(this.tail=this.tail.next=new m((w=w>>>0)<128?1:w<16384?2:w<2097152?3:w<268435456?4:5,w)).len,this},u.prototype.int32=function(w){return w<0?this._push(b,10,p.fromNumber(w)):this.uint32(w)},u.prototype.sint32=function(w){return this.uint32((w<<1^w>>31)>>>0)};function b(w,S,$){for(;w.hi;)S[$++]=w.lo&127|128,w.lo=(w.lo>>>7|w.hi<<25)>>>0,w.hi>>>=7;for(;w.lo>127;)S[$++]=w.lo&127|128,w.lo=w.lo>>>7;S[$++]=w.lo}u.prototype.uint64=function(w){var S=p.from(w);return this._push(b,S.length(),S)},u.prototype.int64=u.prototype.uint64,u.prototype.sint64=function(w){var S=p.from(w).zzEncode();return this._push(b,S.length(),S)},u.prototype.bool=function(w){return this._push(d,1,w?1:0)};function x(w,S,$){S[$]=w&255,S[$+1]=w>>>8&255,S[$+2]=w>>>16&255,S[$+3]=w>>>24}u.prototype.fixed32=function(w){return this._push(x,4,w>>>0)},u.prototype.sfixed32=u.prototype.fixed32,u.prototype.fixed64=function(w){var S=p.from(w);return this._push(x,4,S.lo)._push(x,4,S.hi)},u.prototype.sfixed64=u.prototype.fixed64,u.prototype.float=function(w){return this._push(o.float.writeFloatLE,4,w)},u.prototype.double=function(w){return this._push(o.float.writeDoubleLE,8,w)};var E=o.Array.prototype.set?function(w,S,$){S.set(w,$)}:function(w,S,$){for(var F=0;F<w.length;++F)S[$+F]=w[F]};u.prototype.bytes=function(w){var S=w.length>>>0;if(!S)return this._push(d,1,0);if(o.isString(w)){var $=u.alloc(S=l.length(w));l.decode(w,$,0),w=$}return this.uint32(S)._push(E,S,w)},u.prototype.string=function(w){var S=c.length(w);return S?this.uint32(S)._push(c.write,S,w):this._push(d,1,0)},u.prototype.fork=function(){return this.states=new t(this),this.head=this.tail=new n(a,0,0),this.len=0,this},u.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new n(a,0,0),this.len=0),this},u.prototype.ldelim=function(){var w=this.head,S=this.tail,$=this.len;return this.reset().uint32($),$&&(this.tail.next=w.next,this.tail=S,this.len+=$),this},u.prototype.finish=function(){for(var w=this.head.next,S=this.constructor.alloc(this.len),$=0;w;)w.fn(w.val,S,$),$+=w.len,w=w.next;return S},u._configure=function(w){s=w,u.create=i(),s._configure()}}),Wh=ne((e,r)=>{"use strict";r.exports=p;var o=wl();(p.prototype=Object.create(o.prototype)).constructor=p;var s=wt();function p(){o.call(this)}p._configure=function(){p.alloc=s._Buffer_allocUnsafe,p.writeBytesBuffer=s.Buffer&&s.Buffer.prototype instanceof Uint8Array&&s.Buffer.prototype.set.name==="set"?function(c,n,a){n.set(c,a)}:function(c,n,a){if(c.copy)c.copy(n,a,0,c.length);else for(var t=0;t<c.length;)n[a++]=c[t++]}},p.prototype.bytes=function(c){s.isString(c)&&(c=s._Buffer_from(c,"base64"));var n=c.length>>>0;return this.uint32(n),n&&this._push(p.writeBytesBuffer,n,c),this};function l(c,n,a){c.length<40?s.utf8.write(c,n,a):n.utf8Write?n.utf8Write(c,a):n.write(c,a)}p.prototype.string=function(c){var n=s.Buffer.byteLength(c);return this.uint32(n),n&&this._push(l,n,c),this},p._configure()}),vl=ne((e,r)=>{"use strict";r.exports=n;var o=wt(),s,p=o.LongBits,l=o.utf8;function c(h,m){return RangeError("index out of range: "+h.pos+" + "+(m||1)+" > "+h.len)}function n(h){this.buf=h,this.pos=0,this.len=h.length}var a=typeof Uint8Array<"u"?function(h){if(h instanceof Uint8Array||Array.isArray(h))return new n(h);throw Error("illegal buffer")}:function(h){if(Array.isArray(h))return new n(h);throw Error("illegal buffer")},t=function(){return o.Buffer?function(h){return(n.create=function(m){return o.Buffer.isBuffer(m)?new s(m):a(m)})(h)}:a};n.create=t(),n.prototype._slice=o.Array.prototype.subarray||o.Array.prototype.slice,n.prototype.uint32=function(){var h=4294967295;return function(){if(h=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(h=(h|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return h;if((this.pos+=5)>this.len)throw this.pos=this.len,c(this,10);return h}}(),n.prototype.int32=function(){return this.uint32()|0},n.prototype.sint32=function(){var h=this.uint32();return h>>>1^-(h&1)|0};function u(){var h=new p(0,0),m=0;if(this.len-this.pos>4){for(;m<4;++m)if(h.lo=(h.lo|(this.buf[this.pos]&127)<<m*7)>>>0,this.buf[this.pos++]<128)return h;if(h.lo=(h.lo|(this.buf[this.pos]&127)<<28)>>>0,h.hi=(h.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return h;m=0}else{for(;m<3;++m){if(this.pos>=this.len)throw c(this);if(h.lo=(h.lo|(this.buf[this.pos]&127)<<m*7)>>>0,this.buf[this.pos++]<128)return h}return h.lo=(h.lo|(this.buf[this.pos++]&127)<<m*7)>>>0,h}if(this.len-this.pos>4){for(;m<5;++m)if(h.hi=(h.hi|(this.buf[this.pos]&127)<<m*7+3)>>>0,this.buf[this.pos++]<128)return h}else for(;m<5;++m){if(this.pos>=this.len)throw c(this);if(h.hi=(h.hi|(this.buf[this.pos]&127)<<m*7+3)>>>0,this.buf[this.pos++]<128)return h}throw Error("invalid varint encoding")}n.prototype.bool=function(){return this.uint32()!==0};function i(h,m){return(h[m-4]|h[m-3]<<8|h[m-2]<<16|h[m-1]<<24)>>>0}n.prototype.fixed32=function(){if(this.pos+4>this.len)throw c(this,4);return i(this.buf,this.pos+=4)},n.prototype.sfixed32=function(){if(this.pos+4>this.len)throw c(this,4);return i(this.buf,this.pos+=4)|0};function d(){if(this.pos+8>this.len)throw c(this,8);return new p(i(this.buf,this.pos+=4),i(this.buf,this.pos+=4))}n.prototype.float=function(){if(this.pos+4>this.len)throw c(this,4);var h=o.float.readFloatLE(this.buf,this.pos);return this.pos+=4,h},n.prototype.double=function(){if(this.pos+8>this.len)throw c(this,4);var h=o.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,h},n.prototype.bytes=function(){var h=this.uint32(),m=this.pos,b=this.pos+h;if(b>this.len)throw c(this,h);if(this.pos+=h,Array.isArray(this.buf))return this.buf.slice(m,b);if(m===b){var x=o.Buffer;return x?x.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,m,b)},n.prototype.string=function(){var h=this.bytes();return l.read(h,0,h.length)},n.prototype.skip=function(h){if(typeof h=="number"){if(this.pos+h>this.len)throw c(this,h);this.pos+=h}else do if(this.pos>=this.len)throw c(this);while(this.buf[this.pos++]&128);return this},n.prototype.skipType=function(h){switch(h){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(h=this.uint32()&7)!==4;)this.skipType(h);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+h+" at offset "+this.pos)}return this},n._configure=function(h){s=h,n.create=t(),s._configure();var m=o.Long?"toLong":"toNumber";o.merge(n.prototype,{int64:function(){return u.call(this)[m](!1)},uint64:function(){return u.call(this)[m](!0)},sint64:function(){return u.call(this).zzDecode()[m](!1)},fixed64:function(){return d.call(this)[m](!0)},sfixed64:function(){return d.call(this)[m](!1)}})}}),Xh=ne((e,r)=>{"use strict";r.exports=p;var o=vl();(p.prototype=Object.create(o.prototype)).constructor=p;var s=wt();function p(l){o.call(this,l)}p._configure=function(){s.Buffer&&(p.prototype._slice=s.Buffer.prototype.slice)},p.prototype.string=function(){var l=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+l,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+l,this.len))},p._configure()}),Kh=ne((e,r)=>{"use strict";r.exports=s;var o=wt();(s.prototype=Object.create(o.EventEmitter.prototype)).constructor=s;function s(p,l,c){if(typeof p!="function")throw TypeError("rpcImpl must be a function");o.EventEmitter.call(this),this.rpcImpl=p,this.requestDelimited=!!l,this.responseDelimited=!!c}s.prototype.rpcCall=function p(l,c,n,a,t){if(!a)throw TypeError("request must be specified");var u=this;if(!t)return o.asPromise(p,u,l,c,n,a);if(!u.rpcImpl){setTimeout(function(){t(Error("already ended"))},0);return}try{return u.rpcImpl(l,c[u.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(i,d){if(i)return u.emit("error",i,l),t(i);if(d===null){u.end(!0);return}if(!(d instanceof n))try{d=n[u.responseDelimited?"decodeDelimited":"decode"](d)}catch(h){return u.emit("error",h,l),t(h)}return u.emit("data",d,l),t(null,d)})}catch(i){u.emit("error",i,l),setTimeout(function(){t(i)},0);return}},s.prototype.end=function(p){return this.rpcImpl&&(p||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Zh=ne(e=>{"use strict";var r=e;r.Service=Kh()}),Jh=ne((e,r)=>{"use strict";r.exports={}}),Yh=ne(e=>{"use strict";var r=e;r.build="minimal",r.Writer=wl(),r.BufferWriter=Wh(),r.Reader=vl(),r.BufferReader=Xh(),r.util=wt(),r.rpc=Zh(),r.roots=Jh(),r.configure=o;function o(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}o()}),Qh=ne((e,r)=>{"use strict";r.exports=Yh()}),br=ne((e,r)=>{"use strict";var o=Qh(),s=o.Reader,p=o.Writer,l=o.util,c=o.roots.default||(o.roots.default={});c.onnx=function(){var n={};return n.Version=function(){var a={},t=Object.create(a);return t[a[0]="_START_VERSION"]=0,t[a[1]="IR_VERSION_2017_10_10"]=1,t[a[2]="IR_VERSION_2017_10_30"]=2,t[a[3]="IR_VERSION_2017_11_3"]=3,t[a[4]="IR_VERSION_2019_1_22"]=4,t[a[5]="IR_VERSION_2019_3_18"]=5,t[a[6]="IR_VERSION_2019_9_19"]=6,t[a[7]="IR_VERSION_2020_5_8"]=7,t[a[8]="IR_VERSION_2021_7_30"]=8,t[a[9]="IR_VERSION"]=9,t}(),n.AttributeProto=function(){function a(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.name="",a.prototype.refAttrName="",a.prototype.docString="",a.prototype.type=0,a.prototype.f=0,a.prototype.i=l.Long?l.Long.fromBits(0,0,!1):0,a.prototype.s=l.newBuffer([]),a.prototype.t=null,a.prototype.g=null,a.prototype.sparseTensor=null,a.prototype.tp=null,a.prototype.floats=l.emptyArray,a.prototype.ints=l.emptyArray,a.prototype.strings=l.emptyArray,a.prototype.tensors=l.emptyArray,a.prototype.graphs=l.emptyArray,a.prototype.sparseTensors=l.emptyArray,a.prototype.typeProtos=l.emptyArray,a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&u.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&u.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&u.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&c.onnx.TensorProto.encode(t.t,u.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&c.onnx.GraphProto.encode(t.g,u.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){u.uint32(58).fork();for(var i=0;i<t.floats.length;++i)u.float(t.floats[i]);u.ldelim()}if(t.ints!=null&&t.ints.length){u.uint32(66).fork();for(var i=0;i<t.ints.length;++i)u.int64(t.ints[i]);u.ldelim()}if(t.strings!=null&&t.strings.length)for(var i=0;i<t.strings.length;++i)u.uint32(74).bytes(t.strings[i]);if(t.tensors!=null&&t.tensors.length)for(var i=0;i<t.tensors.length;++i)c.onnx.TensorProto.encode(t.tensors[i],u.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(var i=0;i<t.graphs.length;++i)c.onnx.GraphProto.encode(t.graphs[i],u.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&c.onnx.TypeProto.encode(t.tp,u.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(var i=0;i<t.typeProtos.length;++i)c.onnx.TypeProto.encode(t.typeProtos[i],u.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&u.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&u.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&c.onnx.SparseTensorProto.encode(t.sparseTensor,u.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(var i=0;i<t.sparseTensors.length;++i)c.onnx.SparseTensorProto.encode(t.sparseTensors[i],u.uint32(186).fork()).ldelim();return u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.AttributeProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.name=t.string();break}case 21:{d.refAttrName=t.string();break}case 13:{d.docString=t.string();break}case 20:{d.type=t.int32();break}case 2:{d.f=t.float();break}case 3:{d.i=t.int64();break}case 4:{d.s=t.bytes();break}case 5:{d.t=c.onnx.TensorProto.decode(t,t.uint32());break}case 6:{d.g=c.onnx.GraphProto.decode(t,t.uint32());break}case 22:{d.sparseTensor=c.onnx.SparseTensorProto.decode(t,t.uint32());break}case 14:{d.tp=c.onnx.TypeProto.decode(t,t.uint32());break}case 7:{if(d.floats&&d.floats.length||(d.floats=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.floats.push(t.float());else d.floats.push(t.float());break}case 8:{if(d.ints&&d.ints.length||(d.ints=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.ints.push(t.int64());else d.ints.push(t.int64());break}case 9:{d.strings&&d.strings.length||(d.strings=[]),d.strings.push(t.bytes());break}case 10:{d.tensors&&d.tensors.length||(d.tensors=[]),d.tensors.push(c.onnx.TensorProto.decode(t,t.uint32()));break}case 11:{d.graphs&&d.graphs.length||(d.graphs=[]),d.graphs.push(c.onnx.GraphProto.decode(t,t.uint32()));break}case 23:{d.sparseTensors&&d.sparseTensors.length||(d.sparseTensors=[]),d.sparseTensors.push(c.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 15:{d.typeProtos&&d.typeProtos.length||(d.typeProtos=[]),d.typeProtos.push(c.onnx.TypeProto.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!l.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!l.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!l.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!l.isInteger(t.i)&&!(t.i&&l.isInteger(t.i.low)&&l.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||l.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")){var u=c.onnx.TensorProto.verify(t.t);if(u)return"t."+u}if(t.g!=null&&t.hasOwnProperty("g")){var u=c.onnx.GraphProto.verify(t.g);if(u)return"g."+u}if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")){var u=c.onnx.SparseTensorProto.verify(t.sparseTensor);if(u)return"sparseTensor."+u}if(t.tp!=null&&t.hasOwnProperty("tp")){var u=c.onnx.TypeProto.verify(t.tp);if(u)return"tp."+u}if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var i=0;i<t.floats.length;++i)if(typeof t.floats[i]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(var i=0;i<t.ints.length;++i)if(!l.isInteger(t.ints[i])&&!(t.ints[i]&&l.isInteger(t.ints[i].low)&&l.isInteger(t.ints[i].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(var i=0;i<t.strings.length;++i)if(!(t.strings[i]&&typeof t.strings[i].length=="number"||l.isString(t.strings[i])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(var i=0;i<t.tensors.length;++i){var u=c.onnx.TensorProto.verify(t.tensors[i]);if(u)return"tensors."+u}}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(var i=0;i<t.graphs.length;++i){var u=c.onnx.GraphProto.verify(t.graphs[i]);if(u)return"graphs."+u}}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(var i=0;i<t.sparseTensors.length;++i){var u=c.onnx.SparseTensorProto.verify(t.sparseTensors[i]);if(u)return"sparseTensors."+u}}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(var i=0;i<t.typeProtos.length;++i){var u=c.onnx.TypeProto.verify(t.typeProtos[i]);if(u)return"typeProtos."+u}}return null},a.fromObject=function(t){if(t instanceof c.onnx.AttributeProto)return t;var u=new c.onnx.AttributeProto;switch(t.name!=null&&(u.name=String(t.name)),t.refAttrName!=null&&(u.refAttrName=String(t.refAttrName)),t.docString!=null&&(u.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){u.type=t.type;break}break;case"UNDEFINED":case 0:u.type=0;break;case"FLOAT":case 1:u.type=1;break;case"INT":case 2:u.type=2;break;case"STRING":case 3:u.type=3;break;case"TENSOR":case 4:u.type=4;break;case"GRAPH":case 5:u.type=5;break;case"SPARSE_TENSOR":case 11:u.type=11;break;case"TYPE_PROTO":case 13:u.type=13;break;case"FLOATS":case 6:u.type=6;break;case"INTS":case 7:u.type=7;break;case"STRINGS":case 8:u.type=8;break;case"TENSORS":case 9:u.type=9;break;case"GRAPHS":case 10:u.type=10;break;case"SPARSE_TENSORS":case 12:u.type=12;break;case"TYPE_PROTOS":case 14:u.type=14;break}if(t.f!=null&&(u.f=Number(t.f)),t.i!=null&&(l.Long?(u.i=l.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?u.i=parseInt(t.i,10):typeof t.i=="number"?u.i=t.i:typeof t.i=="object"&&(u.i=new l.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?l.base64.decode(t.s,u.s=l.newBuffer(l.base64.length(t.s)),0):t.s.length>=0&&(u.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");u.t=c.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");u.g=c.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");u.sparseTensor=c.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");u.tp=c.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");u.floats=[];for(var i=0;i<t.floats.length;++i)u.floats[i]=Number(t.floats[i])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");u.ints=[];for(var i=0;i<t.ints.length;++i)l.Long?(u.ints[i]=l.Long.fromValue(t.ints[i])).unsigned=!1:typeof t.ints[i]=="string"?u.ints[i]=parseInt(t.ints[i],10):typeof t.ints[i]=="number"?u.ints[i]=t.ints[i]:typeof t.ints[i]=="object"&&(u.ints[i]=new l.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");u.strings=[];for(var i=0;i<t.strings.length;++i)typeof t.strings[i]=="string"?l.base64.decode(t.strings[i],u.strings[i]=l.newBuffer(l.base64.length(t.strings[i])),0):t.strings[i].length>=0&&(u.strings[i]=t.strings[i])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");u.tensors=[];for(var i=0;i<t.tensors.length;++i){if(typeof t.tensors[i]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");u.tensors[i]=c.onnx.TensorProto.fromObject(t.tensors[i])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");u.graphs=[];for(var i=0;i<t.graphs.length;++i){if(typeof t.graphs[i]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");u.graphs[i]=c.onnx.GraphProto.fromObject(t.graphs[i])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");u.sparseTensors=[];for(var i=0;i<t.sparseTensors.length;++i){if(typeof t.sparseTensors[i]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");u.sparseTensors[i]=c.onnx.SparseTensorProto.fromObject(t.sparseTensors[i])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");u.typeProtos=[];for(var i=0;i<t.typeProtos.length;++i){if(typeof t.typeProtos[i]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");u.typeProtos[i]=c.onnx.TypeProto.fromObject(t.typeProtos[i])}}return u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.floats=[],i.ints=[],i.strings=[],i.tensors=[],i.graphs=[],i.typeProtos=[],i.sparseTensors=[]),u.defaults){if(i.name="",i.f=0,l.Long){var d=new l.Long(0,0,!1);i.i=u.longs===String?d.toString():u.longs===Number?d.toNumber():d}else i.i=u.longs===String?"0":0;u.bytes===String?i.s="":(i.s=[],u.bytes!==Array&&(i.s=l.newBuffer(i.s))),i.t=null,i.g=null,i.docString="",i.tp=null,i.type=u.enums===String?"UNDEFINED":0,i.refAttrName="",i.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(i.f=u.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?i.i=u.longs===String?String(t.i):t.i:i.i=u.longs===String?l.Long.prototype.toString.call(t.i):u.longs===Number?new l.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(i.s=u.bytes===String?l.base64.encode(t.s,0,t.s.length):u.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(i.t=c.onnx.TensorProto.toObject(t.t,u)),t.g!=null&&t.hasOwnProperty("g")&&(i.g=c.onnx.GraphProto.toObject(t.g,u)),t.floats&&t.floats.length){i.floats=[];for(var h=0;h<t.floats.length;++h)i.floats[h]=u.json&&!isFinite(t.floats[h])?String(t.floats[h]):t.floats[h]}if(t.ints&&t.ints.length){i.ints=[];for(var h=0;h<t.ints.length;++h)typeof t.ints[h]=="number"?i.ints[h]=u.longs===String?String(t.ints[h]):t.ints[h]:i.ints[h]=u.longs===String?l.Long.prototype.toString.call(t.ints[h]):u.longs===Number?new l.LongBits(t.ints[h].low>>>0,t.ints[h].high>>>0).toNumber():t.ints[h]}if(t.strings&&t.strings.length){i.strings=[];for(var h=0;h<t.strings.length;++h)i.strings[h]=u.bytes===String?l.base64.encode(t.strings[h],0,t.strings[h].length):u.bytes===Array?Array.prototype.slice.call(t.strings[h]):t.strings[h]}if(t.tensors&&t.tensors.length){i.tensors=[];for(var h=0;h<t.tensors.length;++h)i.tensors[h]=c.onnx.TensorProto.toObject(t.tensors[h],u)}if(t.graphs&&t.graphs.length){i.graphs=[];for(var h=0;h<t.graphs.length;++h)i.graphs[h]=c.onnx.GraphProto.toObject(t.graphs[h],u)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(i.tp=c.onnx.TypeProto.toObject(t.tp,u)),t.typeProtos&&t.typeProtos.length){i.typeProtos=[];for(var h=0;h<t.typeProtos.length;++h)i.typeProtos[h]=c.onnx.TypeProto.toObject(t.typeProtos[h],u)}if(t.type!=null&&t.hasOwnProperty("type")&&(i.type=u.enums===String?c.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:c.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(i.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(i.sparseTensor=c.onnx.SparseTensorProto.toObject(t.sparseTensor,u)),t.sparseTensors&&t.sparseTensors.length){i.sparseTensors=[];for(var h=0;h<t.sparseTensors.length;++h)i.sparseTensors[h]=c.onnx.SparseTensorProto.toObject(t.sparseTensors[h],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},a.AttributeType=function(){var t={},u=Object.create(t);return u[t[0]="UNDEFINED"]=0,u[t[1]="FLOAT"]=1,u[t[2]="INT"]=2,u[t[3]="STRING"]=3,u[t[4]="TENSOR"]=4,u[t[5]="GRAPH"]=5,u[t[11]="SPARSE_TENSOR"]=11,u[t[13]="TYPE_PROTO"]=13,u[t[6]="FLOATS"]=6,u[t[7]="INTS"]=7,u[t[8]="STRINGS"]=8,u[t[9]="TENSORS"]=9,u[t[10]="GRAPHS"]=10,u[t[12]="SPARSE_TENSORS"]=12,u[t[14]="TYPE_PROTOS"]=14,u}(),a}(),n.ValueInfoProto=function(){function a(t){if(t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.name="",a.prototype.type=null,a.prototype.docString="",a.create=function(t){return new a(t)},a.encode=function(t,u){return u||(u=p.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&c.onnx.TypeProto.encode(t.type,u.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(26).string(t.docString),u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.ValueInfoProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.name=t.string();break}case 2:{d.type=c.onnx.TypeProto.decode(t,t.uint32());break}case 3:{d.docString=t.string();break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!l.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var u=c.onnx.TypeProto.verify(t.type);if(u)return"type."+u}return t.docString!=null&&t.hasOwnProperty("docString")&&!l.isString(t.docString)?"docString: string expected":null},a.fromObject=function(t){if(t instanceof c.onnx.ValueInfoProto)return t;var u=new c.onnx.ValueInfoProto;if(t.name!=null&&(u.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");u.type=c.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(u.docString=String(t.docString)),u},a.toObject=function(t,u){u||(u={});var i={};return u.defaults&&(i.name="",i.type=null,i.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(i.type=c.onnx.TypeProto.toObject(t.type,u)),t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},a}(),n.NodeProto=function(){function a(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.input=l.emptyArray,a.prototype.output=l.emptyArray,a.prototype.name="",a.prototype.opType="",a.prototype.domain="",a.prototype.attribute=l.emptyArray,a.prototype.docString="",a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)u.uint32(10).string(t.input[i]);if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)u.uint32(18).string(t.output[i]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&u.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(var i=0;i<t.attribute.length;++i)c.onnx.AttributeProto.encode(t.attribute[i],u.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&u.uint32(58).string(t.domain),u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.NodeProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.input&&d.input.length||(d.input=[]),d.input.push(t.string());break}case 2:{d.output&&d.output.length||(d.output=[]),d.output.push(t.string());break}case 3:{d.name=t.string();break}case 4:{d.opType=t.string();break}case 7:{d.domain=t.string();break}case 5:{d.attribute&&d.attribute.length||(d.attribute=[]),d.attribute.push(c.onnx.AttributeProto.decode(t,t.uint32()));break}case 6:{d.docString=t.string();break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var u=0;u<t.input.length;++u)if(!l.isString(t.input[u]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var u=0;u<t.output.length;++u)if(!l.isString(t.output[u]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!l.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!l.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!l.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var u=0;u<t.attribute.length;++u){var i=c.onnx.AttributeProto.verify(t.attribute[u]);if(i)return"attribute."+i}}return t.docString!=null&&t.hasOwnProperty("docString")&&!l.isString(t.docString)?"docString: string expected":null},a.fromObject=function(t){if(t instanceof c.onnx.NodeProto)return t;var u=new c.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");u.input=[];for(var i=0;i<t.input.length;++i)u.input[i]=String(t.input[i])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");u.output=[];for(var i=0;i<t.output.length;++i)u.output[i]=String(t.output[i])}if(t.name!=null&&(u.name=String(t.name)),t.opType!=null&&(u.opType=String(t.opType)),t.domain!=null&&(u.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");u.attribute=[];for(var i=0;i<t.attribute.length;++i){if(typeof t.attribute[i]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");u.attribute[i]=c.onnx.AttributeProto.fromObject(t.attribute[i])}}return t.docString!=null&&(u.docString=String(t.docString)),u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.input=[],i.output=[],i.attribute=[]),u.defaults&&(i.name="",i.opType="",i.docString="",i.domain=""),t.input&&t.input.length){i.input=[];for(var d=0;d<t.input.length;++d)i.input[d]=t.input[d]}if(t.output&&t.output.length){i.output=[];for(var d=0;d<t.output.length;++d)i.output[d]=t.output[d]}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(i.opType=t.opType),t.attribute&&t.attribute.length){i.attribute=[];for(var d=0;d<t.attribute.length;++d)i.attribute[d]=c.onnx.AttributeProto.toObject(t.attribute[d],u)}return t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},a}(),n.TrainingInfoProto=function(){function a(t){if(this.initializationBinding=[],this.updateBinding=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.initialization=null,a.prototype.algorithm=null,a.prototype.initializationBinding=l.emptyArray,a.prototype.updateBinding=l.emptyArray,a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&c.onnx.GraphProto.encode(t.initialization,u.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&c.onnx.GraphProto.encode(t.algorithm,u.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var i=0;i<t.initializationBinding.length;++i)c.onnx.StringStringEntryProto.encode(t.initializationBinding[i],u.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(var i=0;i<t.updateBinding.length;++i)c.onnx.StringStringEntryProto.encode(t.updateBinding[i],u.uint32(34).fork()).ldelim();return u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.TrainingInfoProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.initialization=c.onnx.GraphProto.decode(t,t.uint32());break}case 2:{d.algorithm=c.onnx.GraphProto.decode(t,t.uint32());break}case 3:{d.initializationBinding&&d.initializationBinding.length||(d.initializationBinding=[]),d.initializationBinding.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 4:{d.updateBinding&&d.updateBinding.length||(d.updateBinding=[]),d.updateBinding.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")){var u=c.onnx.GraphProto.verify(t.initialization);if(u)return"initialization."+u}if(t.algorithm!=null&&t.hasOwnProperty("algorithm")){var u=c.onnx.GraphProto.verify(t.algorithm);if(u)return"algorithm."+u}if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var i=0;i<t.initializationBinding.length;++i){var u=c.onnx.StringStringEntryProto.verify(t.initializationBinding[i]);if(u)return"initializationBinding."+u}}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(var i=0;i<t.updateBinding.length;++i){var u=c.onnx.StringStringEntryProto.verify(t.updateBinding[i]);if(u)return"updateBinding."+u}}return null},a.fromObject=function(t){if(t instanceof c.onnx.TrainingInfoProto)return t;var u=new c.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");u.initialization=c.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");u.algorithm=c.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");u.initializationBinding=[];for(var i=0;i<t.initializationBinding.length;++i){if(typeof t.initializationBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");u.initializationBinding[i]=c.onnx.StringStringEntryProto.fromObject(t.initializationBinding[i])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");u.updateBinding=[];for(var i=0;i<t.updateBinding.length;++i){if(typeof t.updateBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");u.updateBinding[i]=c.onnx.StringStringEntryProto.fromObject(t.updateBinding[i])}}return u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.initializationBinding=[],i.updateBinding=[]),u.defaults&&(i.initialization=null,i.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(i.initialization=c.onnx.GraphProto.toObject(t.initialization,u)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(i.algorithm=c.onnx.GraphProto.toObject(t.algorithm,u)),t.initializationBinding&&t.initializationBinding.length){i.initializationBinding=[];for(var d=0;d<t.initializationBinding.length;++d)i.initializationBinding[d]=c.onnx.StringStringEntryProto.toObject(t.initializationBinding[d],u)}if(t.updateBinding&&t.updateBinding.length){i.updateBinding=[];for(var d=0;d<t.updateBinding.length;++d)i.updateBinding[d]=c.onnx.StringStringEntryProto.toObject(t.updateBinding[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},a}(),n.ModelProto=function(){function a(t){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.irVersion=l.Long?l.Long.fromBits(0,0,!1):0,a.prototype.opsetImport=l.emptyArray,a.prototype.producerName="",a.prototype.producerVersion="",a.prototype.domain="",a.prototype.modelVersion=l.Long?l.Long.fromBits(0,0,!1):0,a.prototype.docString="",a.prototype.graph=null,a.prototype.metadataProps=l.emptyArray,a.prototype.trainingInfo=l.emptyArray,a.prototype.functions=l.emptyArray,a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&u.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&u.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&u.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&u.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&u.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&c.onnx.GraphProto.encode(t.graph,u.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var i=0;i<t.opsetImport.length;++i)c.onnx.OperatorSetIdProto.encode(t.opsetImport[i],u.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(var i=0;i<t.metadataProps.length;++i)c.onnx.StringStringEntryProto.encode(t.metadataProps[i],u.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(var i=0;i<t.trainingInfo.length;++i)c.onnx.TrainingInfoProto.encode(t.trainingInfo[i],u.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(var i=0;i<t.functions.length;++i)c.onnx.FunctionProto.encode(t.functions[i],u.uint32(202).fork()).ldelim();return u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.ModelProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.irVersion=t.int64();break}case 8:{d.opsetImport&&d.opsetImport.length||(d.opsetImport=[]),d.opsetImport.push(c.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 2:{d.producerName=t.string();break}case 3:{d.producerVersion=t.string();break}case 4:{d.domain=t.string();break}case 5:{d.modelVersion=t.int64();break}case 6:{d.docString=t.string();break}case 7:{d.graph=c.onnx.GraphProto.decode(t,t.uint32());break}case 14:{d.metadataProps&&d.metadataProps.length||(d.metadataProps=[]),d.metadataProps.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 20:{d.trainingInfo&&d.trainingInfo.length||(d.trainingInfo=[]),d.trainingInfo.push(c.onnx.TrainingInfoProto.decode(t,t.uint32()));break}case 25:{d.functions&&d.functions.length||(d.functions=[]),d.functions.push(c.onnx.FunctionProto.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!l.isInteger(t.irVersion)&&!(t.irVersion&&l.isInteger(t.irVersion.low)&&l.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var u=0;u<t.opsetImport.length;++u){var i=c.onnx.OperatorSetIdProto.verify(t.opsetImport[u]);if(i)return"opsetImport."+i}}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!l.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!l.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!l.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!l.isInteger(t.modelVersion)&&!(t.modelVersion&&l.isInteger(t.modelVersion.low)&&l.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!l.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")){var i=c.onnx.GraphProto.verify(t.graph);if(i)return"graph."+i}if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(var u=0;u<t.metadataProps.length;++u){var i=c.onnx.StringStringEntryProto.verify(t.metadataProps[u]);if(i)return"metadataProps."+i}}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(var u=0;u<t.trainingInfo.length;++u){var i=c.onnx.TrainingInfoProto.verify(t.trainingInfo[u]);if(i)return"trainingInfo."+i}}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(var u=0;u<t.functions.length;++u){var i=c.onnx.FunctionProto.verify(t.functions[u]);if(i)return"functions."+i}}return null},a.fromObject=function(t){if(t instanceof c.onnx.ModelProto)return t;var u=new c.onnx.ModelProto;if(t.irVersion!=null&&(l.Long?(u.irVersion=l.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?u.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?u.irVersion=t.irVersion:typeof t.irVersion=="object"&&(u.irVersion=new l.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");u.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i){if(typeof t.opsetImport[i]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");u.opsetImport[i]=c.onnx.OperatorSetIdProto.fromObject(t.opsetImport[i])}}if(t.producerName!=null&&(u.producerName=String(t.producerName)),t.producerVersion!=null&&(u.producerVersion=String(t.producerVersion)),t.domain!=null&&(u.domain=String(t.domain)),t.modelVersion!=null&&(l.Long?(u.modelVersion=l.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?u.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?u.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(u.modelVersion=new l.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(u.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");u.graph=c.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");u.metadataProps=[];for(var i=0;i<t.metadataProps.length;++i){if(typeof t.metadataProps[i]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");u.metadataProps[i]=c.onnx.StringStringEntryProto.fromObject(t.metadataProps[i])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");u.trainingInfo=[];for(var i=0;i<t.trainingInfo.length;++i){if(typeof t.trainingInfo[i]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");u.trainingInfo[i]=c.onnx.TrainingInfoProto.fromObject(t.trainingInfo[i])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");u.functions=[];for(var i=0;i<t.functions.length;++i){if(typeof t.functions[i]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");u.functions[i]=c.onnx.FunctionProto.fromObject(t.functions[i])}}return u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.opsetImport=[],i.metadataProps=[],i.trainingInfo=[],i.functions=[]),u.defaults){if(l.Long){var d=new l.Long(0,0,!1);i.irVersion=u.longs===String?d.toString():u.longs===Number?d.toNumber():d}else i.irVersion=u.longs===String?"0":0;if(i.producerName="",i.producerVersion="",i.domain="",l.Long){var d=new l.Long(0,0,!1);i.modelVersion=u.longs===String?d.toString():u.longs===Number?d.toNumber():d}else i.modelVersion=u.longs===String?"0":0;i.docString="",i.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?i.irVersion=u.longs===String?String(t.irVersion):t.irVersion:i.irVersion=u.longs===String?l.Long.prototype.toString.call(t.irVersion):u.longs===Number?new l.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(i.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(i.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?i.modelVersion=u.longs===String?String(t.modelVersion):t.modelVersion:i.modelVersion=u.longs===String?l.Long.prototype.toString.call(t.modelVersion):u.longs===Number?new l.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(i.graph=c.onnx.GraphProto.toObject(t.graph,u)),t.opsetImport&&t.opsetImport.length){i.opsetImport=[];for(var h=0;h<t.opsetImport.length;++h)i.opsetImport[h]=c.onnx.OperatorSetIdProto.toObject(t.opsetImport[h],u)}if(t.metadataProps&&t.metadataProps.length){i.metadataProps=[];for(var h=0;h<t.metadataProps.length;++h)i.metadataProps[h]=c.onnx.StringStringEntryProto.toObject(t.metadataProps[h],u)}if(t.trainingInfo&&t.trainingInfo.length){i.trainingInfo=[];for(var h=0;h<t.trainingInfo.length;++h)i.trainingInfo[h]=c.onnx.TrainingInfoProto.toObject(t.trainingInfo[h],u)}if(t.functions&&t.functions.length){i.functions=[];for(var h=0;h<t.functions.length;++h)i.functions[h]=c.onnx.FunctionProto.toObject(t.functions[h],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},a}(),n.StringStringEntryProto=function(){function a(t){if(t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.key="",a.prototype.value="",a.create=function(t){return new a(t)},a.encode=function(t,u){return u||(u=p.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&u.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&u.uint32(18).string(t.value),u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.StringStringEntryProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.key=t.string();break}case 2:{d.value=t.string();break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!l.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!l.isString(t.value)?"value: string expected":null},a.fromObject=function(t){if(t instanceof c.onnx.StringStringEntryProto)return t;var u=new c.onnx.StringStringEntryProto;return t.key!=null&&(u.key=String(t.key)),t.value!=null&&(u.value=String(t.value)),u},a.toObject=function(t,u){u||(u={});var i={};return u.defaults&&(i.key="",i.value=""),t.key!=null&&t.hasOwnProperty("key")&&(i.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(i.value=t.value),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},a}(),n.TensorAnnotation=function(){function a(t){if(this.quantParameterTensorNames=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.tensorName="",a.prototype.quantParameterTensorNames=l.emptyArray,a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&u.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var i=0;i<t.quantParameterTensorNames.length;++i)c.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[i],u.uint32(18).fork()).ldelim();return u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.TensorAnnotation;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.tensorName=t.string();break}case 2:{d.quantParameterTensorNames&&d.quantParameterTensorNames.length||(d.quantParameterTensorNames=[]),d.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!l.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var u=0;u<t.quantParameterTensorNames.length;++u){var i=c.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[u]);if(i)return"quantParameterTensorNames."+i}}return null},a.fromObject=function(t){if(t instanceof c.onnx.TensorAnnotation)return t;var u=new c.onnx.TensorAnnotation;if(t.tensorName!=null&&(u.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");u.quantParameterTensorNames=[];for(var i=0;i<t.quantParameterTensorNames.length;++i){if(typeof t.quantParameterTensorNames[i]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");u.quantParameterTensorNames[i]=c.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[i])}}return u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.quantParameterTensorNames=[]),u.defaults&&(i.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(i.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){i.quantParameterTensorNames=[];for(var d=0;d<t.quantParameterTensorNames.length;++d)i.quantParameterTensorNames[d]=c.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},a}(),n.GraphProto=function(){function a(t){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.node=l.emptyArray,a.prototype.name="",a.prototype.initializer=l.emptyArray,a.prototype.sparseInitializer=l.emptyArray,a.prototype.docString="",a.prototype.input=l.emptyArray,a.prototype.output=l.emptyArray,a.prototype.valueInfo=l.emptyArray,a.prototype.quantizationAnnotation=l.emptyArray,a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.node!=null&&t.node.length)for(var i=0;i<t.node.length;++i)c.onnx.NodeProto.encode(t.node[i],u.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(var i=0;i<t.initializer.length;++i)c.onnx.TensorProto.encode(t.initializer[i],u.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)c.onnx.ValueInfoProto.encode(t.input[i],u.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)c.onnx.ValueInfoProto.encode(t.output[i],u.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(var i=0;i<t.valueInfo.length;++i)c.onnx.ValueInfoProto.encode(t.valueInfo[i],u.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(var i=0;i<t.quantizationAnnotation.length;++i)c.onnx.TensorAnnotation.encode(t.quantizationAnnotation[i],u.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(var i=0;i<t.sparseInitializer.length;++i)c.onnx.SparseTensorProto.encode(t.sparseInitializer[i],u.uint32(122).fork()).ldelim();return u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.GraphProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.node&&d.node.length||(d.node=[]),d.node.push(c.onnx.NodeProto.decode(t,t.uint32()));break}case 2:{d.name=t.string();break}case 5:{d.initializer&&d.initializer.length||(d.initializer=[]),d.initializer.push(c.onnx.TensorProto.decode(t,t.uint32()));break}case 15:{d.sparseInitializer&&d.sparseInitializer.length||(d.sparseInitializer=[]),d.sparseInitializer.push(c.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 10:{d.docString=t.string();break}case 11:{d.input&&d.input.length||(d.input=[]),d.input.push(c.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 12:{d.output&&d.output.length||(d.output=[]),d.output.push(c.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 13:{d.valueInfo&&d.valueInfo.length||(d.valueInfo=[]),d.valueInfo.push(c.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 14:{d.quantizationAnnotation&&d.quantizationAnnotation.length||(d.quantizationAnnotation=[]),d.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var u=0;u<t.node.length;++u){var i=c.onnx.NodeProto.verify(t.node[u]);if(i)return"node."+i}}if(t.name!=null&&t.hasOwnProperty("name")&&!l.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(var u=0;u<t.initializer.length;++u){var i=c.onnx.TensorProto.verify(t.initializer[u]);if(i)return"initializer."+i}}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(var u=0;u<t.sparseInitializer.length;++u){var i=c.onnx.SparseTensorProto.verify(t.sparseInitializer[u]);if(i)return"sparseInitializer."+i}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!l.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var u=0;u<t.input.length;++u){var i=c.onnx.ValueInfoProto.verify(t.input[u]);if(i)return"input."+i}}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var u=0;u<t.output.length;++u){var i=c.onnx.ValueInfoProto.verify(t.output[u]);if(i)return"output."+i}}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(var u=0;u<t.valueInfo.length;++u){var i=c.onnx.ValueInfoProto.verify(t.valueInfo[u]);if(i)return"valueInfo."+i}}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var u=0;u<t.quantizationAnnotation.length;++u){var i=c.onnx.TensorAnnotation.verify(t.quantizationAnnotation[u]);if(i)return"quantizationAnnotation."+i}}return null},a.fromObject=function(t){if(t instanceof c.onnx.GraphProto)return t;var u=new c.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");u.node=[];for(var i=0;i<t.node.length;++i){if(typeof t.node[i]!="object")throw TypeError(".onnx.GraphProto.node: object expected");u.node[i]=c.onnx.NodeProto.fromObject(t.node[i])}}if(t.name!=null&&(u.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");u.initializer=[];for(var i=0;i<t.initializer.length;++i){if(typeof t.initializer[i]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");u.initializer[i]=c.onnx.TensorProto.fromObject(t.initializer[i])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");u.sparseInitializer=[];for(var i=0;i<t.sparseInitializer.length;++i){if(typeof t.sparseInitializer[i]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");u.sparseInitializer[i]=c.onnx.SparseTensorProto.fromObject(t.sparseInitializer[i])}}if(t.docString!=null&&(u.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");u.input=[];for(var i=0;i<t.input.length;++i){if(typeof t.input[i]!="object")throw TypeError(".onnx.GraphProto.input: object expected");u.input[i]=c.onnx.ValueInfoProto.fromObject(t.input[i])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");u.output=[];for(var i=0;i<t.output.length;++i){if(typeof t.output[i]!="object")throw TypeError(".onnx.GraphProto.output: object expected");u.output[i]=c.onnx.ValueInfoProto.fromObject(t.output[i])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");u.valueInfo=[];for(var i=0;i<t.valueInfo.length;++i){if(typeof t.valueInfo[i]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");u.valueInfo[i]=c.onnx.ValueInfoProto.fromObject(t.valueInfo[i])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");u.quantizationAnnotation=[];for(var i=0;i<t.quantizationAnnotation.length;++i){if(typeof t.quantizationAnnotation[i]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");u.quantizationAnnotation[i]=c.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[i])}}return u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.node=[],i.initializer=[],i.input=[],i.output=[],i.valueInfo=[],i.quantizationAnnotation=[],i.sparseInitializer=[]),u.defaults&&(i.name="",i.docString=""),t.node&&t.node.length){i.node=[];for(var d=0;d<t.node.length;++d)i.node[d]=c.onnx.NodeProto.toObject(t.node[d],u)}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.initializer&&t.initializer.length){i.initializer=[];for(var d=0;d<t.initializer.length;++d)i.initializer[d]=c.onnx.TensorProto.toObject(t.initializer[d],u)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.input&&t.input.length){i.input=[];for(var d=0;d<t.input.length;++d)i.input[d]=c.onnx.ValueInfoProto.toObject(t.input[d],u)}if(t.output&&t.output.length){i.output=[];for(var d=0;d<t.output.length;++d)i.output[d]=c.onnx.ValueInfoProto.toObject(t.output[d],u)}if(t.valueInfo&&t.valueInfo.length){i.valueInfo=[];for(var d=0;d<t.valueInfo.length;++d)i.valueInfo[d]=c.onnx.ValueInfoProto.toObject(t.valueInfo[d],u)}if(t.quantizationAnnotation&&t.quantizationAnnotation.length){i.quantizationAnnotation=[];for(var d=0;d<t.quantizationAnnotation.length;++d)i.quantizationAnnotation[d]=c.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[d],u)}if(t.sparseInitializer&&t.sparseInitializer.length){i.sparseInitializer=[];for(var d=0;d<t.sparseInitializer.length;++d)i.sparseInitializer[d]=c.onnx.SparseTensorProto.toObject(t.sparseInitializer[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},a}(),n.TensorProto=function(){function a(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.dims=l.emptyArray,a.prototype.dataType=0,a.prototype.segment=null,a.prototype.floatData=l.emptyArray,a.prototype.int32Data=l.emptyArray,a.prototype.stringData=l.emptyArray,a.prototype.int64Data=l.emptyArray,a.prototype.name="",a.prototype.docString="",a.prototype.rawData=l.newBuffer([]),a.prototype.externalData=l.emptyArray,a.prototype.dataLocation=0,a.prototype.doubleData=l.emptyArray,a.prototype.uint64Data=l.emptyArray,a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.dims!=null&&t.dims.length){u.uint32(10).fork();for(var i=0;i<t.dims.length;++i)u.int64(t.dims[i]);u.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&u.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&c.onnx.TensorProto.Segment.encode(t.segment,u.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){u.uint32(34).fork();for(var i=0;i<t.floatData.length;++i)u.float(t.floatData[i]);u.ldelim()}if(t.int32Data!=null&&t.int32Data.length){u.uint32(42).fork();for(var i=0;i<t.int32Data.length;++i)u.int32(t.int32Data[i]);u.ldelim()}if(t.stringData!=null&&t.stringData.length)for(var i=0;i<t.stringData.length;++i)u.uint32(50).bytes(t.stringData[i]);if(t.int64Data!=null&&t.int64Data.length){u.uint32(58).fork();for(var i=0;i<t.int64Data.length;++i)u.int64(t.int64Data[i]);u.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&u.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){u.uint32(82).fork();for(var i=0;i<t.doubleData.length;++i)u.double(t.doubleData[i]);u.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){u.uint32(90).fork();for(var i=0;i<t.uint64Data.length;++i)u.uint64(t.uint64Data[i]);u.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(var i=0;i<t.externalData.length;++i)c.onnx.StringStringEntryProto.encode(t.externalData[i],u.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&u.uint32(112).int32(t.dataLocation),u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.TensorProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{if(d.dims&&d.dims.length||(d.dims=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.dims.push(t.int64());else d.dims.push(t.int64());break}case 2:{d.dataType=t.int32();break}case 3:{d.segment=c.onnx.TensorProto.Segment.decode(t,t.uint32());break}case 4:{if(d.floatData&&d.floatData.length||(d.floatData=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.floatData.push(t.float());else d.floatData.push(t.float());break}case 5:{if(d.int32Data&&d.int32Data.length||(d.int32Data=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.int32Data.push(t.int32());else d.int32Data.push(t.int32());break}case 6:{d.stringData&&d.stringData.length||(d.stringData=[]),d.stringData.push(t.bytes());break}case 7:{if(d.int64Data&&d.int64Data.length||(d.int64Data=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.int64Data.push(t.int64());else d.int64Data.push(t.int64());break}case 8:{d.name=t.string();break}case 12:{d.docString=t.string();break}case 9:{d.rawData=t.bytes();break}case 13:{d.externalData&&d.externalData.length||(d.externalData=[]),d.externalData.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 14:{d.dataLocation=t.int32();break}case 10:{if(d.doubleData&&d.doubleData.length||(d.doubleData=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.doubleData.push(t.double());else d.doubleData.push(t.double());break}case 11:{if(d.uint64Data&&d.uint64Data.length||(d.uint64Data=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.uint64Data.push(t.uint64());else d.uint64Data.push(t.uint64());break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var u=0;u<t.dims.length;++u)if(!l.isInteger(t.dims[u])&&!(t.dims[u]&&l.isInteger(t.dims[u].low)&&l.isInteger(t.dims[u].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!l.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")){var i=c.onnx.TensorProto.Segment.verify(t.segment);if(i)return"segment."+i}if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(var u=0;u<t.floatData.length;++u)if(typeof t.floatData[u]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(var u=0;u<t.int32Data.length;++u)if(!l.isInteger(t.int32Data[u]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(var u=0;u<t.stringData.length;++u)if(!(t.stringData[u]&&typeof t.stringData[u].length=="number"||l.isString(t.stringData[u])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(var u=0;u<t.int64Data.length;++u)if(!l.isInteger(t.int64Data[u])&&!(t.int64Data[u]&&l.isInteger(t.int64Data[u].low)&&l.isInteger(t.int64Data[u].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!l.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!l.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||l.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(var u=0;u<t.externalData.length;++u){var i=c.onnx.StringStringEntryProto.verify(t.externalData[u]);if(i)return"externalData."+i}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(var u=0;u<t.doubleData.length;++u)if(typeof t.doubleData[u]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(var u=0;u<t.uint64Data.length;++u)if(!l.isInteger(t.uint64Data[u])&&!(t.uint64Data[u]&&l.isInteger(t.uint64Data[u].low)&&l.isInteger(t.uint64Data[u].high)))return"uint64Data: integer|Long[] expected"}return null},a.fromObject=function(t){if(t instanceof c.onnx.TensorProto)return t;var u=new c.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");u.dims=[];for(var i=0;i<t.dims.length;++i)l.Long?(u.dims[i]=l.Long.fromValue(t.dims[i])).unsigned=!1:typeof t.dims[i]=="string"?u.dims[i]=parseInt(t.dims[i],10):typeof t.dims[i]=="number"?u.dims[i]=t.dims[i]:typeof t.dims[i]=="object"&&(u.dims[i]=new l.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber())}if(t.dataType!=null&&(u.dataType=t.dataType|0),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");u.segment=c.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");u.floatData=[];for(var i=0;i<t.floatData.length;++i)u.floatData[i]=Number(t.floatData[i])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");u.int32Data=[];for(var i=0;i<t.int32Data.length;++i)u.int32Data[i]=t.int32Data[i]|0}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");u.stringData=[];for(var i=0;i<t.stringData.length;++i)typeof t.stringData[i]=="string"?l.base64.decode(t.stringData[i],u.stringData[i]=l.newBuffer(l.base64.length(t.stringData[i])),0):t.stringData[i].length>=0&&(u.stringData[i]=t.stringData[i])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");u.int64Data=[];for(var i=0;i<t.int64Data.length;++i)l.Long?(u.int64Data[i]=l.Long.fromValue(t.int64Data[i])).unsigned=!1:typeof t.int64Data[i]=="string"?u.int64Data[i]=parseInt(t.int64Data[i],10):typeof t.int64Data[i]=="number"?u.int64Data[i]=t.int64Data[i]:typeof t.int64Data[i]=="object"&&(u.int64Data[i]=new l.LongBits(t.int64Data[i].low>>>0,t.int64Data[i].high>>>0).toNumber())}if(t.name!=null&&(u.name=String(t.name)),t.docString!=null&&(u.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?l.base64.decode(t.rawData,u.rawData=l.newBuffer(l.base64.length(t.rawData)),0):t.rawData.length>=0&&(u.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");u.externalData=[];for(var i=0;i<t.externalData.length;++i){if(typeof t.externalData[i]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");u.externalData[i]=c.onnx.StringStringEntryProto.fromObject(t.externalData[i])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){u.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:u.dataLocation=0;break;case"EXTERNAL":case 1:u.dataLocation=1;break}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");u.doubleData=[];for(var i=0;i<t.doubleData.length;++i)u.doubleData[i]=Number(t.doubleData[i])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");u.uint64Data=[];for(var i=0;i<t.uint64Data.length;++i)l.Long?(u.uint64Data[i]=l.Long.fromValue(t.uint64Data[i])).unsigned=!0:typeof t.uint64Data[i]=="string"?u.uint64Data[i]=parseInt(t.uint64Data[i],10):typeof t.uint64Data[i]=="number"?u.uint64Data[i]=t.uint64Data[i]:typeof t.uint64Data[i]=="object"&&(u.uint64Data[i]=new l.LongBits(t.uint64Data[i].low>>>0,t.uint64Data[i].high>>>0).toNumber(!0))}return u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.dims=[],i.floatData=[],i.int32Data=[],i.stringData=[],i.int64Data=[],i.doubleData=[],i.uint64Data=[],i.externalData=[]),u.defaults&&(i.dataType=0,i.segment=null,i.name="",u.bytes===String?i.rawData="":(i.rawData=[],u.bytes!==Array&&(i.rawData=l.newBuffer(i.rawData))),i.docString="",i.dataLocation=u.enums===String?"DEFAULT":0),t.dims&&t.dims.length){i.dims=[];for(var d=0;d<t.dims.length;++d)typeof t.dims[d]=="number"?i.dims[d]=u.longs===String?String(t.dims[d]):t.dims[d]:i.dims[d]=u.longs===String?l.Long.prototype.toString.call(t.dims[d]):u.longs===Number?new l.LongBits(t.dims[d].low>>>0,t.dims[d].high>>>0).toNumber():t.dims[d]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(i.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(i.segment=c.onnx.TensorProto.Segment.toObject(t.segment,u)),t.floatData&&t.floatData.length){i.floatData=[];for(var d=0;d<t.floatData.length;++d)i.floatData[d]=u.json&&!isFinite(t.floatData[d])?String(t.floatData[d]):t.floatData[d]}if(t.int32Data&&t.int32Data.length){i.int32Data=[];for(var d=0;d<t.int32Data.length;++d)i.int32Data[d]=t.int32Data[d]}if(t.stringData&&t.stringData.length){i.stringData=[];for(var d=0;d<t.stringData.length;++d)i.stringData[d]=u.bytes===String?l.base64.encode(t.stringData[d],0,t.stringData[d].length):u.bytes===Array?Array.prototype.slice.call(t.stringData[d]):t.stringData[d]}if(t.int64Data&&t.int64Data.length){i.int64Data=[];for(var d=0;d<t.int64Data.length;++d)typeof t.int64Data[d]=="number"?i.int64Data[d]=u.longs===String?String(t.int64Data[d]):t.int64Data[d]:i.int64Data[d]=u.longs===String?l.Long.prototype.toString.call(t.int64Data[d]):u.longs===Number?new l.LongBits(t.int64Data[d].low>>>0,t.int64Data[d].high>>>0).toNumber():t.int64Data[d]}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(i.rawData=u.bytes===String?l.base64.encode(t.rawData,0,t.rawData.length):u.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length){i.doubleData=[];for(var d=0;d<t.doubleData.length;++d)i.doubleData[d]=u.json&&!isFinite(t.doubleData[d])?String(t.doubleData[d]):t.doubleData[d]}if(t.uint64Data&&t.uint64Data.length){i.uint64Data=[];for(var d=0;d<t.uint64Data.length;++d)typeof t.uint64Data[d]=="number"?i.uint64Data[d]=u.longs===String?String(t.uint64Data[d]):t.uint64Data[d]:i.uint64Data[d]=u.longs===String?l.Long.prototype.toString.call(t.uint64Data[d]):u.longs===Number?new l.LongBits(t.uint64Data[d].low>>>0,t.uint64Data[d].high>>>0).toNumber(!0):t.uint64Data[d]}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.externalData&&t.externalData.length){i.externalData=[];for(var d=0;d<t.externalData.length;++d)i.externalData[d]=c.onnx.StringStringEntryProto.toObject(t.externalData[d],u)}return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(i.dataLocation=u.enums===String?c.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:c.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},a.DataType=function(){var t={},u=Object.create(t);return u[t[0]="UNDEFINED"]=0,u[t[1]="FLOAT"]=1,u[t[2]="UINT8"]=2,u[t[3]="INT8"]=3,u[t[4]="UINT16"]=4,u[t[5]="INT16"]=5,u[t[6]="INT32"]=6,u[t[7]="INT64"]=7,u[t[8]="STRING"]=8,u[t[9]="BOOL"]=9,u[t[10]="FLOAT16"]=10,u[t[11]="DOUBLE"]=11,u[t[12]="UINT32"]=12,u[t[13]="UINT64"]=13,u[t[14]="COMPLEX64"]=14,u[t[15]="COMPLEX128"]=15,u[t[16]="BFLOAT16"]=16,u[t[17]="FLOAT8E4M3FN"]=17,u[t[18]="FLOAT8E4M3FNUZ"]=18,u[t[19]="FLOAT8E5M2"]=19,u[t[20]="FLOAT8E5M2FNUZ"]=20,u}(),a.Segment=function(){function t(u){if(u)for(var i=Object.keys(u),d=0;d<i.length;++d)u[i[d]]!=null&&(this[i[d]]=u[i[d]])}return t.prototype.begin=l.Long?l.Long.fromBits(0,0,!1):0,t.prototype.end=l.Long?l.Long.fromBits(0,0,!1):0,t.create=function(u){return new t(u)},t.encode=function(u,i){return i||(i=p.create()),u.begin!=null&&Object.hasOwnProperty.call(u,"begin")&&i.uint32(8).int64(u.begin),u.end!=null&&Object.hasOwnProperty.call(u,"end")&&i.uint32(16).int64(u.end),i},t.encodeDelimited=function(u,i){return this.encode(u,i).ldelim()},t.decode=function(u,i){u instanceof s||(u=s.create(u));for(var d=i===void 0?u.len:u.pos+i,h=new c.onnx.TensorProto.Segment;u.pos<d;){var m=u.uint32();switch(m>>>3){case 1:{h.begin=u.int64();break}case 2:{h.end=u.int64();break}default:u.skipType(m&7);break}}return h},t.decodeDelimited=function(u){return u instanceof s||(u=new s(u)),this.decode(u,u.uint32())},t.verify=function(u){return typeof u!="object"||u===null?"object expected":u.begin!=null&&u.hasOwnProperty("begin")&&!l.isInteger(u.begin)&&!(u.begin&&l.isInteger(u.begin.low)&&l.isInteger(u.begin.high))?"begin: integer|Long expected":u.end!=null&&u.hasOwnProperty("end")&&!l.isInteger(u.end)&&!(u.end&&l.isInteger(u.end.low)&&l.isInteger(u.end.high))?"end: integer|Long expected":null},t.fromObject=function(u){if(u instanceof c.onnx.TensorProto.Segment)return u;var i=new c.onnx.TensorProto.Segment;return u.begin!=null&&(l.Long?(i.begin=l.Long.fromValue(u.begin)).unsigned=!1:typeof u.begin=="string"?i.begin=parseInt(u.begin,10):typeof u.begin=="number"?i.begin=u.begin:typeof u.begin=="object"&&(i.begin=new l.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber())),u.end!=null&&(l.Long?(i.end=l.Long.fromValue(u.end)).unsigned=!1:typeof u.end=="string"?i.end=parseInt(u.end,10):typeof u.end=="number"?i.end=u.end:typeof u.end=="object"&&(i.end=new l.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber())),i},t.toObject=function(u,i){i||(i={});var d={};if(i.defaults){if(l.Long){var h=new l.Long(0,0,!1);d.begin=i.longs===String?h.toString():i.longs===Number?h.toNumber():h}else d.begin=i.longs===String?"0":0;if(l.Long){var h=new l.Long(0,0,!1);d.end=i.longs===String?h.toString():i.longs===Number?h.toNumber():h}else d.end=i.longs===String?"0":0}return u.begin!=null&&u.hasOwnProperty("begin")&&(typeof u.begin=="number"?d.begin=i.longs===String?String(u.begin):u.begin:d.begin=i.longs===String?l.Long.prototype.toString.call(u.begin):i.longs===Number?new l.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber():u.begin),u.end!=null&&u.hasOwnProperty("end")&&(typeof u.end=="number"?d.end=i.longs===String?String(u.end):u.end:d.end=i.longs===String?l.Long.prototype.toString.call(u.end):i.longs===Number?new l.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber():u.end),d},t.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},t.getTypeUrl=function(u){return u===void 0&&(u="type.googleapis.com"),u+"/onnx.TensorProto.Segment"},t}(),a.DataLocation=function(){var t={},u=Object.create(t);return u[t[0]="DEFAULT"]=0,u[t[1]="EXTERNAL"]=1,u}(),a}(),n.SparseTensorProto=function(){function a(t){if(this.dims=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.values=null,a.prototype.indices=null,a.prototype.dims=l.emptyArray,a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&c.onnx.TensorProto.encode(t.values,u.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&c.onnx.TensorProto.encode(t.indices,u.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){u.uint32(26).fork();for(var i=0;i<t.dims.length;++i)u.int64(t.dims[i]);u.ldelim()}return u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.SparseTensorProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.values=c.onnx.TensorProto.decode(t,t.uint32());break}case 2:{d.indices=c.onnx.TensorProto.decode(t,t.uint32());break}case 3:{if(d.dims&&d.dims.length||(d.dims=[]),(h&7)===2)for(var m=t.uint32()+t.pos;t.pos<m;)d.dims.push(t.int64());else d.dims.push(t.int64());break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.values!=null&&t.hasOwnProperty("values")){var u=c.onnx.TensorProto.verify(t.values);if(u)return"values."+u}if(t.indices!=null&&t.hasOwnProperty("indices")){var u=c.onnx.TensorProto.verify(t.indices);if(u)return"indices."+u}if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var i=0;i<t.dims.length;++i)if(!l.isInteger(t.dims[i])&&!(t.dims[i]&&l.isInteger(t.dims[i].low)&&l.isInteger(t.dims[i].high)))return"dims: integer|Long[] expected"}return null},a.fromObject=function(t){if(t instanceof c.onnx.SparseTensorProto)return t;var u=new c.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");u.values=c.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");u.indices=c.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");u.dims=[];for(var i=0;i<t.dims.length;++i)l.Long?(u.dims[i]=l.Long.fromValue(t.dims[i])).unsigned=!1:typeof t.dims[i]=="string"?u.dims[i]=parseInt(t.dims[i],10):typeof t.dims[i]=="number"?u.dims[i]=t.dims[i]:typeof t.dims[i]=="object"&&(u.dims[i]=new l.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber())}return u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.dims=[]),u.defaults&&(i.values=null,i.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(i.values=c.onnx.TensorProto.toObject(t.values,u)),t.indices!=null&&t.hasOwnProperty("indices")&&(i.indices=c.onnx.TensorProto.toObject(t.indices,u)),t.dims&&t.dims.length){i.dims=[];for(var d=0;d<t.dims.length;++d)typeof t.dims[d]=="number"?i.dims[d]=u.longs===String?String(t.dims[d]):t.dims[d]:i.dims[d]=u.longs===String?l.Long.prototype.toString.call(t.dims[d]):u.longs===Number?new l.LongBits(t.dims[d].low>>>0,t.dims[d].high>>>0).toNumber():t.dims[d]}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},a}(),n.TensorShapeProto=function(){function a(t){if(this.dim=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.dim=l.emptyArray,a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.dim!=null&&t.dim.length)for(var i=0;i<t.dim.length;++i)c.onnx.TensorShapeProto.Dimension.encode(t.dim[i],u.uint32(10).fork()).ldelim();return u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.TensorShapeProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.dim&&d.dim.length||(d.dim=[]),d.dim.push(c.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var u=0;u<t.dim.length;++u){var i=c.onnx.TensorShapeProto.Dimension.verify(t.dim[u]);if(i)return"dim."+i}}return null},a.fromObject=function(t){if(t instanceof c.onnx.TensorShapeProto)return t;var u=new c.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");u.dim=[];for(var i=0;i<t.dim.length;++i){if(typeof t.dim[i]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");u.dim[i]=c.onnx.TensorShapeProto.Dimension.fromObject(t.dim[i])}}return u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.dim=[]),t.dim&&t.dim.length){i.dim=[];for(var d=0;d<t.dim.length;++d)i.dim[d]=c.onnx.TensorShapeProto.Dimension.toObject(t.dim[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},a.Dimension=function(){function t(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}t.prototype.dimValue=null,t.prototype.dimParam=null,t.prototype.denotation="";var u;return Object.defineProperty(t.prototype,"value",{get:l.oneOfGetter(u=["dimValue","dimParam"]),set:l.oneOfSetter(u)}),t.create=function(i){return new t(i)},t.encode=function(i,d){return d||(d=p.create()),i.dimValue!=null&&Object.hasOwnProperty.call(i,"dimValue")&&d.uint32(8).int64(i.dimValue),i.dimParam!=null&&Object.hasOwnProperty.call(i,"dimParam")&&d.uint32(18).string(i.dimParam),i.denotation!=null&&Object.hasOwnProperty.call(i,"denotation")&&d.uint32(26).string(i.denotation),d},t.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},t.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TensorShapeProto.Dimension;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.dimValue=i.int64();break}case 2:{m.dimParam=i.string();break}case 3:{m.denotation=i.string();break}default:i.skipType(b&7);break}}return m},t.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";var d={};if(i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(d.value=1,!l.isInteger(i.dimValue)&&!(i.dimValue&&l.isInteger(i.dimValue.low)&&l.isInteger(i.dimValue.high))))return"dimValue: integer|Long expected";if(i.dimParam!=null&&i.hasOwnProperty("dimParam")){if(d.value===1)return"value: multiple values";if(d.value=1,!l.isString(i.dimParam))return"dimParam: string expected"}return i.denotation!=null&&i.hasOwnProperty("denotation")&&!l.isString(i.denotation)?"denotation: string expected":null},t.fromObject=function(i){if(i instanceof c.onnx.TensorShapeProto.Dimension)return i;var d=new c.onnx.TensorShapeProto.Dimension;return i.dimValue!=null&&(l.Long?(d.dimValue=l.Long.fromValue(i.dimValue)).unsigned=!1:typeof i.dimValue=="string"?d.dimValue=parseInt(i.dimValue,10):typeof i.dimValue=="number"?d.dimValue=i.dimValue:typeof i.dimValue=="object"&&(d.dimValue=new l.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber())),i.dimParam!=null&&(d.dimParam=String(i.dimParam)),i.denotation!=null&&(d.denotation=String(i.denotation)),d},t.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.denotation=""),i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(typeof i.dimValue=="number"?h.dimValue=d.longs===String?String(i.dimValue):i.dimValue:h.dimValue=d.longs===String?l.Long.prototype.toString.call(i.dimValue):d.longs===Number?new l.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber():i.dimValue,d.oneofs&&(h.value="dimValue")),i.dimParam!=null&&i.hasOwnProperty("dimParam")&&(h.dimParam=i.dimParam,d.oneofs&&(h.value="dimParam")),i.denotation!=null&&i.hasOwnProperty("denotation")&&(h.denotation=i.denotation),h},t.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TensorShapeProto.Dimension"},t}(),a}(),n.TypeProto=function(){function a(u){if(u)for(var i=Object.keys(u),d=0;d<i.length;++d)u[i[d]]!=null&&(this[i[d]]=u[i[d]])}a.prototype.tensorType=null,a.prototype.sequenceType=null,a.prototype.mapType=null,a.prototype.optionalType=null,a.prototype.sparseTensorType=null,a.prototype.denotation="";var t;return Object.defineProperty(a.prototype,"value",{get:l.oneOfGetter(t=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:l.oneOfSetter(t)}),a.create=function(u){return new a(u)},a.encode=function(u,i){return i||(i=p.create()),u.tensorType!=null&&Object.hasOwnProperty.call(u,"tensorType")&&c.onnx.TypeProto.Tensor.encode(u.tensorType,i.uint32(10).fork()).ldelim(),u.sequenceType!=null&&Object.hasOwnProperty.call(u,"sequenceType")&&c.onnx.TypeProto.Sequence.encode(u.sequenceType,i.uint32(34).fork()).ldelim(),u.mapType!=null&&Object.hasOwnProperty.call(u,"mapType")&&c.onnx.TypeProto.Map.encode(u.mapType,i.uint32(42).fork()).ldelim(),u.denotation!=null&&Object.hasOwnProperty.call(u,"denotation")&&i.uint32(50).string(u.denotation),u.sparseTensorType!=null&&Object.hasOwnProperty.call(u,"sparseTensorType")&&c.onnx.TypeProto.SparseTensor.encode(u.sparseTensorType,i.uint32(66).fork()).ldelim(),u.optionalType!=null&&Object.hasOwnProperty.call(u,"optionalType")&&c.onnx.TypeProto.Optional.encode(u.optionalType,i.uint32(74).fork()).ldelim(),i},a.encodeDelimited=function(u,i){return this.encode(u,i).ldelim()},a.decode=function(u,i){u instanceof s||(u=s.create(u));for(var d=i===void 0?u.len:u.pos+i,h=new c.onnx.TypeProto;u.pos<d;){var m=u.uint32();switch(m>>>3){case 1:{h.tensorType=c.onnx.TypeProto.Tensor.decode(u,u.uint32());break}case 4:{h.sequenceType=c.onnx.TypeProto.Sequence.decode(u,u.uint32());break}case 5:{h.mapType=c.onnx.TypeProto.Map.decode(u,u.uint32());break}case 9:{h.optionalType=c.onnx.TypeProto.Optional.decode(u,u.uint32());break}case 8:{h.sparseTensorType=c.onnx.TypeProto.SparseTensor.decode(u,u.uint32());break}case 6:{h.denotation=u.string();break}default:u.skipType(m&7);break}}return h},a.decodeDelimited=function(u){return u instanceof s||(u=new s(u)),this.decode(u,u.uint32())},a.verify=function(u){if(typeof u!="object"||u===null)return"object expected";var i={};if(u.tensorType!=null&&u.hasOwnProperty("tensorType")){i.value=1;{var d=c.onnx.TypeProto.Tensor.verify(u.tensorType);if(d)return"tensorType."+d}}if(u.sequenceType!=null&&u.hasOwnProperty("sequenceType")){if(i.value===1)return"value: multiple values";i.value=1;{var d=c.onnx.TypeProto.Sequence.verify(u.sequenceType);if(d)return"sequenceType."+d}}if(u.mapType!=null&&u.hasOwnProperty("mapType")){if(i.value===1)return"value: multiple values";i.value=1;{var d=c.onnx.TypeProto.Map.verify(u.mapType);if(d)return"mapType."+d}}if(u.optionalType!=null&&u.hasOwnProperty("optionalType")){if(i.value===1)return"value: multiple values";i.value=1;{var d=c.onnx.TypeProto.Optional.verify(u.optionalType);if(d)return"optionalType."+d}}if(u.sparseTensorType!=null&&u.hasOwnProperty("sparseTensorType")){if(i.value===1)return"value: multiple values";i.value=1;{var d=c.onnx.TypeProto.SparseTensor.verify(u.sparseTensorType);if(d)return"sparseTensorType."+d}}return u.denotation!=null&&u.hasOwnProperty("denotation")&&!l.isString(u.denotation)?"denotation: string expected":null},a.fromObject=function(u){if(u instanceof c.onnx.TypeProto)return u;var i=new c.onnx.TypeProto;if(u.tensorType!=null){if(typeof u.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");i.tensorType=c.onnx.TypeProto.Tensor.fromObject(u.tensorType)}if(u.sequenceType!=null){if(typeof u.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");i.sequenceType=c.onnx.TypeProto.Sequence.fromObject(u.sequenceType)}if(u.mapType!=null){if(typeof u.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");i.mapType=c.onnx.TypeProto.Map.fromObject(u.mapType)}if(u.optionalType!=null){if(typeof u.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");i.optionalType=c.onnx.TypeProto.Optional.fromObject(u.optionalType)}if(u.sparseTensorType!=null){if(typeof u.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");i.sparseTensorType=c.onnx.TypeProto.SparseTensor.fromObject(u.sparseTensorType)}return u.denotation!=null&&(i.denotation=String(u.denotation)),i},a.toObject=function(u,i){i||(i={});var d={};return i.defaults&&(d.denotation=""),u.tensorType!=null&&u.hasOwnProperty("tensorType")&&(d.tensorType=c.onnx.TypeProto.Tensor.toObject(u.tensorType,i),i.oneofs&&(d.value="tensorType")),u.sequenceType!=null&&u.hasOwnProperty("sequenceType")&&(d.sequenceType=c.onnx.TypeProto.Sequence.toObject(u.sequenceType,i),i.oneofs&&(d.value="sequenceType")),u.mapType!=null&&u.hasOwnProperty("mapType")&&(d.mapType=c.onnx.TypeProto.Map.toObject(u.mapType,i),i.oneofs&&(d.value="mapType")),u.denotation!=null&&u.hasOwnProperty("denotation")&&(d.denotation=u.denotation),u.sparseTensorType!=null&&u.hasOwnProperty("sparseTensorType")&&(d.sparseTensorType=c.onnx.TypeProto.SparseTensor.toObject(u.sparseTensorType,i),i.oneofs&&(d.value="sparseTensorType")),u.optionalType!=null&&u.hasOwnProperty("optionalType")&&(d.optionalType=c.onnx.TypeProto.Optional.toObject(u.optionalType,i),i.oneofs&&(d.value="optionalType")),d},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(u){return u===void 0&&(u="type.googleapis.com"),u+"/onnx.TypeProto"},a.Tensor=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&d.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&c.onnx.TensorShapeProto.encode(i.shape,d.uint32(18).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.Tensor;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.elemType=i.int32();break}case 2:{m.shape=c.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!l.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var d=c.onnx.TensorShapeProto.verify(i.shape);if(d)return"shape."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.Tensor)return i;var d=new c.onnx.TypeProto.Tensor;if(i.elemType!=null&&(d.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");d.shape=c.onnx.TensorShapeProto.fromObject(i.shape)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.elemType=0,h.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(h.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(h.shape=c.onnx.TensorShapeProto.toObject(i.shape,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Tensor"},u}(),a.Sequence=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.elemType=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&c.onnx.TypeProto.encode(i.elemType,d.uint32(10).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.Sequence;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.elemType=c.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var d=c.onnx.TypeProto.verify(i.elemType);if(d)return"elemType."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.Sequence)return i;var d=new c.onnx.TypeProto.Sequence;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");d.elemType=c.onnx.TypeProto.fromObject(i.elemType)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(h.elemType=c.onnx.TypeProto.toObject(i.elemType,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Sequence"},u}(),a.Map=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.keyType=0,u.prototype.valueType=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.keyType!=null&&Object.hasOwnProperty.call(i,"keyType")&&d.uint32(8).int32(i.keyType),i.valueType!=null&&Object.hasOwnProperty.call(i,"valueType")&&c.onnx.TypeProto.encode(i.valueType,d.uint32(18).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.Map;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.keyType=i.int32();break}case 2:{m.valueType=c.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.keyType!=null&&i.hasOwnProperty("keyType")&&!l.isInteger(i.keyType))return"keyType: integer expected";if(i.valueType!=null&&i.hasOwnProperty("valueType")){var d=c.onnx.TypeProto.verify(i.valueType);if(d)return"valueType."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.Map)return i;var d=new c.onnx.TypeProto.Map;if(i.keyType!=null&&(d.keyType=i.keyType|0),i.valueType!=null){if(typeof i.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");d.valueType=c.onnx.TypeProto.fromObject(i.valueType)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.keyType=0,h.valueType=null),i.keyType!=null&&i.hasOwnProperty("keyType")&&(h.keyType=i.keyType),i.valueType!=null&&i.hasOwnProperty("valueType")&&(h.valueType=c.onnx.TypeProto.toObject(i.valueType,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Map"},u}(),a.Optional=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.elemType=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&c.onnx.TypeProto.encode(i.elemType,d.uint32(10).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.Optional;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.elemType=c.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var d=c.onnx.TypeProto.verify(i.elemType);if(d)return"elemType."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.Optional)return i;var d=new c.onnx.TypeProto.Optional;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");d.elemType=c.onnx.TypeProto.fromObject(i.elemType)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(h.elemType=c.onnx.TypeProto.toObject(i.elemType,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Optional"},u}(),a.SparseTensor=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&d.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&c.onnx.TensorShapeProto.encode(i.shape,d.uint32(18).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.SparseTensor;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.elemType=i.int32();break}case 2:{m.shape=c.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!l.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var d=c.onnx.TensorShapeProto.verify(i.shape);if(d)return"shape."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.SparseTensor)return i;var d=new c.onnx.TypeProto.SparseTensor;if(i.elemType!=null&&(d.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");d.shape=c.onnx.TensorShapeProto.fromObject(i.shape)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.elemType=0,h.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(h.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(h.shape=c.onnx.TensorShapeProto.toObject(i.shape,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.SparseTensor"},u}(),a}(),n.OperatorSetIdProto=function(){function a(t){if(t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.domain="",a.prototype.version=l.Long?l.Long.fromBits(0,0,!1):0,a.create=function(t){return new a(t)},a.encode=function(t,u){return u||(u=p.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&u.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&u.uint32(16).int64(t.version),u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.OperatorSetIdProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.domain=t.string();break}case 2:{d.version=t.int64();break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!l.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!l.isInteger(t.version)&&!(t.version&&l.isInteger(t.version.low)&&l.isInteger(t.version.high))?"version: integer|Long expected":null},a.fromObject=function(t){if(t instanceof c.onnx.OperatorSetIdProto)return t;var u=new c.onnx.OperatorSetIdProto;return t.domain!=null&&(u.domain=String(t.domain)),t.version!=null&&(l.Long?(u.version=l.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?u.version=parseInt(t.version,10):typeof t.version=="number"?u.version=t.version:typeof t.version=="object"&&(u.version=new l.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),u},a.toObject=function(t,u){u||(u={});var i={};if(u.defaults)if(i.domain="",l.Long){var d=new l.Long(0,0,!1);i.version=u.longs===String?d.toString():u.longs===Number?d.toNumber():d}else i.version=u.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?i.version=u.longs===String?String(t.version):t.version:i.version=u.longs===String?l.Long.prototype.toString.call(t.version):u.longs===Number?new l.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},a}(),n.OperatorStatus=function(){var a={},t=Object.create(a);return t[a[0]="EXPERIMENTAL"]=0,t[a[1]="STABLE"]=1,t}(),n.FunctionProto=function(){function a(t){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],t)for(var u=Object.keys(t),i=0;i<u.length;++i)t[u[i]]!=null&&(this[u[i]]=t[u[i]])}return a.prototype.name="",a.prototype.input=l.emptyArray,a.prototype.output=l.emptyArray,a.prototype.attribute=l.emptyArray,a.prototype.attributeProto=l.emptyArray,a.prototype.node=l.emptyArray,a.prototype.docString="",a.prototype.opsetImport=l.emptyArray,a.prototype.domain="",a.create=function(t){return new a(t)},a.encode=function(t,u){if(u||(u=p.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)u.uint32(34).string(t.input[i]);if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)u.uint32(42).string(t.output[i]);if(t.attribute!=null&&t.attribute.length)for(var i=0;i<t.attribute.length;++i)u.uint32(50).string(t.attribute[i]);if(t.node!=null&&t.node.length)for(var i=0;i<t.node.length;++i)c.onnx.NodeProto.encode(t.node[i],u.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(var i=0;i<t.opsetImport.length;++i)c.onnx.OperatorSetIdProto.encode(t.opsetImport[i],u.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&u.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(var i=0;i<t.attributeProto.length;++i)c.onnx.AttributeProto.encode(t.attributeProto[i],u.uint32(90).fork()).ldelim();return u},a.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},a.decode=function(t,u){t instanceof s||(t=s.create(t));for(var i=u===void 0?t.len:t.pos+u,d=new c.onnx.FunctionProto;t.pos<i;){var h=t.uint32();switch(h>>>3){case 1:{d.name=t.string();break}case 4:{d.input&&d.input.length||(d.input=[]),d.input.push(t.string());break}case 5:{d.output&&d.output.length||(d.output=[]),d.output.push(t.string());break}case 6:{d.attribute&&d.attribute.length||(d.attribute=[]),d.attribute.push(t.string());break}case 11:{d.attributeProto&&d.attributeProto.length||(d.attributeProto=[]),d.attributeProto.push(c.onnx.AttributeProto.decode(t,t.uint32()));break}case 7:{d.node&&d.node.length||(d.node=[]),d.node.push(c.onnx.NodeProto.decode(t,t.uint32()));break}case 8:{d.docString=t.string();break}case 9:{d.opsetImport&&d.opsetImport.length||(d.opsetImport=[]),d.opsetImport.push(c.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 10:{d.domain=t.string();break}default:t.skipType(h&7);break}}return d},a.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},a.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!l.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var u=0;u<t.input.length;++u)if(!l.isString(t.input[u]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var u=0;u<t.output.length;++u)if(!l.isString(t.output[u]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var u=0;u<t.attribute.length;++u)if(!l.isString(t.attribute[u]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(var u=0;u<t.attributeProto.length;++u){var i=c.onnx.AttributeProto.verify(t.attributeProto[u]);if(i)return"attributeProto."+i}}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var u=0;u<t.node.length;++u){var i=c.onnx.NodeProto.verify(t.node[u]);if(i)return"node."+i}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!l.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var u=0;u<t.opsetImport.length;++u){var i=c.onnx.OperatorSetIdProto.verify(t.opsetImport[u]);if(i)return"opsetImport."+i}}return t.domain!=null&&t.hasOwnProperty("domain")&&!l.isString(t.domain)?"domain: string expected":null},a.fromObject=function(t){if(t instanceof c.onnx.FunctionProto)return t;var u=new c.onnx.FunctionProto;if(t.name!=null&&(u.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");u.input=[];for(var i=0;i<t.input.length;++i)u.input[i]=String(t.input[i])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");u.output=[];for(var i=0;i<t.output.length;++i)u.output[i]=String(t.output[i])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");u.attribute=[];for(var i=0;i<t.attribute.length;++i)u.attribute[i]=String(t.attribute[i])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");u.attributeProto=[];for(var i=0;i<t.attributeProto.length;++i){if(typeof t.attributeProto[i]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");u.attributeProto[i]=c.onnx.AttributeProto.fromObject(t.attributeProto[i])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");u.node=[];for(var i=0;i<t.node.length;++i){if(typeof t.node[i]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");u.node[i]=c.onnx.NodeProto.fromObject(t.node[i])}}if(t.docString!=null&&(u.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");u.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i){if(typeof t.opsetImport[i]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");u.opsetImport[i]=c.onnx.OperatorSetIdProto.fromObject(t.opsetImport[i])}}return t.domain!=null&&(u.domain=String(t.domain)),u},a.toObject=function(t,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.input=[],i.output=[],i.attribute=[],i.node=[],i.opsetImport=[],i.attributeProto=[]),u.defaults&&(i.name="",i.docString="",i.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.input&&t.input.length){i.input=[];for(var d=0;d<t.input.length;++d)i.input[d]=t.input[d]}if(t.output&&t.output.length){i.output=[];for(var d=0;d<t.output.length;++d)i.output[d]=t.output[d]}if(t.attribute&&t.attribute.length){i.attribute=[];for(var d=0;d<t.attribute.length;++d)i.attribute[d]=t.attribute[d]}if(t.node&&t.node.length){i.node=[];for(var d=0;d<t.node.length;++d)i.node[d]=c.onnx.NodeProto.toObject(t.node[d],u)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.opsetImport&&t.opsetImport.length){i.opsetImport=[];for(var d=0;d<t.opsetImport.length;++d)i.opsetImport[d]=c.onnx.OperatorSetIdProto.toObject(t.opsetImport[d],u)}if(t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.attributeProto&&t.attributeProto.length){i.attributeProto=[];for(var d=0;d<t.attributeProto.length;++d)i.attributeProto[d]=c.onnx.AttributeProto.toObject(t.attributeProto[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},a}(),n}(),r.exports=c});function Hr(e,r){if(!e)throw new Error(typeof r=="string"?r:r())}function mo(e){return new TextDecoder().decode(e)}var q,er,_a,Me,xl,Ee,Ve,C,bo,qr,hr,fr,U=I(()=>{"use strict";Ko(),yl(),q=It(br()),Dt(),er=class{static arraysEqual(e,r){if(e.length!==r.length)return!1;for(let o=0;o<e.length;o++)if(e[o]!==r[o])return!1;return!0}},_a=class{static preprocessInputShapes(e,r){let o=e.length===1?[1,e[0]]:e,s=r.length===1?[r[0],1]:r;return[o,s]}static postprocessOutputShape(e,r,o){r===1&&e.splice(e.length-2,1),o===1&&e.pop()}static calcMatMulShape(e,r){return e[1]!==r[0]?void 0:[e[0],r[1]]}},Me=class tr{static calcShape(r,o,s=!1){let p=r.length,l=o.length;if(p===0)return o;if(l===0)return r;let c=Math.max(r.length,o.length),n=new Array(c);if(s){if(p<2||l<2)return;let a=_a.calcMatMulShape([r[p-2],r[p-1]],[o[l-2],o[l-1]]);if(a===void 0)return;[n[c-2],n[c-1]]=a}for(let a=s?3:1;a<=c;a++){let t=p-a<0?1:r[p-a],u=l-a<0?1:o[l-a];if(t!==u&&t>1&&u>1)return;n[c-a]=Math.max(t,u)}return n}static index(r,o){let s=new Array(o.length);return tr.fillIndex(r,o,s),s}static fillIndex(r,o,s){let p=r.length-o.length;for(let l=0;l<o.length;l++)s[l]=r[p+l]%o[l]}static calc(r,o,s,p,l){let c=tr.calcShape(r.dims,o.dims);if(c){if(p&&!C.areEqual(c,r.dims))return;let n=C.size(c),a=p?r:new Pe(c,l||r.type);if(c.length===0)a.set([],s(r.get([]),o.get([])));else{let t=new Array(c.length),u=new Array(r.dims.length),i=new Array(o.dims.length),d=0,h=0,m=!1,b=!1;r.dims.length===0&&(d=r.get([]),m=!0),o.dims.length===0&&(h=o.get([]),b=!0);let x;for(let E=0;E<n;E++){x=E;for(let w=c.length-1;w>=0;w--)t[w]=x%c[w],x=Math.floor(x/c[w]);m||(tr.fillIndex(t,r.dims,u),d=r.get(u)),b||(tr.fillIndex(t,o.dims,i),h=o.get(i)),a.set(t,s(d,h))}}return a}}static isValidBroadcast(r,o){let s=r.length,p=o.length;if(s>p)return!1;for(let l=1;l<=s;l++)if(r[s-l]!==1&&r[s-l]!==o[p-l])return!1;return!0}static getBroadcastDims(r,o){let s=r.length,p=[];for(let l=0;l<s;l++){let c=s-1-l,n=r[c]||1;(o[o.length-1-l]||1)>1&&n===1&&p.unshift(c)}return p}},xl=class{static getShapeOfGemmResult(e,r,o,s,p){if(e.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let l,c,n;r?(l=e[1],c=e[0]):(l=e[0],c=e[1]);let a=-1;if(s?(n=o[0],a=1):(n=o[1],a=0),o[a]!==c)throw new Error("dimension mismatch");if(l<=0||n<=0||c<=0)throw new Error("invalid shape specified");if(p&&!Me.isValidBroadcast(p,[l,n]))throw new Error("gemm: invalid bias shape for broadcast");return[l,n,c]}},Ee=class yo{static tensorDataTypeFromProto(r){switch(r){case q.onnx.TensorProto.DataType.INT8:return"int8";case q.onnx.TensorProto.DataType.UINT8:return"uint8";case q.onnx.TensorProto.DataType.BOOL:return"bool";case q.onnx.TensorProto.DataType.INT16:return"int16";case q.onnx.TensorProto.DataType.UINT16:return"uint16";case q.onnx.TensorProto.DataType.INT32:return"int32";case q.onnx.TensorProto.DataType.UINT32:return"uint32";case q.onnx.TensorProto.DataType.FLOAT:return"float32";case q.onnx.TensorProto.DataType.DOUBLE:return"float64";case q.onnx.TensorProto.DataType.STRING:return"string";case q.onnx.TensorProto.DataType.INT64:return"int32";case q.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${q.onnx.TensorProto.DataType[r]}`)}}static tensorDataTypeStringToEnum(r){switch(r){case"int8":return q.onnx.TensorProto.DataType.INT8;case"uint8":return q.onnx.TensorProto.DataType.UINT8;case"bool":return q.onnx.TensorProto.DataType.BOOL;case"int16":return q.onnx.TensorProto.DataType.INT16;case"uint16":return q.onnx.TensorProto.DataType.UINT16;case"int32":return q.onnx.TensorProto.DataType.INT32;case"uint32":return q.onnx.TensorProto.DataType.UINT32;case"float32":return q.onnx.TensorProto.DataType.FLOAT;case"float64":return q.onnx.TensorProto.DataType.DOUBLE;case"string":return q.onnx.TensorProto.DataType.STRING;case"int64":return q.onnx.TensorProto.DataType.INT64;case"uint64":return q.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${r}`)}}static tensorDimsFromProto(r){return r.map(o=>tt.isLong(o)?o.toNumber():o)}static tensorValueTypeFromProto(r){return{tensorType:yo.tensorDataTypeFromProto(r.elemType),shape:{dims:yo.tensorDimsFromProto(r.shape.dim.map(o=>o.dimValue))}}}static tensorDimsFromORTFormat(r){let o=[];for(let s=0;s<r.dimsLength();s++)o.push(Ve.longToNumber(r.dims(s)));return o}static tensorAttributesFromORTFormat(r){let o=[];for(let s=0;s<r.attributesLength();s++)o.push(r.attributes(s));return o}},Ve=class{static longToNumber(e,r){return tt.isLong(e)?e.toNumber():e instanceof T.Long?tt.fromValue({low:e.low,high:e.high,unsigned:r??!1}).toNumber():e}static isLong(e){return tt.isLong(e)||e instanceof T.Long}},C=class Qe{static size(r){return Qe.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,o){if(o<0||o>r.length)throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return Qe.getSizeFromDimensionRange(r,o,r.length)}static sizeToDimension(r,o){if(o<0||o>r.length)throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${r.length} dimensions.`);return Qe.getSizeFromDimensionRange(r,0,o)}static getSizeFromDimensionRange(r,o,s){let p=1;for(let l=o;l<s;l++){if(r[l]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");p*=r[l]}return p}static computeStrides(r){let o=r.length;if(o===0)return[];if(o===1)return[1];let s=new Array(o);s[o-1]=1,s[o-2]=r[o-1];for(let p=o-3;p>=0;--p)s[p]=s[p+1]*r[p+1];return s}static transpose(r){return r.slice().reverse()}static indicesToOffset(r,o,s){s===void 0&&(s=r.length);let p=0;for(let l=0;l<s;++l)p+=o[l]*r[l];return p}static offsetToIndices(r,o){let s=o.length;if(s===0)return[];if(s===1)return[r*o[0]];let p=new Array(o.length);for(let l=0;l<p.length-1;++l)p[l]=Math.floor(r/o[l]),r-=p[l]*o[l];return p[p.length-1]=r,p}static normalizeAxis(r,o){if(r<-o&&r>=o)throw new Error("unsupported axis for this operation.");return r<0?r+o:r}static normalizeAxes(r,o){return r.map(s=>this.normalizeAxis(s,o))}static incrementIndex(r,o,s){if(o.length===0||r.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(s===void 0)s=o.length;else if(s<=0||s>o.length)throw new Error("Incorrect axis to increment on");for(let p=s-1;p>=0&&(r[p]++,!(r[p]<o[p]));--p)r[p]=0}static calculateReshapedDims(r,o){if(o.length===0){if(r.length===0||Qe.size(r)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let s=o.length,p=new Array(s),l=-1,c=1;for(let a=0;a<s;a++){if(o[a]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(o[a]===-1){if(l!==-1)throw new Error("at most one dimension in shape hints can be -1");l=a}else{if(o[a]===0){if(a>=r.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");p[a]=r[a]}else p[a]=o[a];c*=p[a]}}let n=Qe.size(r);if(l!==-1){if(n%c!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${r}] Output shape: [${o}]`);p[l]=n/c}else if(c!==n)throw new Error("reshapedDims and originalDims don't have matching sizes");return p}static sortBasedOnPerm(r,o){return o?o.map(s=>r[s]):r.slice().reverse()}static padShape(r,o){let s=r.length;return r.map((p,l)=>p+o[l]+o[l+s])}static areEqual(r,o){return r.length!==o.length?!1:r.every((s,p)=>s===o[p])}static validateDimsAndCalcSize(r){if(r.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let o=1;for(let s of r){if(!Number.isInteger(s))throw new TypeError(`Invalid shape: ${s} is not an integer`);if(s<0||s>2147483647)throw new TypeError(`Invalid shape: length ${s} is not allowed`);o*=s}return o}static flattenShape(r,o){o<0&&(o+=r.length);let s=r.reduce((l,c)=>l*c,1),p=r.slice(o).reduce((l,c)=>l*c,1);return[s/p,p]}static squeezeShape(r,o){let s=new Array;o=Qe.normalizeAxes(o,r.length);for(let p=0;p<r.length;p++){let l=o.indexOf(p)>=0;if(l&&r[p]!==1)throw new Error("squeeze an axis of size different than 1");(o.length===0&&r[p]>1||o.length>0&&!l)&&s.push(r[p])}return s}static unsqueezeShape(r,o){let s=new Array(r.length+o.length);s.fill(0);for(let l=0;l<o.length;l++){let c=Qe.normalizeAxis(o[l],s.length);if(c>=s.length)throw new Error("'axes' has an out of range axis");if(s[c]!==0)throw new Error("'axes' has a duplicate axis");s[c]=1}let p=0;for(let l=0;l<s.length;l++)s[l]===0&&(s[l]=r[p++]);if(p!==r.length)throw new Error("the unsqueezed dimension could not be established");return s}},bo=class Tl{static splitShape(r,o,s,p){if(s.length===0){if(!p)throw new Error("need to know number of outputs when the 'split' attribute is not specified");Tl.determineSplit(r[o],p,s)}let l=[],c=[0];for(let n=0;n<s.length;++n){n!==0&&c.push(c[n-1]+s[n-1]);let a=r.slice();a[o]=s[n],l.push(a)}return[l,c]}static determineSplit(r,o,s){if(r%o!==0)throw new Error("cannot split tensor to equal sized parts");for(let p=0;p<o;++p)s.push(r/o)}},qr=class rr{static adjustPoolAttributes(r,o,s,p,l,c){if(!r&&s.length!==o.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let n=0;n<o.length-2;n++)n>=s.length?s.push(o[n+2]):s[n]=o[n+2];for(let n=0;n<s.length;n++)if(n<p.length){if(p[n]<0)throw new Error("strides should be greater than or equal to 1")}else p.push(1);for(let n=0;n<s.length;n++)if(n<l.length){if(l[n]<0)throw new Error("dilations should be greater than or equal to 1")}else l.push(1);for(let n=0;n<s.length*2;n++)if(n<c.length){if(c[n]<0)throw new Error("pad should be greater than or equal to 1")}else c.push(0);for(let n=0;n<s.length;n++){if(s[n]<=0)throw new Error("kernel shapes need to be greater than 0");if(c[n]>=s[n]||c[n+s.length]>=s[n])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,o,s,p,l,c){if(c){if(l.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(o.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(p.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let n=0;n<r.length-2;n++)rr.adjustPadAndReturnShape(r[n+2],o[n],s[n],p[n],l,n,n+r.length-2,c)}}static computePoolOutputShape(r,o,s,p,l,c,n){if(o.length<=0)throw new Error("input shape must be of size greater than 0");let a=[o[0],o[1]];return rr.computeShapeHelper(r,o,a,s,p,l,c,n),a}static computeConvOutputShape(r,o,s,p,l,c,n){if(r.length<=0||o.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[r[0],o[0]];return rr.computeShapeHelper(!1,r,a,s,p,l,c,n),a}static computeShapeHelper(r,o,s,p,l,c,n,a){if(r)for(let t=0;t<o.length-2;t++)s.push(1);else for(let t=0;t<o.length-2;t++)s.push(rr.adjustPadAndReturnShape(o[t+2],p[t],l[t],c[t],n,t,t+o.length-2,a))}static adjustPadAndReturnShape(r,o,s,p,l,c,n,a){let t=s*(p-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return l[c]=0,l[n]=0,Math.floor((r-t)/o+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let u=((r+o-1)/o-1)*o+p-r;return l[c]=Math.floor(a==="SAME_LOWER"?(u+1)/2:u/2),l[n]=u-l[c],Math.floor((r+u-p)/o+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+l[c]+l[n]-t)/o+1)}},hr=-34028234663852886e22,fr=34028234663852886e22});function ef(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}function Sa(e){switch(e){case L.onnx.TensorProto.DataType.UINT8:case L.onnx.TensorProto.DataType.INT8:case L.onnx.TensorProto.DataType.BOOL:return 1;case L.onnx.TensorProto.DataType.UINT16:case L.onnx.TensorProto.DataType.INT16:return 2;case L.onnx.TensorProto.DataType.FLOAT:case L.onnx.TensorProto.DataType.INT32:case L.onnx.TensorProto.DataType.UINT32:return 4;case L.onnx.TensorProto.DataType.INT64:case L.onnx.TensorProto.DataType.DOUBLE:case L.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${L.onnx.TensorProto.DataType[e]}`)}}function tf(e,r){return new(_l(r))(e)}function _l(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function wo(e,r){if(r===L.onnx.TensorProto.DataType.INT64||r===Mr.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(r===L.onnx.TensorProto.DataType.UINT32||r===Mr.TensorDataType.UINT32||r===L.onnx.TensorProto.DataType.UINT64||r===Mr.TensorDataType.UINT64){if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${L.onnx.TensorProto.DataType[r]}`);return e.toNumber()}function Oa(e,r,o){switch(r){case L.onnx.TensorProto.DataType.BOOL:case L.onnx.TensorProto.DataType.UINT8:return e.getUint8(o);case L.onnx.TensorProto.DataType.INT8:return e.getInt8(o);case L.onnx.TensorProto.DataType.UINT16:return e.getUint16(o,!0);case L.onnx.TensorProto.DataType.INT16:return e.getInt16(o,!0);case L.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(o,!0);case L.onnx.TensorProto.DataType.INT32:return e.getInt32(o,!0);case L.onnx.TensorProto.DataType.UINT32:return e.getUint32(o,!0);case L.onnx.TensorProto.DataType.INT64:return wo(tt.fromBits(e.getUint32(o,!0),e.getUint32(o+4,!0),!1),r);case L.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(o,!0);case L.onnx.TensorProto.DataType.UINT64:return wo(tt.fromBits(e.getUint32(o,!0),e.getUint32(o+4,!0),!0),r);default:throw new Error(`cannot read from DataView for type ${L.onnx.TensorProto.DataType[r]}`)}}var Ea,L,Mr,Pe,Dt=I(()=>{"use strict";Ea=It(jh()),yl(),Qr(),L=It(br()),U(),Mr=H.experimental.fbs,Pe=class zr{constructor(r,o,s,p,l,c=Ea.Guid.create()){this.dims=r,this.type=o,this.dataProvider=s,this.asyncDataProvider=p,this.cache=l,this.dataId=c,this.size=C.validateDimsAndCalcSize(r);let n=this.size,a=s===void 0&&p===void 0&&l===void 0;if(l!==void 0&&l.length!==n)throw new RangeError("Input dims doesn't match data length.");if(o==="string"){if(l!==void 0&&(!Array.isArray(l)||!l.every(t=>typeof t=="string")))throw new TypeError("cache should be a string array");a&&(this.cache=new Array(n))}else{if(l!==void 0){let t=_l(o);if(!(l instanceof t))throw new TypeError(`cache should be type ${t.name}`)}if(a){let t=new ArrayBuffer(n*ef(o));this.cache=tf(t,o)}}}get data(){if(this.cache===void 0){let r=this.dataProvider(this.dataId);if(r.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=r}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(r){return this.data[C.indicesToOffset(r,this.strides)]}set(r,o){this.data[C.indicesToOffset(r,this.strides)]=o}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=C.computeStrides(this.dims)),this._strides}static fromProto(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let o=Ee.tensorDataTypeFromProto(r.dataType),s=Ee.tensorDimsFromProto(r.dims),p=new zr(s,o);if(o==="string")r.stringData.forEach((l,c)=>{p.data[c]=mo(l)});else if(r.rawData&&typeof r.rawData.byteLength=="number"&&r.rawData.byteLength>0){let l=p.data,c=new DataView(r.rawData.buffer,r.rawData.byteOffset,r.rawData.byteLength),n=Sa(r.dataType),a=r.rawData.byteLength/n;if(r.rawData.byteLength%n!==0)throw new Error("invalid buffer length");if(l.length!==a)throw new Error("buffer length mismatch");for(let t=0;t<a;t++){let u=Oa(c,r.dataType,t*n);l[t]=u}}else{let l;switch(r.dataType){case L.onnx.TensorProto.DataType.FLOAT:l=r.floatData;break;case L.onnx.TensorProto.DataType.INT32:case L.onnx.TensorProto.DataType.INT16:case L.onnx.TensorProto.DataType.UINT16:case L.onnx.TensorProto.DataType.INT8:case L.onnx.TensorProto.DataType.UINT8:case L.onnx.TensorProto.DataType.BOOL:l=r.int32Data;break;case L.onnx.TensorProto.DataType.INT64:l=r.int64Data;break;case L.onnx.TensorProto.DataType.DOUBLE:l=r.doubleData;break;case L.onnx.TensorProto.DataType.UINT32:case L.onnx.TensorProto.DataType.UINT64:l=r.uint64Data;break;default:throw new Error("unspecific error")}if(l==null)throw new Error("failed to populate data from a tensorproto value");let c=p.data;if(c.length!==l.length)throw new Error("array length mismatch");for(let n=0;n<l.length;n++){let a=l[n];tt.isLong(a)?c[n]=wo(a,r.dataType):c[n]=a}}return p}static fromData(r,o,s){return new zr(o,s,void 0,void 0,r)}static fromOrtTensor(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let o=Ee.tensorDimsFromORTFormat(r),s=Ee.tensorDataTypeFromProto(r.dataType()),p=new zr(o,s);if(s==="string")for(let l=0;l<r.stringDataLength();l++)p.data[l]=r.stringData(l);else if(r.rawDataArray()&&typeof r.rawDataLength()=="number"&&r.rawDataLength()>0){let l=p.data,c=new DataView(r.rawDataArray().buffer,r.rawDataArray().byteOffset,r.rawDataLength()),n=Sa(r.dataType()),a=r.rawDataLength()/n;if(r.rawDataLength()%n!==0)throw new Error("invalid buffer length");if(l.length!==a)throw new Error("buffer length mismatch");for(let t=0;t<a;t++){let u=Oa(c,r.dataType(),t*n);l[t]=u}}return p}}});function B(e){return e===1?Sl:Ol}function rf(e){let r=B(e);return`${r.version}
      precision highp float;
      ${r.attribute} vec3 position;
      ${r.attribute} vec2 textureCoord;

      ${r.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function nf(e){let r=B(e);return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFrag} vec2 TexCoords;
    ${r.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function of(e,r){let o=B(e);return`
  void main() {
    int indices[${r}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o.output} = result;
  }
  `}var Sl,Ol,Y=I(()=>{"use strict";Sl={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},Ol={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),V=I(()=>{"use strict"});async function Ia(e,r=s=>0,o){return new Promise((s,p)=>{let l=0,c=()=>{if(e()){s();return}l++;let n=r(l);if(o!=null&&l>=o){p();return}setTimeout(c,n)};c()})}function In(e){return Hr(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)}function af(e){return Hr(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"}function Gt(e,r){let o=JSON.parse(JSON.stringify(e));return o=r,o}function Ht(e,r){return r.map(o=>e[o]).join(", ")}function rt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function $t(e=6){return["x","y","z","w","u","v"].slice(0,e)}var qe=I(()=>{"use strict";U()});function sf(e,r){return $t(r).map(o=>`${e}.${o}`)}function Zo(e,r){return r===1?[e]:sf(e,r)}function yr(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var Nt=I(()=>{"use strict";qe()});function uf(e,r,o){if(e===0)return"false";if(e===1)return`rc > ${r[0]}`;let s="";for(let p=e-2;p<e;p++)s+=`${o[p]} >= ${r[p-e+2]}`,p<e-1&&(s+="||");return s}function lf(e,r){let o=e.length;if(o===0)return"getA(), 0, 0, 0";if(o===1)return`getA(rc),
            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),
            0, 0`;let s="r, c",p="r, cp1",l="rp1, c",c="rp1, cp1",n="";if(o>2)for(let a=0;a<o-2;++a)n=n+`${r[a]},`;return`getA(${n}${s}),
          rEdge ? 0. : getA(${n}${l}),
          cEdge ? 0. : getA(${n}${p}),
          rEdge || cEdge ? 0. : getA(${n}${c})`}function pf(e,r,o,s){return e===0||e===1?"":`
    int r = ${r[e-2]};
    int c = ${r[e-1]};
    int rp1 = ${r[e-2]} + 1;
    int cp1 = ${r[e-1]} + 1;
    bool rEdge = rp1 >= ${s};
    bool cEdge = cp1 >= ${o};
    `}var Pn,Pa,El,cf=I(()=>{"use strict";Y(),V(),qe(),Nt(),Pn={name:"pack",inputNames:["A"],inputTypes:[1]},Pa=(e,r)=>{let o=B(e.session.backend.glContext.version),s=r.dims,p=s.length,l=r.dims.length,c=rt(l),n=Zo("rc",l),a=pf(l,n,s[s.length-2],s[s.length-1]),t;p===0?t=[1,1]:p===1?t=[s[0],1]:t=[s[l-1],s[l-2]];let u=uf(l,t,n),i=lf(s,n),d=`
        void main() {
          ${c} rc = getOutputCoords();

          if(${u}) {
            ${o.output} = vec4(0);
          } else {
            ${a}

            ${o.output} = vec4(${i});
          }
        }
      `;return{...Pn,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:2},shaderSource:d}},El=(e,r)=>({...Pn,get:()=>Pa(e,r)})});function Aa(e){if(e.length===0)return[1,1,1];let r=1;for(let o=0;o<e.length-2;++o)r*=e[o];return[r,e.length>1?e[e.length-2]:1,e[e.length-1]]}function df(e,r){let o=!1;return e.length===0||r.length===0?o=!0:e.length<2||r.length<2?o=e[e.length-1]===r[r.length-1]:o=e[e.length-1]===r[r.length-1]&&e[e.length-2]===r[r.length-2],o}function hf(e){let r=C.computeStrides(e),o=["b","r","c"],s="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r.map((p,l)=>{let c=`int ${o[l]} = ${s} / ${p}`,n=l===r.length-1?`int ${o[l+1]} = ${s} - ${o[l]} * ${p}`:`index -= ${o[l]} * ${p}`;return`${c}; ${n};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function ff(e){let r=C.computeStrides(e);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${r[0]} + coords.z * ${r[1]} + coords.y;
  }
`}var $a,Da,Il,gf=I(()=>{"use strict";U(),Y(),V(),Nt(),$a=e=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${e}`}),Da=(e,r,o,s)=>{let p=r.dims,l=s,c="";for(let t=0;t<4;t++){let u="";switch(t){case 0:u="outputCoords = rc;";break;case 1:u="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:u="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:u="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}c+=`
        ${u}
        ${t>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${t>0?"}":""}
      `}let n=B(e.session.backend.glContext.version),a=`
      ${hf(p)}
      ${ff(l)}
      ${yr()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${l[2]};
        int cols = ${l[1]};

        ${c}
        ${n.output} = result;
      }
    `;return{...o,output:{dims:l,type:r.type,textureType:2},shaderSource:a,hasMain:!0}},Il=(e,r,o)=>{let s=$a(o);return{...s,get:()=>Da(e,r,s,o)}}}),vo,mf=I(()=>{"use strict";Y(),V(),vo=(e,r)=>{let o=r.shape,s=B(e.session.backend.glContext.version),p=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${s.texture2D}(X,TexCoords).r;
      ${s.output} = encodeAsUint8(value);
    }`,l={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:o,type:r.tensor.type,textureType:3},shaderSource:p,hasMain:!0};return e.executeProgram(l,[r.tensor])}});function bf(e,r){if(e===1)return"rc";let o="";for(let s=0;s<e;s++)o+=r[s],s<e-1&&(o+=",");return o}var An,Na,Pl,yf=I(()=>{"use strict";Y(),V(),qe(),Nt(),An={name:"unpack",inputNames:["A"],inputTypes:[2]},Na=(e,r)=>{let o=r.dims.length,s=Zo("rc",o),p=s.slice(-2),l=rt(o),c=yr(),n=r.dims.length===0?"":bf(o,s),a=o<=1?"rc":`vec2(${p.join(",")})`,t=B(e.session.backend.glContext.version),u=`
    ${c}
    void main() {
      ${l} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${n});

       ${t.output} = vec4(getChannel(packedInput, ${a}), 0, 0, 0);
     }
   `;return{...An,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:u}},Pl=(e,r)=>({...An,get:()=>Na(e,r)})}),Al,xo,$l,Wr=I(()=>{"use strict";Re(),Al=class{constructor(e,r=1){if(r===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){let o,s;return e.constructor!==Float32Array&&(ee.warning("Encoder","data was not of type Float32; creating new Float32Array"),s=new Float32Array(e)),r*this.channelSize>e.length?(ee.warning("Encoder","Source data too small. Allocating larger array"),s=e,o=this.allocate(r*this.channelSize),s.forEach((p,l)=>o[l]=p)):(s=e,o=s),o}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((o,s)=>s%4===0).subarray(0,r):e.subarray(0,r)}},xo=class{constructor(e,r=1,o){if(r!==1&&r!==4)throw new Error(`Invalid number of channels: ${r}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=r,this.textureType=o||e.FLOAT}encode(e,r){let o=e;return this.channelSize===1&&(ee.verbose("Encoder","Exploding into a larger array"),o=this.allocate(r),e.forEach((s,p)=>o[p*4]=s)),o}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((o,s)=>s%4===0).subarray(0,r):e.subarray(0,r)}},$l=class{constructor(e,r=1){if(this.channelSize=4,r===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,r){if(e instanceof Uint8Array)return e.subarray(0,r);throw new Error(`Invalid array type: ${e.constructor}`)}}}),lr,Dl,To,wf=I(()=>{"use strict";U(),V(),lr=(e,r,o)=>{let s=o===0||o===1?1:4,p=o===2,l=o===1||o===2,c=o===4?r.length-1:void 0,n=o===4?r.map((a,t)=>t===r.length-1?a*4:a):void 0;return To(e,r,s,n,{isPacked:p,reverseWH:l,breakAxis:c})},Dl=(e,r,o)=>{let s=lr(e,r,o);return[s.width,s.height]},To=(e,r,o=1,s,p)=>{let l=!!(p&&p.isPacked),[c,n]=e.computeTextureWH(l&&s||r,p),a=r.length,t=r.slice(0);if(a===0&&(t=[1]),o===1)s=r;else if(l){if(o!==4)throw new Error("a packed texture must be 4-channel");s=r,a>0&&(t[a-1]=Math.ceil(t[a-1]/2)),a>1&&(t[a-2]=Math.ceil(t[a-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:c,height:n,channels:o,isPacked:l,shape:t,strides:C.computeStrides(t),unpackedShape:s,reversedWH:p&&p.reverseWH}}}),ka,Nl,vf=I(()=>{"use strict";Re(),Dt(),U(),cf(),gf(),mf(),yf(),Wr(),wf(),V(),ka=(e,r)=>{let o=r.map(p=>`${p.unpackedShape.join(",")};${p.width}x${p.height}`).join("_"),s=e.name;return e.cacheHint&&(s+="["+e.cacheHint+"]"),s+=":"+o,s},Nl=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,r){return Dl(this.session.layoutStrategy,e,r)}executeProgram(e,r){if(r.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let o=[];for(let a=0;a<e.inputNames.length;++a)o[a]=this.getOrCreateTextureData(r[a],e.inputTypes[a]);let s=ka(e,o),p=this.session.programManager.getArtifact(s),l=p?p.programInfo:typeof e.get=="function"?e.get():e,c=lr(this.session.layoutStrategy,l.output.dims,l.output.textureType),n=this.createTextureData(c,l.output.type);return p||(p=this.session.programManager.build(l,o,n),this.session.programManager.setArtifact(s,p)),this.runProgram(p,o,n),n}run(e,r){return this.executeProgram(e,r).tensor}runProgram(e,r,o){for(let s=0;s<r.length;++s)if(!!r[s].isPacked!=(e.programInfo.inputTypes[s]===2))throw new Error(`input[${s}] property packed inconsistent`);if(!!o.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,r,o)}getOrCreateTextureData(e,r){let o=this.getTextureData(e.dataId,r===2);if(!o&&(o=this.getTextureData(e.dataId,r!==2),o))return r===2?this.pack(o):this.unpack(o);if(!o){let s=lr(this.session.layoutStrategy,e.dims,r);if(r===4){let p=e.dims;if(p.length===4){let l=[p[0],Math.ceil(p[1]*p[2]*p[3]/4)],c=lr(this.session.layoutStrategy,l,r),n=e.numberData;if(p[1]*p[2]*p[3]%4!==0){let a=p[0],t=p[1]*p[2]*p[3],u=Math.ceil(t*1/4)*4,i=a*u;n=new Float32Array(i);for(let d=0;d<a;++d){let h=d*t,m=d*u+d%1*t;n.set(e.numberData.subarray(h,h+t),m)}}return this.createTextureData(c,e.type,n,e,1)}}if(r===2){let p=To(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),l=this.createTextureData(p,e.type,e.numberData,e,1);o=this.pack(l)}else o=this.createTextureData(s,e.type,e.numberData,e,1)}return o}createTextureDataFromLayoutBindTensor(e,r,o,s){return this.createTextureData(e,r,o,s,1)}createTextureData(e,r,o,s,p){ee.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let l=this.session.textureManager.createTextureFromLayout(r,e,o,p);return this.createTextureDataFromTexture(e,r,l,s)}reshapeUnpacked(e,r){let o=this.getOrCreateTextureData(e,0),s={channels:o.channels,height:o.height,width:o.width,shape:r.length!==0?r:[1],strides:C.computeStrides(r),unpackedShape:r};return this.createTextureDataFromTexture(s,e.type,o.texture).tensor}reshapePacked(e,r){let o=this.getOrCreateTextureData(e,2);if(df(e.dims,r)){let n={channels:o.channels,height:o.height,width:o.width,shape:r.length!==0?r:[1],strides:C.computeStrides(r),unpackedShape:r,isPacked:!0};return this.createTextureDataFromTexture(n,e.type,o.texture).tensor}let s=Aa(e.dims),p=Aa(r),l=this.reshapePacked(e,s),c=this.run(Il(this,l,p),[l]);return this.reshapePacked(c,r)}cast(e,r){let o=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(o,r,o.texture).tensor}createTextureDataFromTexture(e,r,o,s,p){let l={...e,tensor:s||new Pe(e.unpackedShape,r,c=>this.readTexture(l),async c=>this.readTextureAsync(l),void 0,p),texture:o};return this.setTextureData(l.tensor.dataId,l,e.isPacked),l}getTextureData(e,r=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,r):r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,o=!1){this.session.isInitializer(e)?this.session.setTextureData(e,r,o):(o?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,r)}isTextureLayoutCached(e,r=!1){return!!this.getTextureData(e.dataId,r)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(vo(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(vo(this,e))}pack(e){return this.executeProgram(El(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(Pl(this,e.tensor),[e.tensor])}}}),Fa,X,le=I(()=>{"use strict";Fa=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},X=e=>new Fa(e)}),$n,kl,Fl,Ca,La,xf=I(()=>{"use strict";le(),Y(),V(),$n={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},kl=(e,r,o)=>(La(r),[e.run({...$n,cacheHint:o.cacheKey,get:()=>Ca(e,r,o)},r)]),Fl=e=>{let r=e.attributes.getFloat("epsilon",1e-5),o=e.attributes.getFloat("momentum",.9),s=e.attributes.getInt("spatial",1);return X({epsilon:r,momentum:o,spatial:s})},Ca=(e,r,o)=>{let s=B(e.session.backend.glContext.version),p=r[0].dims.length,[l,c]=e.calculateTextureWidthAndHeight(r[1].dims,0),n=`
  float process(int[${p}] indices) {
    vec2 position = offsetToCoords(indices[1], ${l}, ${c});
    float scale = getColorAsFloat(${s.texture2D}(Scale, position));
    float mean = getColorAsFloat(${s.texture2D}(Mean, position));
    float variance = getColorAsFloat(${s.texture2D}(Variance, position));
    float b = getColorAsFloat(${s.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${o.epsilon})) ) + b;
  }`;return{...$n,output:{dims:r[0].dims,type:r[0].type,textureType:0},shaderSource:n}},La=e=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let r=e[0],o=e[1],s=e[2],p=e[3],l=e[4];if(r.dims.length<3||o.dims.length!==1||s.dims.length!==1||p.dims.length!==1||l.dims.length!==1)throw new Error("invalid input shape.");if(o.dims[0]!==r.dims[1]||s.dims[0]!==r.dims[1]||p.dims[0]!==r.dims[1]||l.dims[0]!==r.dims[1])throw new Error("invalid input shape.");if(r.type!=="float32"&&r.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||p.type!=="float32"&&p.type!=="float64"||l.type!=="float32"&&l.type!=="float64")throw new Error("invalid input tensor types.")}}),Cl,kt,D,_o,Ll,nt=I(()=>{"use strict";Cl=class{constructor(e,r,o,s){this.glContext=e,this.programInfo=r,this.inputTextureLayouts=o,this.outputTextureLayout=s}},kt=class{constructor(e){this.context=e}},D=class{constructor(e,r){this.routineBody=e,this.dependencies=r}},_o=class{constructor(e,r,o){this.name=e,o?this.dependencies=o:this.dependencies=[],r&&(this.routineBody=r)}addDependency(e){e&&this.dependencies.push(e)}},Ll=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let r=new Set,o=new Set,s=new Array;return this.createOrderedNodes(e,r,o,s),s}static createOrderedNodes(e,r,o,s){for(let p=0;p<e.length;++p)this.dfsTraverse(e[p],r,o,s)}static dfsTraverse(e,r,o,s){if(!e||o.has(e.name))return;if(r.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");r.add(e.name);let p=e.dependencies;if(p&&p.length>0)for(let l=0;l<p.length;++l)this.dfsTraverse(p[l],r,o,s);s.push(e),o.add(e.name),r.delete(e.name)}}});function Tf(){let e="add_";return{body:`
  float ${e}(float a, float b) {
    return a + b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:e,type:0}}function _f(){let e="div_";return{body:`
  float ${e}(float a, float b) {
    return a / b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:e,type:0}}function Sf(){let e="mul_";return{body:`
  float ${e}(float a, float b) {
    return a * b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:e,type:0}}function Of(){let e="sub_";return{body:`
  float ${e}(float a, float b) {
    return a - b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:e,type:0}}function Ef(){let e="equal_";return{body:`
  float ${e}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:e,type:0}}function If(){let e="greater_";return{body:`
  float ${e}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:e,type:0}}function Pf(){let e="less_";return{body:`
  float ${e}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:e,type:0}}function Af(){let e="and_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:e,type:0}}function $f(){let e="or_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:e,type:0}}function Df(){let e="xor_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:e,type:0}}function Nf(){return Ff("pow")}function kf(){let e="prelu_";return{body:`
  float ${e}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:e,type:0}}function Ff(e){let r=`${e}_`;return{body:`
  float ${r}(float a, float b) {
    return ${e}(a, b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return ${e}(v1, v2);
  }
  `,name:r,type:0}}var Se,Ra,Rl,jl,Bl,Vl,Ml,zl,Ul,Gl,Hl,ql,Wl,Xl,Cf=I(()=>{"use strict";U(),nt(),Y(),V(),Se=(e,r,o,s=r[0].type,p)=>{let l=e.session.pack?2:0;return{name:o.name,inputNames:["A","B"],inputTypes:[l,l],cacheHint:p,get:()=>Ra(e,r,o,s)}},Ra=(e,r,o,s=r[0].type)=>{let p=e.session.pack?2:0,l=!C.areEqual(r[0].dims,r[1].dims),c=r[0].dims,n=e.session.pack;if(l){let u=Me.calcShape(r[0].dims,r[1].dims,!1);if(!u)throw new Error("Can't perform binary op on the given tensors");c=u;let i=c.length,d=r[0].dims.length!==0?r[0].dims.length:1,h=r[1].dims.length!==0?r[1].dims.length:1,m=r[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",b=r[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",x=B(e.session.backend.glContext.version),E=n?`
      ${o.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${o.name}(a, b);
        ${x.output} = result;
      }`:`
      ${o.body}
      float process(int indices[${i}]) {
        int aindices[${d}];
        int bindices[${h}];
        ${m}
        ${b}
        return ${o.name}(_A(aindices), _B(bindices));
      }`;return{name:o.name,inputNames:["A","B"],inputTypes:[p,p],output:{dims:c,type:s,textureType:p},shaderSource:E,hasMain:n}}let a=B(e.session.backend.glContext.version),t=`
    ${o.body}
    void main() {
      vec4 v1 = ${a.texture2D}(A, TexCoords);
      vec4 v2 = ${a.texture2D}(B, TexCoords);
      vec4 result = ${o.name}(v1, v2);
      ${a.output} = result;
    }
    `;return{name:o.name,inputNames:["A","B"],inputTypes:[p,p],output:{dims:r[0].dims,type:s,textureType:p},shaderSource:t,hasMain:!0}},Rl=(e,r)=>[e.run(Se(e,r,Tf()),r)],jl=(e,r)=>[e.run(Se(e,r,Af(),"bool"),r)],Bl=(e,r)=>[e.run(Se(e,r,_f()),r)],Vl=(e,r)=>[e.run(Se(e,r,Ef(),"bool"),r)],Ml=(e,r)=>[e.run(Se(e,r,If(),"bool"),r)],zl=(e,r)=>[e.run(Se(e,r,Pf(),"bool"),r)],Ul=(e,r)=>[e.run(Se(e,r,Sf()),r)],Gl=(e,r)=>[e.run(Se(e,r,$f(),"bool"),r)],Hl=(e,r)=>[e.run(Se(e,r,Nf()),r)],ql=(e,r)=>[e.run(Se(e,r,kf()),r)],Wl=(e,r)=>[e.run(Se(e,r,Of()),r)],Xl=(e,r)=>[e.run(Se(e,r,Df(),"bool"),r)]}),Kl,Zl,ja,Lf=I(()=>{"use strict";U(),Kl=(e,r,o)=>(ja(r),[e.cast(r[0],o)]),Zl=e=>Ee.tensorDataTypeFromProto(e.attributes.getInt("to")),ja=e=>{if(!e||e.length!==1)throw new Error("Cast requires 1 input.");if(e[0].type==="string")throw new Error("Invalid input type.")}}),Ba,Va,Jl,qt,Rf=I(()=>{"use strict";Y(),V(),qe(),Nt(),Ba=(e,r)=>({name:"Concat (packed)",inputNames:Array.from({length:e},(o,s)=>`X${s}`),inputTypes:Array(e).fill(2),cacheHint:r}),Va=(e,r,o,s)=>{let p=o[0].dims.slice();if(s>=p.length||s<-1*p.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=p.length+s);let l=p.slice(0);for(let F=1;F<o.length;F++){let be=o[F].dims.slice();for(let pe=0;pe<p.length;pe++)if(pe===s)l[s]+=be[pe];else if(p[pe]!==be[pe])throw new Error("non concat dimensions must match")}let c=l.length,n=Zo("coords",c),a=rt(c),t=yr(),u=o.map(F=>F.dims),i=$t(c),d=new Array(u.length-1);d[0]=u[0][s];for(let F=1;F<d.length;F++)d[F]=d[F-1]+u[F][s];let h=i[s],m=i.slice(-2),b=i.join(),x=`if (${h} < ${d[0]}) {
        return getChannel(
            getX0(${b}), vec2(${m.join()}));
        }`;for(let F=1;F<d.length;F++){let be=d[F-1];x+=`
            if (${h} < ${d[F]}  && ${h} >= ${d[F-1]}) {
              return getChannel(
                getX${F}(${qt(i,h,be)}),
                vec2(${qt(m,h,be)}));
            }`}let E=d.length,w=d[d.length-1];x+=`
            return getChannel(
              getX${E}(${qt(i,h,w)}),
              vec2(${qt(m,h,w)}));`;let S=B(e.session.backend.glContext.version),$=`
          ${t}
          float getValue(${i.map(F=>"int "+F)}) {
            ${x}
          }

          void main() {
            ${a} coords = getOutputCoords();
            int lastDim = coords.${i[c-1]};
            coords.${i[c-1]} = coords.${i[c-2]};
            coords.${i[c-2]} = lastDim;

            vec4 result = vec4(getValue(${n}), 0., 0., 0.);

            ${n[c-1]} = ${n[c-1]} + 1;
            if (${n[c-1]} < ${l[c-1]}) {
              result.g = getValue(${n});
            }

            ${n[c-2]} = ${n[c-2]} + 1;
            if (${n[c-2]} < ${l[c-2]}) {
              result.a = getValue(${n});
            }

            ${n[c-1]} = ${n[c-1]} - 1;
            if (${n[c-2]} < ${l[c-2]} &&
                ${n[c-1]} < ${l[c-1]}) {
              result.b = getValue(${n});
            }
            ${S.output} = result;
          }
        `;return{...r,output:{dims:l,type:o[0].type,textureType:2},shaderSource:$,hasMain:!0}},Jl=(e,r,o)=>{let s=Ba(r.length,o.cacheKey);return{...s,get:()=>Va(e,s,r,o.axis)}},qt=(e,r,o)=>{let s=e.indexOf(r);return e.map((p,l)=>l===s?`${p} - ${o}`:p).join()}}),Yl,Ma,za,Ua,Dn,Ga,Ha,qa,Ql,Wa,jf=I(()=>{"use strict";le(),V(),Rf(),Yl=(e,r,o)=>(Wa(r),e.session.pack&&r[0].dims.length>1?[e.run(Jl(e,r,o),r)]:[e.run(Ua(e,r,o),r)]),Ma=(e,r)=>({name:"Concat",inputNames:Array.from({length:e},(o,s)=>`X${s}`),inputTypes:Array(e).fill(0),cacheHint:r}),za=(e,r,o,s)=>{let p=o[0].dims.slice();if(s>=p.length||s<-1*p.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=p.length+s);let l=p.slice(0);for(let h=1;h<o.length;h++){let m=o[h].dims.slice();for(let b=0;b<p.length;b++)if(b===s)l[s]+=m[b];else if(p[b]!==m[b])throw new Error("non concat dimensions must match")}let c=l.length,n=new Array(o.length),a=0;for(let h=0;h<n.length;++h)a+=o[h].dims[s],n[h]=a;let t="";o.length<5?t=Dn(n):t=Ga(n);let u=Ha(o.length,c),i=qa(n),d=`
        ${u}
        ${i}
        ${t}
        float process(int indices[${c}]) {
          int textureIndex = getTextureWhereDataResides (indices[${s}]);

          if(textureIndex != 0) {
            indices[${s}] = indices[${s}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...r,output:{dims:l,type:o[0].type,textureType:0},shaderSource:d}},Ua=(e,r,o)=>{let s=Ma(r.length,o.cacheKey);return{...s,get:()=>za(e,s,r,o.axis)}},Dn=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((r,o)=>`if(index<${r}) {return ${o};}
`).join("")}
    }`,Ga=e=>Dn(e),Ha=(e,r)=>{let o=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${r}]) {`];for(let s=0;s<e;++s)s===0?o.push(`	if (textureIndex == ${s}) { return _X${s}(indices); }`):s===e-1?o.push(`	else { return _X${s}(indices); }`):o.push(`	else if (textureIndex == ${s}) { return _X${s}(indices); }`);return o.push("	}"),o.join(`
`)},qa=e=>{let r=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let o=0;o<e.length;++o)o===0?r.push(`	if (index == ${o}) { return ${e[o]}; }`):o===e.length-1?r.push(`	else { return ${e[o]}; }`):r.push(`	else if (index == ${o}) { return ${e[o]}; }`);return r.push("	}"),r.join(`
`)},Ql=e=>X({axis:e.attributes.getInt("axis")}),Wa=e=>{if(!e||e.length<1)throw new Error("too few inputs");let r=e[0].type,o=e[0].dims.length;if(r==="string")throw new Error("string tensor is not supported yet");for(let s of e){if(s.type!==r)throw new Error("input tensors should be one type");if(s.dims.length!==o)throw new Error("input tensors should have the same shape")}}});function Bf(){return Fe("abs")}function Vf(){return Fe("acos")}function Mf(){return Fe("asin")}function zf(){return Fe("atan")}function Uf(){return Fe("ceil")}function Gf(){return Fe("cos")}function Hf(e){let r="elu";return{body:`
  const float alpha = float(${e});

  float ${r}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function qf(){return Fe("exp")}function Wf(){return Fe("floor")}function ep(e,r){let o="clip";return{body:`
  const float min = float(${e});
  const float max = float(${r});

  float ${o}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${o}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:o,type:0}}function Xf(){let e="indentity";return{body:`
  float ${e}_(float a) {
    return a;
  }
  vec4 ${e}_(vec4 v) {
    return v;
  }
  `,name:e,type:0}}function Kf(e){let r="leakyRelu";return{body:`
  const float alpha = float(${e});

  float ${r}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function Zf(){return Fe("log")}function Jf(){let e="neg";return{body:`
  float ${e}_(float a) {
    return -a;
  }
  vec4 ${e}_(vec4 v) {
    return -v;
  }
  `,name:e,type:0}}function Yf(){let e="not";return{body:`
  float ${e}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e}_(bool a) {
    return !a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:e,type:0}}function Qf(){return Fe("sin")}function tp(){let e="relu";return{body:`
  float ${e}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:e,type:0}}function rp(){let e="sigmoid";return{body:`
  float ${e}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:e,type:0}}function eg(){return Fe("sqrt")}function tg(){return Fe("tan")}function rg(){let e="tanh";return{body:`
  float ${e}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:e,type:0}}function Fe(e){return{body:`
  float ${e}_(float a) {
    return ${e}(a);
  }
  vec4 ${e}_(vec4 v) {
    return ${e}(v);
  }
  `,name:e,type:0}}var Xa,Q,np,op,ip,ap,So,sp,up,Ka,lp,pp,cp,dp,hp,fp,Oo,gp,mp,bp,yp,wp,vp,xp,Tp,_p,Sp,Op,Ep=I(()=>{"use strict";le(),U(),nt(),Y(),V(),Xa=(e,r,o,s)=>{let p=e.session.pack?2:0,l=B(e.session.backend.glContext.version);return{...r,output:{dims:o.dims,type:o.type,textureType:p},shaderSource:`
     ${s.body}
     void main() {
       vec4 v = ${l.texture2D}(A, TexCoords);
       v = ${s.name}_(v);
       ${l.output} = v;
     }
     `,hasMain:!0}},Q=(e,r,o,s)=>{let p=e.session.pack?2:0,l={name:o.name,inputTypes:[p],inputNames:["A"],cacheHint:s};return{...l,get:()=>Xa(e,l,r,o)}},np=(e,r)=>[e.run(Q(e,r[0],Bf()),r)],op=(e,r)=>[e.run(Q(e,r[0],Vf()),r)],ip=(e,r)=>[e.run(Q(e,r[0],Mf()),r)],ap=(e,r)=>[e.run(Q(e,r[0],zf()),r)],So=(e,r,o)=>[e.run(Q(e,r[0],ep(o.min,o.max),o.cacheKey),r)],sp=e=>X({min:e.attributes.getFloat("min",hr),max:e.attributes.getFloat("max",fr)}),up=(e,r)=>{let o=Ka(e,r);return So(e,[r[0]],o)},Ka=(e,r)=>{if(r.length>=3&&(!e.session.isInitializer(r[1].dataId)||!e.session.isInitializer(r[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let o=r.length>=3?r[1].numberData[0]:hr,s=r.length>=3?r[2].numberData[0]:fr;return X({min:o,max:s})},lp=(e,r)=>[e.run(Q(e,r[0],Uf()),r)],pp=(e,r)=>[e.run(Q(e,r[0],Gf()),r)],cp=(e,r,o)=>[e.run(Q(e,r[0],Hf(o.alpha),o.cacheKey),r)],dp=e=>X({alpha:e.attributes.getFloat("alpha",1)}),hp=(e,r)=>[e.run(Q(e,r[0],qf()),r)],fp=(e,r)=>[e.run(Q(e,r[0],Wf()),r)],Oo=(e,r)=>[e.run(Q(e,r[0],Xf()),r)],gp=(e,r,o)=>[e.run(Q(e,r[0],Kf(o.alpha),o.cacheKey),r)],mp=e=>X({alpha:e.attributes.getFloat("alpha",.01)}),bp=(e,r)=>[e.run(Q(e,r[0],Zf()),r)],yp=(e,r)=>[e.run(Q(e,r[0],Jf()),r)],wp=(e,r)=>[e.run(Q(e,r[0],Yf()),r)],vp=(e,r)=>[e.run(Q(e,r[0],tp()),r)],xp=(e,r)=>[e.run(Q(e,r[0],rp()),r)],Tp=(e,r)=>[e.run(Q(e,r[0],Qf()),r)],_p=(e,r)=>[e.run(Q(e,r[0],eg()),r)],Sp=(e,r)=>[e.run(Q(e,r[0],tg()),r)],Op=(e,r)=>[e.run(Q(e,r[0],rg()),r)]});function wr(e){let r;switch(e.activation){case"Relu":r=tp();break;case"Sigmoid":r=rp();break;case"Clip":r=ep(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let o=r.name,s=r.body,p=`value = ${o}_(value);`;return{activationFunction:s,applyActivation:p}}var en,Ft=I(()=>{"use strict";U(),Ep(),en=e=>{let r=e.getString("activation","");if(r==="Clip"){let[o,s]=e.getFloats("activation_params",[hr,fr]);return{activation:r,clipMax:s,clipMin:o,activationCacheKey:`${r}:${o},${s}`}}return{activation:r,activationCacheKey:r}}}),Za,Ja,Ip,ng=I(()=>{"use strict";Re(),Y(),V(),Qo(),Ft(),Za=(e,r)=>({name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),Ja=(e,r,o,s)=>{let p=r.length>2?"value += getBias(output_channel);":"",l=r[0].dims.slice(),c=r[1].dims.slice(),n=c[0]/s.group;ee.verbose("GroupedConv",`autpPad:${s.autoPad}, dilations:${s.dilations}, group:${s.group}, kernelShape:${s.kernelShape}, pads:${s.pads}, strides:${s.strides}`);let a=pr(l,c,s.dilations,s.pads,s.strides),t=B(e.session.backend.glContext.version),{activationFunction:u,applyActivation:i}=wr(s),d=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${u}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${n};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${c[1]}; wInChannel++) {
      int input_channel = group_id * ${c[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${c[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${s.dilations[0]};

        if (xHeight < 0 || xHeight >= ${l[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${c[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${s.dilations[1]};
          if (xWidth < 0 || xWidth >= ${l[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${p}
    ${i}
    ${t.output} = vec4(value, .0, .0, .0);
  }
`;return{...o,output:{dims:a,type:r[0].type,textureType:0},shaderSource:d,hasMain:!0}},Ip=(e,r,o)=>{let s=Za(r.length>2,o.cacheKey);return{...s,get:()=>Ja(e,r,s,o)}}}),Ya,Qa,Pp,og=I(()=>{"use strict";Y(),V(),Nt(),Ya=e=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:e}),Qa=(e,r,o,s,p,l)=>{let c=o.dims,n=s.dims,a=2,t=3,u=p.length,i=[n[1]*n[2]*n[3],p[2]*p[3]],d=n[2]*n[3],h=yr(),m=B(e.session.backend.glContext.version),b="";for(let E=0;E<=1;E++)for(let w=0;w<=1;w++)b+=`
            blockIndex = rc.x + ${w};
            pos = rc.y + ${E};

            if(blockIndex < ${i[1]} && pos < ${i[0]}) {
              offsetY = int(blockIndex / (${p[u-1]})) * ${l.strides[0]} -
                ${l.pads[0]};
              d0 = offsetY + ${l.dilations[0]} * (imod(pos, ${d}) / ${n[2]});

              if(d0 < ${c[a]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${p[u-1]}) * ${l.strides[1]} -
                  ${l.pads[1]};
                d1 = offsetX + ${l.dilations[1]} * imod(imod(pos, ${d}), ${n[2]});

                if(d1 < ${c[t]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d}.);
                    innerDims = vec2(d0, d1);
                    result[${E*2+w}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let x=`
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b}
          ${m.output} = result;
      }
            `;return{...r,output:{dims:i,type:o.type,textureType:2},shaderSource:x,hasMain:!0}},Pp=(e,r,o,s,p)=>{let l=Ya(p.cacheKey);return{...l,get:()=>Qa(e,l,r,o,s,p)}}});function ig(e,r,o){let s=r[0].dims,p=r[1].dims,l=Me.calcShape(s,p,!0);if(!l)throw new Error("Can't use matmul on the given tensors");let c=rt(l.length),n=$t(),{activationFunction:a,applyActivation:t}=wr(o),u=r.length>2,i=u?"value += getBiasForMatmul();":"",d=u?`${$p(c,n,r[2].dims,l,!1)}`:"",h=l.length,m=s.length,b=p.length,x=s[s.length-1],E=`
    ${a}
    ${d}
    float process(int indices[${h}]) {
        int a[${m}];
        int b[${b}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${x}; ++k) {
            a[${m-1}] = k;
            b[${b-2}] = k;
            value += _A(a) * _B(b);
        }
        ${i}
        ${t}
        return value;
    }`;return{...e,output:{dims:l,type:r[0].type,textureType:0},shaderSource:E}}function Ap(e,r){let o=kp(e.length>2,r.activationCacheKey);return{...o,get:()=>ig(o,e,r)}}function $p(e,r,o,s,p){let l="",c=o.length,n=s.length,a=n-c;n<2&&c>0?l="coords":l=o.map((d,h)=>`coords.${r[h+a]}`).join(", ");let t=Me.getBroadcastDims(o,s).map(d=>`coords.${r[d+a]} = 0;`).join(`
`),u=C.size(o)===1,i="vec4(outputValue.xx, outputValue.yy)";return u&&(i="vec4(outputValue.x)"),p?`
vec4 getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${t}
  vec4 outputValue = getBias(${l});
  return ${i};
}`:`
float getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${t}
  return getBias(coords.x);
}`}var Dp,Np,kp,es,Jo=I(()=>{"use strict";U(),V(),qe(),Ft(),Fp(),Dp=(e,r,o)=>(es(r),e.session.pack?[e.run(Yo(e,r,o),r)]:[e.run(Ap(r,o),r)]),Np=e=>en(e.attributes),kp=(e,r)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),es=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64")throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")}});function ag(e,r,o,s){let p=[],l=[],c=o[0].dims,n=o[1].dims,a=c.length,t=n.length,u=s.length,i=u-a,d=u-t;p=c.map((w,S)=>`coords.${r[S+i]}`),p[a-1]="i*2",p.join(", "),l=n.map((w,S)=>`coords.${r[S+d]}`),l[t-2]="i*2",l.join(", ");let h=Me.getBroadcastDims(c,s),m=Me.getBroadcastDims(n,s),b=h.map(w=>`coords.${r[w+i]} = 0;`).join(`
`),x=m.map(w=>`coords.${r[w+d]} = 0;`).join(`
`),E=`int lastDim = coords.${r[u-1]};
  coords.${r[u-1]} = coords.${r[u-2]};
  coords.${r[u-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${E}
  ${b}
  vec4 outputValue = getA(${p});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${E}
  ${x}
  vec4 outputValue = getB(${l});
  return outputValue;
}`}function sg(e,r){let o="";for(let s=0;s<r-2;s++)o+=`rc.${e[s]}, `;return o+=`rc.${e[r-2]}, i*2`,o}function ug(e,r){let o="";for(let s=0;s<r-2;s++)o+=`rc.${e[s]}, `;return o+=`i*2, rc.${e[r-1]}`,o}var ts,rs,Yo,Fp=I(()=>{"use strict";U(),Y(),V(),qe(),Ft(),Jo(),ts=(e,r)=>({name:"MatMul (packed)",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[2,2,2]:[2,2],cacheHint:r}),rs=(e,r,o,s)=>{let p=o.length>2,l=p?"value += getBiasForMatmul();":"",c=o[0].dims,n=o[1].dims,a=Me.calcShape(c,n,!0),t=!C.areEqual(o[0].dims,o[1].dims);if(!a)throw new Error("Can't use matmul on the given tensors");let u=c[c.length-1],i=Math.ceil(u/2),d=c.length,h=n.length,m=B(e.session.backend.glContext.version),b=rt(a.length),x=a.length,E=$t(),{activationFunction:w,applyActivation:S}=wr(s),$=p?`${$p(b,E,o[2].dims,a,!0)}`:"",F=t?`${ag(b,E,o,a)}`:"",be=t?"getAAtOutCoordsMatmul(i)":`getA(${sg(E,d)})`,pe=t?"getBAtOutCoordsMatmul(i)":`getB(${ug(E,h)})`,Z=t?"":`${b} rc =
          getOutputCoords(); int lastDim = rc.${E[x-1]}; rc.${E[x-1]} =
          rc.${E[x-2]}; rc.${E[x-2]} = lastDim;
      `,Rt=`
            ${F}
            ${$}
            ${w}
            void main() {
              ${Z}

              vec4 value = vec4(0);
              for (int i = 0; i < ${i}; i++) {
                vec4 a = ${be};
                vec4 b = ${pe};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${l}
              ${S}
              ${m.output} = value;
            }`;return{...r,output:{dims:a,type:o[0].type,textureType:2},shaderSource:Rt,hasMain:!0}},Yo=(e,r,o)=>{let s=ts(r.length>2,o.activationCacheKey);return{...s,get:()=>rs(e,s,r,o)}}}),Cp,lg=I(()=>{"use strict";Qo(),og(),Fp(),Cp=(e,r,o)=>{let s=r[0].dims,p=r[1].dims,l=pr(s,p,o.dilations,o.pads,o.strides),c=e.run(Pp(e,r[0],r[1],l,o),[r[0]]),n=e.reshapePacked(r[1],[p[0],p[1]*p[2]*p[3]]),a=r.length===3?[n,c,r[2]]:[n,c],t=e.run(Yo(e,a,o),a);return e.reshapePacked(t,l)}}),ns,os,Lp,Eo,Rp=I(()=>{"use strict";V(),ns=e=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:e}),os=(e,r,o,s,p,l)=>{let c=o.dims,n=s.dims,a=p.length,t=Eo(c,n,p,4),u=`
        const int XC = ${c[1]};
        const int XH = ${c[2]};
        const int XW = ${c[3]};
        const int KH = ${l.kernelShape[0]};
        const int KW = ${l.kernelShape[1]};
        const int dilationH = ${l.dilations[0]};
        const int dilationW = ${l.dilations[1]};
        const int strideH = ${l.strides[0]};
        const int strideW = ${l.strides[1]};
        const int padH = ${l.pads[0]};
        const int padW = ${l.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${a}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${c.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...r,output:{dims:t,type:o.type,textureType:4},shaderSource:u}},Lp=(e,r,o,s,p)=>{let l=ns(p.cacheKey);return{...l,get:()=>os(e,l,r,o,s,p)}},Eo=(e,r,o,s=4)=>[o[0],o[2],o[3],Math.ceil(e[1]*r[2]*r[3]/s)]}),is,as,jp,pg=I(()=>{"use strict";U(),Y(),V(),Ft(),Rp(),is=(e,r)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[0,4,0]:[0,4],cacheKey:r.activationCacheKey}),as=(e,r,o,s,p)=>{let l=o[0].dims,c=o[1].dims,n=[c[0],Math.ceil(l[1]*c[2]*c[3]/4)],a=Eo(l,c,s),[t,u]=e.calculateTextureWidthAndHeight(n,4),i=C.computeStrides(a),[d,h]=e.calculateTextureWidthAndHeight(a,4),m=s.length,b=o.length<3?"0.0":"_B(b)",x=Math.ceil(l[1]*c[2]*c[3]/4),{activationFunction:E,applyActivation:w}=wr(p),S=B(e.session.backend.glContext.version),$=`
${E}
float process(int indices[${m}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${i[0]} + im2col[1] * ${i[1]} + im2col[2] * ${i[2]};
  int kernelOffset = indices[1] * ${n[1]};
  float value = ${b};
  for (int i = 0; i < ${x}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d}, ${h});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${t}, ${u});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${w}
  return value;
}`;return{...r,output:{dims:s,type:o[0].type,textureType:0},shaderSource:$}},jp=(e,r,o,s)=>{let p=is(r.length>2,s);return{...p,get:()=>as(e,p,r,o,s)}}}),pr,Io,ss,us,ls,ps,Po,cs,Qo=I(()=>{"use strict";le(),U(),ng(),lg(),pg(),Ft(),Rp(),Jo(),pr=(e,r,o,s,p)=>{let l=e[0],c=e.slice(2),n=c.length,a=r[0],t=r.slice(2).map((i,d)=>i+(i-1)*(o[d]-1)),u=c.map((i,d)=>i+s[d]+s[d+n]).map((i,d)=>Math.floor((i-t[d]+p[d])/p[d]));return[l,a].concat(...u)},Io=(e,r,o)=>(cs(r,o),ss(e,r,o)),ss=(e,r,o)=>{let s=ps(o,r),p=e.session.pack,l=s.kernelShape[0]===1&&s.kernelShape[1]===1;return s.group>1?[e.run(Ip(e,r,s),r)]:l&&p?[us(e,r,s)]:p&&r[0].dims.length===4&&r[0].dims[0]===1&&!l?[Cp(e,r,s)]:[ls(e,r,s)]},us=(e,r,o)=>{let s=r[0].dims,p=r[1].dims,l=pr(s,p,o.dilations,o.pads,o.strides),c=e.reshapeUnpacked(r[0],[s[1],s[2]*s[3]]),n=e.reshapeUnpacked(r[1],[p[0],p[1]]),a=r.length>2?[n,c,r[2]]:[n,c],t=e.run(Ap(a,o),a);return e.reshapeUnpacked(t,l)},ls=(e,r,o)=>{let s=r[0].dims,p=r[1].dims,l=pr(s,p,o.dilations,o.pads,o.strides),c=e.run(Lp(e,r[0],r[1],l,o),[r[0]]),n=r.length===3?[c,r[1],r[2]]:[c,r[1]];return e.run(jp(e,r,l,o),n)},ps=(e,r)=>{let o=e.kernelShape.slice();if(e.kernelShape.length===0)for(let l=2;l<r[1].dims.length;++l)o.push(r[1].dims[l]);let s=e.pads.slice();qr.adjustPadsBasedOnAutoPad(r[0].dims,e.strides,e.dilations,o,s,e.autoPad);let p=Object.assign({},e);return Object.assign(p,{kernelShape:o,pads:s,cacheKey:e.cacheKey}),p},Po=e=>{let r=e.attributes,o=en(r),s=r.getString("auto_pad","NOTSET"),p=r.getInts("dilations",[1,1]),l=r.getInt("group",1),c=r.getInts("kernel_shape",[]),n=r.getInts("pads",[0,0,0,0]),a=r.getInts("strides",[1,1]);return X({autoPad:s,dilations:p,group:l,kernelShape:c,pads:n,strides:a,...o})},cs=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let o=e[0].dims[1],s=e[1].dims[1]*r.group;if(o!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let p=e[0].dims.length-2;if(r.dilations.length!==p)throw new Error(`dilations should be ${p}D`);if(r.strides.length!==p)throw new Error(`strides should be ${p}D`);if(r.pads.length!==p*2)throw new Error(`pads should be ${p*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),ds,hs,fs,Bp,gs,ms,bs,ys,ws,vs,Vp,xs,cg=I(()=>{"use strict";le(),Y(),V(),Ft(),ds=(e,r,o,s,p,l)=>(e-1)*r+o+(s-1)*p+1-l,hs=(e,r,o,s,p)=>{let l=Math.floor(e/2);r==="SAME_UPPER"?(o[s]=l,o[p]=e-l):r==="SAME_LOWER"&&(o[s]=e-l,o[p]=l)},fs=(e,r,o,s,p,l,c,n)=>{let a=e.length-2,t=n.length===0;for(let u=0;u<a;++u){let i=t?e[u+2]*l[u]:n[u],d=ds(e[u+2],l[u],p[u],r[u],o[u],i);hs(d,s,p,u,u+a),t&&n.push(l[u]*(e[u+2]-1)+c[u]+(r[u]-1)*o[u]+1-p[u]-p[u+a])}},Bp=(e,r,o)=>(xs(r,o),gs(e,r,o)),gs=(e,r,o)=>{let s=vs(o,r);return[ws(e,r,s)]},ms=(e,r)=>({name:"ConvTranspose",inputNames:e?["X","W","B"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),bs=(e,r,o,s)=>{let p=r.length>2?"getB(output_channel)":"0.0",l=r[0].dims,c=r[1].dims,n=c[1],a=c[0]/s.group,t=[r[0].dims[0],r[1].dims[1]*s.group,...s.outputShape],u=B(e.session.backend.glContext.version),{activationFunction:i,applyActivation:d}=wr(s),h=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${i}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${n};
    int wOutChannel = output_channel - group_id * ${n};

    float value = ${p};
    for (int inChannelOffset = 0; inChannelOffset < ${a}; inChannelOffset++) {
      int input_channel = group_id * ${a} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${c[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${c[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${s.dilations[0]}, wHOff * ${s.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${l[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${l[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${d}
    ${u.output} = vec4(value, .0, .0, .0);
  }
`;return{...o,output:{dims:t,type:r[0].type,textureType:0},shaderSource:h,hasMain:!0}},ys=(e,r,o)=>{let s=ms(r.length>2,o.cacheKey);return{...s,get:()=>bs(e,r,s,o)}},ws=(e,r,o)=>e.run(ys(e,r,o),r),vs=(e,r)=>{let o=e.kernelShape.slice();if(e.kernelShape.length===0)for(let n=2;n<r[1].dims.length;++n)o.push(r[1].dims[n]);let s=e.pads.slice(),p=e.outputShape.slice(),l=r[0].dims;fs(l,o,e.dilations,e.autoPad,s,e.strides,e.outputPadding,p);let c=Object.assign({},e);return Object.assign(c,{kernelShape:o,pads:s,outputShape:p,cacheKey:e.cacheKey}),c},Vp=e=>{let r=e.attributes,o=en(r),s=r.getString("auto_pad","NOTSET"),p=r.getInts("dilations",[1,1]),l=r.getInt("group",1),c=r.getInts("kernel_shape",[]),n=r.getInts("output_padding",[0,0]),a=r.getInts("output_shape",[]),t=r.getInts("pads",[0,0,0,0]),u=r.getInts("strides",[1,1]);return X({autoPad:s,dilations:p,group:l,kernelShape:c,outputPadding:n,outputShape:a,pads:t,strides:u,...o})},xs=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let o=e[0].dims[1],s=e[1].dims[0];if(o!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let p=e[1].dims[1]*r.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==p))throw new Error("invalid bias");let l=e[0].dims.length-2;if(r.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(r.strides.length!==l)throw new Error(`strides should be ${l}D`);if(r.pads.length!==l*2)throw new Error(`pads should be ${l*2}D`);if(r.outputPadding.length!==l)throw new Error(`output_padding should be ${l}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),Nn,gr,Mp,Ts,kn,_s,Ss,Os,ei=I(()=>{"use strict";le(),U(),V(),Nn={name:"Transpose",inputNames:["A"],inputTypes:[0]},gr=(e,r,o)=>(Os(r),[e.run({...Nn,cacheHint:o.cacheKey,get:()=>Ts(e,r[0],o.perm)},r)]),Mp=e=>X({perm:e.attributes.getInts("perm",[])}),Ts=(e,r,o)=>{let s=r.dims;o=kn(s,o);let p=_s(s,o),l=s.length,c=`
      ${Ss("perm",o,l)}
      float process(int indices[${l}]) {
        int a[${l}];
        perm(a, indices);
        return _A(a);
      }`;return{...Nn,output:{dims:p,type:r.type,textureType:0},shaderSource:c}},kn=(e,r)=>(r&&r.length!==e.length&&(r=[...e.keys()].reverse()),r),_s=(e,r)=>(r=kn(e,r),C.sortBasedOnPerm(e,r)),Ss=(e,r,o)=>{let s=[];s.push(`void ${e}(out int a[${o}], int src[${o}]) {`);for(let p=0;p<o;++p)s.push(`	a[${r[p]}]=src[${p}];`);return s.push("	}"),s.join(`
`)},Os=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}}),zp,Up,Es,dg=I(()=>{"use strict";ei(),zp=(e,r,o)=>{Es(r);let s=o.blocksize,p=s*s,l=o.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],c=o.mode==="DCR"?[r[0].dims[0],s,s,r[0].dims[1]/p,r[0].dims[2],r[0].dims[3]]:[r[0].dims[0],r[0].dims[1]/p,s,s,r[0].dims[2],r[0].dims[3]],n=e.reshapeUnpacked(r[0],c),a={perm:l,cacheKey:`${l}`},[t]=gr(e,[n],a),u=[r[0].dims[0],r[0].dims[1]/p,r[0].dims[2]*s,r[0].dims[3]*s];return[e.reshapeUnpacked(t,u)]},Up=e=>{let r=e.attributes.getInt("blocksize");if(r<1)throw new Error(`blocksize must be >= 1, but got : ${r} for DepthToSpace`);let o=e.attributes.getString("mode","DCR");if(o!=="DCR"&&o!=="CRD")throw new Error(`unrecognized mode: ${o} for DepthToSpace`);return{mode:o,blocksize:r}},Es=e=>{if(e.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if(e[0].type==="string"||e[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),Gp,Hp,Is,hg=I(()=>{"use strict";U(),Gp=(e,r,o)=>{Is(r,o);let s=C.flattenShape(r[0].dims,o);return[e.reshapeUnpacked(r[0],s)]},Hp=e=>e.attributes.getInt("axis",1),Is=(e,r)=>{if(!e||e.length!==1)throw new Error("Flatten requires 1 input.");let o=e[0].dims.length;if(o===0)throw new Error("scalar tensor is not supported.");if(r<-o||r>o)throw new Error("Invalid axis");if(e[0].type==="string")throw new Error("string tensor is not supported.")}}),vr,tn=I(()=>{"use strict";vr=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),qp,Wp,Ps,As,$s,Ds,fg=I(()=>{"use strict";le(),tn(),U(),V(),qp=(e,r,o)=>(Ds(r,o.axis),[e.run($s(e,r,o),r)]),Wp=e=>X({axis:e.attributes.getInt("axis",0)}),Ps={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},As=(e,r,o,s)=>{let p=o[0].dims.slice(),l=o[1].dims.slice(),c=new Array(p.length+l.length-1);s=C.normalizeAxis(s,p.length);let n=[];for(let d=0;d<c.length;d++)d<s?(c[d]=p[d],n.push(`inputIdx[${d}] = outputIdx[${d}];`)):d<s+l.length?(c[d]=l[d-s],n.push(`indexDataIdx[${d-s}] = outputIdx[${d}];`)):(c[d]=p[d-l.length+1],n.push(`inputIdx[${d-l.length+1}] = outputIdx[${d}];`));let a=c.length||1,t=p.length,u=l.length||1,i=`
      float process(int outputIdx[${a}]) {
        int inputIdx[${t}];
        int indexDataIdx[${u}];
        indexDataIdx[0] = 0;
        ${n.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${s}] = idx < 0 ? idx + ${p[s]} : idx;
        return _A(inputIdx);
      }`;return{...r,output:{dims:c,type:o[0].type,textureType:0},shaderSource:i}},$s=(e,r,o)=>{let s={...Ps,cacheHint:o.cacheKey};return{...s,get:()=>As(e,s,r,o.axis)}},Ds=(e,r)=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.");let o=e[0].dims.length;if(o<1)throw new Error("Invalid input shape.");if(r<-o||r>o-1)throw new Error("Invalid axis.");if(vr.indexOf(e[0].type)===-1)throw new Error("Invaid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invaid input type.")}}),Ao,Fn,Xp,Kp,Ns,ks,Fs,gg=I(()=>{"use strict";le(),U(),V(),Ao=(e,r,o)=>(Fs(r,o),[e.run(Ns(r,o),r)]),Fn=(e,r)=>{let o=e.attributes.getInt("transA",0)!==0,s=e.attributes.getInt("transB",0)!==0,p=e.attributes.getFloat("alpha",1),l=e.attributes.getFloat("beta",1);return X({transA:o,transB:s,alpha:p,beta:l,isOptionalC:r})},Xp=e=>Fn(e,!1),Kp=e=>Fn(e,!0),Ns=(e,r)=>{let o={name:"Gemm",inputNames:e.length===3?["A","B","C"]:["A","B"],inputTypes:e.length===3?[0,0,0]:[0,0],key:r.cacheKey};return{...o,get:()=>ks(o,e,r)}},ks=(e,r,o)=>{let s=r[0].dims.slice(),p=r[1].dims.slice(),[l,c]=xl.getShapeOfGemmResult(s,o.transA,p,o.transB,r.length===3?r[2].dims:void 0),n=[l,c];if(!n)throw new Error("Can't use gemm on the given tensors");let a=s[s.length-1],t="";o.transA&&(a=s[0]),o.transA&&o.transB?t="value += _A_T(a) * _B_T(b);":o.transA&&!o.transB?t="value += _A_T(a) * _B(b);":!o.transA&&o.transB?t="value += _A(a) * _B_T(b);":!o.transA&&!o.transB&&(t="value += _A(a) * _B(b);");let u=n.length,i=r.length===3?`int c[${r[2].dims.length}];`:"",d=r.length===3?"bcastIndices_C(indices, c);":"",h=r.length===3?"value += beta * _C(c);":"",m=`
      float process(int indices[${u}]) {
          int a[${u}];
          int b[${u}];
          ${i}

          copyVec(indices, a);
          copyVec(indices, b);
          ${d}

          float value = 0.0;
          for (int k=0; k<${a}; ++k) {
              a[${u-1}] = k;
              b[${u-2}] = k;
              ${t}
          }

          value = value * alpha;
          ${h}
          return value;
      }`;return{...e,output:{dims:n,type:r[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:o.alpha},{name:"beta",type:"float",data:o.beta}],shaderSource:m}},Fs=(e,r)=>{if(!e)throw new Error("Input is missing");if(r.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!r.isOptionalC&&e.length!==3)throw new Error("Gemm requires 3 inputs");if(e.length===3&&e[2].dims.length!==1&&e[2].dims.length!==2)throw new Error("Invalid input shape of C");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64"||e.length===3&&e[2].type!=="float32"&&e[2].type!=="float64")throw new Error("Invalid input type.");if(e[0].type!==e[1].type||e.length===3&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}}),Zp,Jp,Cs,Ls,Rs,js,Bs,mg=I(()=>{"use strict";le(),V(),Zp=(e,r,o)=>(Bs(r),[e.run(Rs(e,r,o),r)]),Jp=e=>{let r=e.attributes.getFloat("scale"),o=e.attributes.getFloats("bias");return X({scale:r,bias:o})},Cs={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},Ls=(e,r,o,s)=>{let p=o[0].dims.slice(),l=p.length,c=`
      ${js(s.bias.length)}
      float process(int indices[${l}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...r,output:{dims:p,type:o[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:s.bias.length,data:s.bias},{name:"scale",type:"float",data:s.scale}],shaderSource:c}},Rs=(e,r,o)=>{let s={...Cs,cacheHint:o.cacheKey};return{...s,get:()=>Ls(e,s,r,o)}},js=e=>{let r=[`float getBias(float bias[${e}], int channel) {`];for(let o=0;o<e;++o)o===0?r.push(`	if (channel == ${o}) { return bias[${o}]; }`):o===e-1?r.push(`	else { return bias[${o}]; }`):r.push(`	else if (channel == ${o}) { return bias[${o}]; }`);return r.push("	}"),r.join(`
`)},Bs=e=>{if(!e||e.length!==1)throw new Error("ImageScaler requires 1 input.");if(e[0].dims.length!==4)throw new Error("Invalid input shape.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")}}),Yp,Qp,Cn,Vs,Ms,zs,Us,Gs,Hs,bg=I(()=>{"use strict";Y(),V(),Yp=(e,r,o)=>{Hs(r);let s=e.run(Ms(r[0]),r);return[e.run(Gs(e,r[0],o,s.dims),[r[0],s,r[1],r[2]])]},Qp=e=>e.attributes.getFloat("epsilon",1e-5),Cn={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},Vs=(e,r)=>{let o=r.dims.slice(),s=o[1],p=o[2]*o[3],l=[o[0],s],c=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${o[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${p});
        temp = 0.0;
        for(int a2=0; a2<${o[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${p});

        return v;
      }`;return{...e,output:{dims:l,type:r.type,textureType:4},shaderSource:c}},Ms=e=>({...Cn,get:()=>Vs(Cn,e)}),zs={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},Us=(e,r,o,s,p)=>{let l=B(e.session.backend.glContext.version),[c,n]=e.calculateTextureWidthAndHeight(p,4),[a,t]=[c/4,n],u=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${a}, ${t});
        return ${l.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...r,output:{dims:o.dims,type:o.type,textureType:0},variables:[{name:"epsilon",type:"float",data:s}],shaderSource:u}},Gs=(e,r,o,s)=>{let p={...zs,cacheHint:`${o}`};return{...p,get:()=>Us(e,p,r,o,s)}},Hs=e=>{if(!e||e.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let r=e[0],o=e[1],s=e[2];if(r.dims.length<3||o.dims.length!==1||s.dims.length!==1)throw new Error("Invalid input shape.");if(o.dims[0]!==r.dims[1]||s.dims[0]!==r.dims[1])throw new Error("Input shapes are mismatched.");if(r.type!=="float32"&&r.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||s.type!=="float32"&&s.type!=="float64")throw new Error("Invalid input type.");if(e[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function yg(e,r){let o=e[0].dims[1],s=e[0].dims.length,p=-Math.floor((r.size-1)/2),l=Math.ceil((r.size-1)/2),c=`float(${r.alpha}) / float(${r.size})`,n=`float(${r.bias})`,a=`float(${r.beta})`,t=`
    float process(int indices[${s}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${p}; i <= ${l}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${o}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${n} + ${c} * square_sum, ${a});
    }`;return{...ti,cacheHint:r.cacheKey,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:t}}function wg(e,r){return{...ti,cacheHint:r.cacheKey,get:()=>yg(e,r)}}var ec,tc,ti,qs,vg=I(()=>{"use strict";le(),V(),ec=(e,r,o)=>(qs(r),[e.run(wg(r,o),r)]),tc=e=>{let r=e.attributes.getFloat("alpha",1e-4),o=e.attributes.getFloat("beta",.75),s=e.attributes.getFloat("bias",1),p=e.attributes.getInt("size");return X({alpha:r,beta:o,bias:s,size:p})},ti={name:"LRN",inputNames:["X"],inputTypes:[0]},qs=e=>{if(!e||e.length!==1)throw new Error("LRN requires 1 input.");if(e[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(e[0].type!=="float32")throw new Error("input should be float type")}}),Ws,$o,rc,nc,oc,Xs,Ks,Zs,Js,Ys,Qs,eu,tu,xg=I(()=>{"use strict";le(),U(),Y(),V(),Ws={name:"Pad",inputNames:["A"],inputTypes:[0]},$o=(e,r,o)=>(Zs(r),[e.run({...Ws,cacheHint:o.cacheKey,get:()=>Ks(e,r[0],o)},r)]),rc=e=>{let r=e.attributes.getString("mode","constant"),o=e.attributes.getFloat("value",0),s=e.attributes.getInts("pads");return X({mode:r,value:o,pads:s})},nc=(e,r,o)=>{Js(r);let s=Xs(e,r,o);return $o(e,[r[0]],s)},oc=e=>e.attributes.getString("mode","constant"),Xs=(e,r,o)=>{if(!e.session.isInitializer(r[1].dataId)||r.length>=3&&!e.session.isInitializer(r[2].dataId))throw new Error("dynamic pad attributes are not allowed");let s=Array.from(r[1].integerData),p=r.length>=3?r[2].floatData[0]:0;return X({mode:o,pads:s,value:p})},Ks=(e,r,o)=>{let s=C.padShape(r.dims.slice(),o.pads),p=s.length,l=`
      ${Ys(e,r,o)}
      float process(int[${p}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:s,type:r.type,textureType:0},shaderSource:l}},Zs=e=>{if(!e||e.length!==1)throw new Error("Pad requires 1 input");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},Js=e=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(e[1].type!=="int32")throw new Error("Invalid input type.");if(e.length>=3&&e[2].type==="string")throw new Error("Invalid input type.")},Ys=(e,r,o)=>{let s=B(e.session.backend.glContext.version),[p,l]=e.calculateTextureWidthAndHeight(r.dims,0),c=C.computeStrides(r.dims);switch(o.mode){case"constant":return Qs(s,r.dims,c,p,l,o.pads,o.value);case"reflect":return eu(s,r.dims,c,p,l,o.pads);case"edge":return tu(s,r.dims,c,p,l,o.pads);default:throw new Error("Invalid mode")}},Qs=(e,r,o,s,p,l,c)=>{let n=r.length,a="";for(let t=n-1;t>=0;--t)a+=`
        k = m[${t}] - ${l[t]};
        if (k < 0)  return constant;
        if (k >= ${r[t]}) return constant;
        offset += k * ${o[t]};
        `;return`
      float padA(int m[${n}]) {
        const float constant = float(${c});
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${s}, ${p});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},eu=(e,r,o,s,p,l)=>{let c=r.length,n="";for(let a=c-1;a>=0;--a)n+=`
        k = m[${a}] - ${l[a]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(r[a]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${r[a]}) { k = _2n_1 - k; }
        }
        offset += k * ${o[a]};
        `;return`
      float padA(int m[${c}]) {
        int offset = 0;
        int k = 0;
        ${n}
        vec2 coords = offsetToCoords(offset, ${s}, ${p});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},tu=(e,r,o,s,p,l)=>{let c=r.length,n="";for(let a=c-1;a>=0;--a)n+=`
        k = m[${a}] - ${l[a]};
        if (k < 0)  k = 0;
        if (k >= ${r[a]}) k = ${r[a]-1};
        offset += k * ${o[a]};
      `;return`
      float padA(int m[${c}]) {
        int offset = 0;
        int k = 0;
        ${n}
        vec2 coords = offsetToCoords(offset, ${s}, ${p});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `}}),ic,ac,Ln,sc,uc,lc,pc,Rn,jn,ru,Bn,cc,Wt,Vn,Xt,nu,Tg=I(()=>{"use strict";le(),U(),V(),ic=(e,r,o)=>{Wt(r);let s={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:o.cacheKey};return[e.run({...s,get:()=>Ln(r,s,!1,o)},r)]},ac=e=>{let r=e.attributes.getString("auto_pad","NOTSET"),o=e.attributes.getInt("ceil_mode",0),s=e.attributes.getInt("count_include_pad",0)!==0,p=e.attributes.getInts("kernel_shape"),l=e.attributes.getInts("strides",[]),c=e.attributes.getInts("pads",[]);if(o!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return X({autoPad:r,ceilMode:o,countIncludePad:s,kernelShape:p,strides:l,pads:c})},Ln=(e,r,o,s)=>{let[p,l]=jn(e,s,o),c=C.size(p.kernelShape),n="value += _X(x);",a="";p.countIncludePad?a+=`value /= float(${c});`:a+=`value /= float(${c} - pad);`;let t=`
        ${Vn(e[0].dims,p,n,a,"0.0")}
      `;return{...r,output:{dims:l,type:e[0].type,textureType:0},shaderSource:t}},sc=(e,r,o)=>{Wt(r);let s={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${o.countIncludePad}`};return[e.run({...s,get:()=>Ln(r,s,!0,o)},r)]},uc=e=>{let r=e.attributes.getInt("count_include_pad",0)!==0;return X({autoPad:"",ceilMode:0,countIncludePad:r,kernelShape:[],strides:[],pads:[]})},lc=(e,r,o)=>{Wt(r);let s={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:o.cacheKey};return[e.run({...s,get:()=>Rn(r,s,!1,o)},r)]},pc=e=>{let r=e.attributes.getString("auto_pad","NOTSET"),o=e.attributes.getInt("ceil_mode",0),s=e.attributes.getInts("kernel_shape"),p=e.attributes.getInts("strides",[]),l=e.attributes.getInts("pads",[]),c=e.attributes.getInt("storage_order",0),n=e.attributes.getInts("dilations",[]);if(c!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return X({autoPad:r,ceilMode:o,countIncludePad:!1,kernelShape:s,strides:p,pads:l,storageOrder:c,dilations:n})},Rn=(e,r,o,s)=>{let[p,l]=jn(e,s,o),c=`
      value = max(_X(x), value);
    `,n="",a=`
      ${Vn(e[0].dims,p,c,n,"-1e5")}
    `;return{...r,output:{dims:l,type:e[0].type,textureType:0},shaderSource:a}},jn=(e,r,o)=>{let s=e[0].dims.slice(),p=Object.hasOwnProperty.call(r,"dilations"),l=r.kernelShape.slice(),c=r.strides.slice(),n=p?r.dilations.slice():[],a=r.pads.slice();qr.adjustPoolAttributes(o,s,l,c,n,a);let t=qr.computePoolOutputShape(o,s,c,n,l,a,r.autoPad),u=Object.assign({},r);return p?Object.assign(u,{kernelShape:l,strides:c,pads:a,dilations:n,cacheKey:r.cacheKey}):Object.assign(u,{kernelShape:l,strides:c,pads:a,cacheKey:r.cacheKey}),[u,t]},ru={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Bn={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},cc=(e,r)=>(Wt(r),[e.run({...Bn,get:()=>Rn(r,Bn,!0,ru)},r)]),Wt=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},Vn=(e,r,o,s,p)=>{let l=e.length;if(r.kernelShape.length<=2){let c=r.kernelShape[r.kernelShape.length-1],n=r.strides[r.strides.length-1],a=r.pads[r.pads.length/2-1],t=r.pads[r.pads.length-1],u=e[l-1],i="",d="",h="";if(a+t!==0?i=`
          for (int i = 0; i < ${c}; i++) {
            x[${l} - 1] = indices[${l} - 1] * ${n} - ${a} + i;
            if (x[${l} - 1] < 0 || x[${l} - 1] >= ${u}) {
              pad++;
              continue;
            }
            ${o}
          }`:i=`
          for (int i = 0; i < ${c}; i++) {
            x[${l} - 1] = indices[${l} - 1] * ${n} - ${a} + i;
            ${o}
          }`,r.kernelShape.length===2){let m=r.kernelShape[r.kernelShape.length-2],b=r.strides[r.strides.length-2],x=r.pads[r.pads.length/2-2],E=r.pads[r.pads.length-2],w=e[l-2];x+E!==0?d=`
            for (int j = 0; j < ${m}; j++) {
              x[${l} - 2] = indices[${l} - 2] * ${b} - ${x} + j;
              if (x[${l} - 2] < 0 || x[${l} - 2] >= ${w}) {
                pad+= ${c};
                continue;
              }
          `:d=`
            for (int j = 0; j < ${m}; j++) {
              x[${l} - 2] = indices[${l} - 2] * ${b} - ${x} + j;
            `,h=`
          }
        `}return`
        float process(int indices[${l}]) {
          int x[${l}];
          copyVec(indices, x);

          float value = ${p};
          int pad = 0;
          ${d}
          ${i}
          ${h}
          ${s}
          return value;
        }
      `}else{let c=C.size(r.kernelShape),n=C.computeStrides(r.kernelShape),a=n.length,t=r.pads.length,u=nu(a),i=Xt(e,"inputDims"),d=Xt(r.pads,"pads"),h=Xt(n,"kernelStrides"),m=Xt(r.strides,"strides"),b=r.pads.reduce((E,w)=>E+w),x="";return b?x=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${o}
          }`:x=`
          }
          ${o}
        `,`
        ${u}
        float process(int indices[${l}]) {
          int x[${l}];
          copyVec(indices, x);
          int offset[${a}];
          int pads[${t}];
          int inputDims[${l}];
          int kernelStrides[${a}];
          int strides[${a}];
          ${d}
          ${i}
          ${m}
          ${h}

          float value = ${p};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${c}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${l} - ${a}; j < ${l}; j++) {
              x[j] = indices[j] * strides[j - ${l} + ${a}]
                + offset[j - ${l} + ${a}] - pads[j - 2];
              ${x}
          }
          ${s}

          return value;
        }
      `}},Xt=(e,r)=>{let o="";for(let s=0;s<e.length;s++)o+=`
      ${r}[${s}] = ${e[s]};
    `;return o},nu=e=>`
  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {
    if (${e} == 0) {
      return;
    }
    for (int i = 0; i < ${e} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e} - 1] = offset;
  }`}),Je,et,ou,iu,dc,hc,fc,gc,mc,bc,yc,_g=I(()=>{"use strict";le(),tn(),U(),V(),Je=(e,r,o,s,p)=>{iu(r);let l={name:s,inputNames:["A"],inputTypes:[0]};return[e.run({...l,cacheHint:o.cacheKey,get:()=>ou(e,r,o,s,p,l)},r)]},et=e=>{let r=e.attributes.getInts("axes",[]),o=e.attributes.getInt("keepdims",1)===1;return X({axes:r,keepDims:o})},ou=(e,r,o,s,p,l)=>{let c=[],n=r[0].dims.length||1,a=[],t=C.normalizeAxes(o.axes,r[0].dims.length),u=p(r,t),i=u[1];for(let h=0;h<r[0].dims.length;h++)t.indexOf(h)>=0||t.length===0?(o.keepDims&&c.push(1),i=`
          for(int j${h} = 0; j${h} < ${r[0].dims[h]}; j${h}++) {
            inputIdx[${h}] = j${h};
            ${i}
          }`):(a.push(`inputIdx[${h}] = outputIdx[${c.length}];`),c.push(r[0].dims[h]));let d=`
      float process(int outputIdx[${c.length||1}]) {
        float value;                 // final result
        int inputIdx[${n}];      // addressing input data
        ${a.join(`
`)}
        ${u[0]}       // init ops for reduce max/min
        ${i}
        ${u[2]}       // final computation for reduce mean
        return value;
      }`;return{...l,output:{dims:c,type:r[0].type,textureType:0},shaderSource:d}},iu=e=>{if(!e||e.length!==1)throw new Error("Reduce op requires 1 input.");if(vr.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},dc=(e,r,o)=>Je(e,r,o,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),hc=(e,r,o)=>Je(e,r,o,"ReduceMean",(s,p)=>{let l=1;for(let c=0;c<s[0].dims.length;c++)(p.indexOf(c)>=0||p.length===0)&&(l*=s[0].dims[c]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${l}.;`]}),fc=(e,r,o)=>Je(e,r,o,"ReduceMax",(s,p)=>{let l=[];for(let c=0;c<s[0].dims.length;c++)(p.indexOf(c)>=0||p.length===0)&&l.push(`inputIdx[${c}] = 0;`);return[`${l.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),gc=(e,r,o)=>Je(e,r,o,"ReduceMin",(s,p)=>{let l=[];for(let c=0;c<s[0].dims.length;c++)(p.indexOf(c)>=0||p.length===0)&&l.push(`inputIdx[${c}] = 0;`);return[`${l.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),mc=(e,r,o)=>Je(e,r,o,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),bc=(e,r,o)=>Je(e,r,o,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),yc=(e,r,o)=>Je(e,r,o,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),wc,Sg=I(()=>{"use strict";U(),wc=(e,r)=>{let o=C.calculateReshapedDims(r[0].dims,r[1].integerData);return e.session.pack?[e.reshapePacked(r[0],o)]:[e.reshapeUnpacked(r[0],o)]}}),Mn,Do,vc,xc,cr,au,No,Xr,Tc=I(()=>{"use strict";le(),Y(),V(),Mn={name:"Upsample",inputNames:["X"],inputTypes:[0]},Do=(e,r,o)=>(No(r,o),[e.run({...Mn,cacheHint:o.cacheKey,get:()=>au(e,r,o)},r)]),vc=e=>cr(e,7),xc=e=>cr(e,9),cr=(e,r)=>{let o=r>=10,s=e.attributes.getString("mode","nearest");if(s!=="nearest"&&s!=="linear"&&(r<11||s!=="cubic"))throw new Error(`unrecognized mode: ${s}`);let p=[];r<9&&(p=e.attributes.getFloats("scales"),Xr(p,s,o));let l=e.attributes.getFloat("extrapolation_value",0),c=r>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(c)===-1)throw new Error(`coordinate_transform_mode '${c}' is not supported`);let n=c==="tf_crop_and_resize",a=n,t=s==="nearest"&&r>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(t)===-1)throw new Error(`nearest_mode '${t}' is not supported`);let u=e.attributes.getFloat("cubic_coeff_a",-.75),i=e.attributes.getInt("exclude_outside",0)!==0;if(i&&s!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let d=r<11?!0:s==="nearest"&&c==="asymmetric"&&t==="floor",h=0,m=0,b=0;return r>10?e.inputs.length>2?(h=1,m=2,b=3):(m=1,b=2):r===9&&(m=1),X({opset:r,isResize:o,mode:s,scales:p,extrapolationValue:l,coordinateTransformMode:c,useExtrapolation:a,needRoiInput:n,nearestMode:t,cubicCoefficientA:u,excludeOutside:i,useNearest2xOptimization:d,roiInputIdx:h,scalesInputIdx:m,sizesInputIdx:b})},au=(e,r,o)=>{let s=B(e.session.backend.glContext.version),[p,l]=e.calculateTextureWidthAndHeight(r[0].dims,0),c=r[0].dims.map((b,x)=>Math.floor(b*o.scales[x])),[n,a]=e.calculateTextureWidthAndHeight(c,0),t=c.length,u=new Array(t),i=new Array(t),d=`
      int output_pitches[${t}];
      int input_pitches[${t}];
      `;for(let b=t-1;b>=0;b--)u[b]=b===t-1?1:u[b+1]*c[b+1],i[b]=b===t-1?1:i[b+1]*r[0].dims[b+1],d+=`
        output_pitches[${b}] = ${u[b]};
        input_pitches[${b}] = ${i[b]};
        `;let h=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${p}, ${l});
        float value = getColorAsFloat(${s.texture2D}(X, coords));
        return value;
      }
      `,m=o.mode==="nearest"?`
    ${h}
    float process(int indices[${t}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${n}, ${a});

      ${d}

      int d, m;
      for (int dim = 0; dim < ${t}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:t===4?`
    ${h}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${n}, ${a});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${r[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${h}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${n}, ${a});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${r[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...Mn,output:{dims:c,type:r[0].type,textureType:0},shaderSource:m,variables:[{name:"scales",type:"int",arrayLength:o.scales.length,data:o.scales.map(b=>Math.ceil(b))}]}},No=(e,r)=>{if(!e||r.opset<9&&e.length!==1||r.opset>=9&&r.opset<11&&e.length!==2||r.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(r.scales.length>0&&e[0].dims.length!==r.scales.length)throw new Error("Invalid input shape.");if(e[0].type==="string")throw new Error("Invalid input tensor types.")},Xr=(e,r,o)=>{if(o){for(let s of e)if(s<=0)throw new Error("Scale value should be greater than 0.")}else for(let s of e)if(s<1)throw new Error("Scale value should be greater than or equal to 1.");if((r==="linear"||r==="cubic")&&e.length!==2&&(e.length!==4||e[0]!==1||e[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?"Resize":"Upsample"} opeartor.`)}}),Lr,ko,_c,Sc,su,uu,lu,pu,Og=I(()=>{"use strict";Y(),V(),qe(),Nt(),Tc(),Lr={name:"Resize",inputNames:["A"],inputTypes:[2]},ko=(e,r,o)=>(No(r,o),[e.run({...Lr,cacheHint:o.cacheKey,get:()=>su(e,r,o)},r)]),_c=e=>cr(e,10),Sc=e=>cr(e,11),su=(e,r,o)=>{let s=B(e.session.backend.glContext.version),[p,l]=uu(r,o);if(p.every(w=>w===1)&&o.coordinateTransformMode!=="tf_crop_and_resize")return{...Lr,output:{dims:l,type:r[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${s.texture2D}(X, TexCoords);
                    ${s.output} = v;
                }`};let c=l.length;if(c<2)throw new Error(`output dimension should be at least 2, but got ${c}`);let n=l[c-2],a=l[c-1],t=r[0].dims;if(c!==t.length)throw new Error(`output dimension should match input ${t.length}, but got ${c}`);let u=t[c-2],i=t[c-1],d=p[c-2],h=p[c-1],m="";if(o.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${o.mode}'`);switch(o.coordinateTransformMode){case"asymmetric":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${a}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${n}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${a}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${n}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${a}.0 - 1.0, ${n}.0 - 1.0, ${a}.0 - 1.0,
                            ${n}.0 - 1.0);
                        vec4 original = vec4(${i}.0 - 1.0, ${u}.0 - 1.0, ${i}.0 - 1.0,
                            ${u}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o.coordinateTransformMode}'`)}let b=rt(c),x=yr(),E=`
            const vec2 inputWH = vec2(${u}.0, ${i}.0);
            const vec4 scaleWHWH = vec4(float(${d}), float(${h}), float(${d}), float(${h}));
            ${x}
            ${m}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${b} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${n-1};
                bool hasNextCol = rc.z < ${a-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s.output} = vec4(newValue);
            }
        `;return{...Lr,output:{dims:l,type:r[0].type,textureType:2},hasMain:!0,shaderSource:E}},uu=(e,r)=>{let o=e[0].dims,s=r.scales,p;if(s.length===0){let c=e[r.scalesInputIdx];if(c&&c.size!==0){if(e[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");s=lu(c,r.mode,r.isResize)}else{let n=e[r.sizesInputIdx];if(!n||n.size===0)throw new Error("Either scales or sizes MUST be provided as input.");p=Array.from(n.integerData),s=pu(p,o,r.mode,r.isResize)}}else if(e[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let l=p||o.map((c,n)=>Math.floor(c*s[n]));return[s,l]},lu=(e,r,o)=>{let s=Array.from(e.floatData);return Xr(s,r,o),s},pu=(e,r,o,s)=>{let p=r.length,l=new Array(p);for(let c=0,n=p;c<n;c++)if(r[c]===0){if(e[c]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");l[c]=1}else l[c]=e[c]/r[c];return Xr(l,o,s),l}}),Oc,cu,Eg=I(()=>{"use strict";Dt(),Oc=(e,r)=>(cu(r),[new Pe([r[0].dims.length],"int32",void 0,void 0,new Int32Array(r[0].dims))]),cu=e=>{if(!e||e.length!==1)throw new Error("Shape requires 1 input.")}}),Rr,Ec,Ic,zn,du,Pc,hu,fu,Ig=I(()=>{"use strict";le(),tn(),U(),V(),Rr={name:"Slice",inputNames:["A"],inputTypes:[0]},Ec=(e,r,o)=>(du(r),[e.run({...Rr,cacheHint:o.cacheKey,get:()=>zn(e,r[0],o)},r)]),Ic=e=>{let r=e.attributes.getInts("starts"),o=e.attributes.getInts("ends"),s=e.attributes.getInts("axes",[]);return X({starts:r,ends:o,axes:s})},zn=(e,r,o)=>{let s=o.axes.length===0?r.dims.slice(0).map((u,i)=>i):o.axes,p=C.normalizeAxes(s,r.dims.length),l=o.starts.map((u,i)=>u>r.dims[p[i]]-1?r.dims[p[i]]:C.normalizeAxis(u,r.dims[p[i]])),c=o.ends.map((u,i)=>u>r.dims[p[i]]-1?r.dims[p[i]]:C.normalizeAxis(u,r.dims[p[i]])),n=r.dims.slice(),a=[];for(let u=0;u<p.length;u++)n[p[u]]=c[u]-l[u],l[u]>0&&a.push(`outputIdx[${p[u]}] += ${l[u]};`);let t=`
      float process(int outputIdx[${n.length}]) {
        ${a.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Rr,output:{dims:n,type:r.type,textureType:0},shaderSource:t}},du=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(vr.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},Pc=(e,r)=>{fu(r);let o=hu(e,r);return[e.run({...Rr,cacheHint:o.cacheKey,get:()=>zn(e,r[0],o)},[r[0]])]},hu=(e,r)=>{if(!e.session.isInitializer(r[1].dataId)||!e.session.isInitializer(r[2].dataId)||r.length>=4&&!e.session.isInitializer(r[3].dataId)||r.length>=5&&!e.session.isInitializer(r[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(r.length>=5&&r[4].integerData.some(c=>c!==1))throw new Error("currently non-1 steps is not supported for Slice");let o=Array.from(r[1].integerData),s=Array.from(r[2].integerData),p=r.length>=4?Array.from(r[3].integerData):[],l=`${p};${o};${s}`;return{starts:o,ends:s,axes:p,cacheKey:l}},fu=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}}),Un,Gn,Hn,Ac,$c,Dc,Nc,qn,gu,mu,bu,Wn,Pg=I(()=>{"use strict";le(),U(),Y(),V(),ei(),Un={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Gn={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Hn={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Ac=(e,r,o)=>{Wn(r);let s=r[0].dims.slice(),p=C.normalizeAxis(o.axis,s.length),l=C.sizeToDimension(s,p),c=C.sizeFromDimension(s,p);return qn(e,r,o,l,c)},$c=e=>X({axis:e.attributes.getInt("axis",1)}),Dc=e=>X({axis:e.attributes.getInt("axis",-1)}),Nc=(e,r,o)=>{Wn(r);let s=r[0].dims.slice(),p=C.normalizeAxis(o.axis,s.length),l=s.length,c=p!==l-1,n=[],a=[],t=[],u;c&&(a=Array.from({length:l}).map((m,b)=>b),a[p]=l-1,a[l-1]=p,a.map(m=>n.push(s[m])),u=X({perm:a}),t=gr(e,r,u));let i=c?C.sizeToDimension(n,l-1):C.sizeToDimension(s,l-1),d=c?C.sizeFromDimension(n,l-1):C.sizeFromDimension(s,l-1),h=qn(e,c?t:r,o,i,d);return c?gr(e,h,u):h},qn=(e,r,o,s,p)=>{let l=gu(e,r[0],s,p,[s]),c=e.run({...Un,cacheHint:o.cacheKey,get:()=>l},r),n=mu(e,r[0],s,p,l.output.dims,[s]),a=e.run({...Gn,cacheHint:o.cacheKey,get:()=>n},[r[0],c]),t=bu(e,r[0],s,p,l.output.dims,n.output.dims);return[e.run({...Hn,cacheHint:o.cacheKey,get:()=>t},[r[0],c,a])]},gu=(e,r,o,s,p)=>{let[l,c]=e.calculateTextureWidthAndHeight(r.dims,0),n=p.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(p.length!==1)throw new Error("Dimensionality of the output should be 1");if(p[0]!==o)throw new Error("Shape of the output should be equal to logical row count");let a=B(e.session.backend.glContext.version),t=`
      float process(int[${n}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float max = getColorAsFloat(${a.texture2D}(A, offsetToCoords(logical_row_start_offset, ${l},
        ${c} )));
        for(int i=1; i<${s}; ++i)
        {
          float current = getColorAsFloat(${a.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${l}, ${c})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Un,output:{dims:p,type:r.type,textureType:0},shaderSource:t}},mu=(e,r,o,s,p,l)=>{let[c,n]=e.calculateTextureWidthAndHeight(r.dims,0),a=l.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(l.length!==1)throw new Error("Dimensionality of the output should be 1");if(l[0]!==o)throw new Error("Shape of the output should be equal to logical row count");if(p.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(p[0]!==o)throw new Error("Shape of the intermediate results should be equal to logical row count");let t=B(e.session.backend.glContext.version),u=`
      float process(int[${a}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${s}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${t.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${c}, ${n}))) - max);
        }

        return norm_factor;
      }`;return{...Gn,output:{dims:l,type:r.type,textureType:0},shaderSource:u}},bu=(e,r,o,s,p,l)=>{let[c,n]=e.calculateTextureWidthAndHeight(r.dims,0),a=r.dims.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(p.length!==1||l.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(p[0]!==o||l[0]!==o)throw new Error("Shape of the intermediate results should be equal to logical row count");let t=`
      float process(int[${a}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${c}, ${n});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${s};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Hn,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:t}},Wn=e=>{if(!e||e.length!==1)throw new Error("Softmax requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type")}}),Xn,kc,Fc,yu,wu,vu,Ag=I(()=>{"use strict";le(),U(),V(),Xn={name:"Split",inputNames:["A"],inputTypes:[0]},kc=(e,r,o)=>{vu(r);let s=C.normalizeAxis(o.axis,r[0].dims.length),p=yu(e,r,s,o),l=[];for(let c=0;c<p;++c)l.push(e.run({...Xn,cacheHint:`${o.cacheKey};${c}`,get:()=>wu(e,r[0],o,s,c)},r));return l},Fc=e=>{let r=e.attributes.getInt("axis",0),o=e.attributes.getInts("split",[]),s=e.outputs.length;return X({axis:r,split:o,numOutputs:s})},yu=(e,r,o,s)=>{let[,p]=bo.splitShape(r[0].dims,o,s.split,s.numOutputs);return p.length},wu=(e,r,o,s,p)=>{let[l,c]=bo.splitShape(r.dims,s,o.split,o.numOutputs),n=c[p],a=l[p],t=`
      float process(int indices[${a.length}]) {
        indices[${s}] += ${n};
        return _A(indices);
      }
    `;return{...Xn,cacheHint:`${o.cacheKey}:${p}`,output:{dims:a,type:r.type,textureType:0},shaderSource:t}},vu=e=>{if(!e||e.length!==1)throw new Error("Split requires one input.");if(e[0].type!=="int8"&&e[0].type!=="uint8"&&e[0].type!=="int16"&&e[0].type!=="uint16"&&e[0].type!=="int32"&&e[0].type!=="uint32"&&e[0].type!=="float32"&&e[0].type!=="float64"&&e[0].type!=="bool")throw new Error("Invalid input type.")}}),Fo,Cc,Lc,xu,Tu,$g=I(()=>{"use strict";U(),Fo=(e,r,o)=>{xu(r);let s=C.squeezeShape(r[0].dims,o);return[e.reshapeUnpacked(r[0],s)]},Cc=(e,r)=>(Tu(r),Fo(e,[r[0]],Array.from(r[1].integerData))),Lc=e=>e.attributes.getInts("axes"),xu=e=>{if(!e||e.length!==1)throw new Error("Squeeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},Tu=e=>{if(!e||e.length!==2)throw new Error("Squeeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),Rc,_u,Su,Dg=I(()=>{"use strict";Y(),V(),Rc=(e,r)=>{Su(r);let o={name:"Sum",inputNames:r.map((s,p)=>`X${p}`),inputTypes:new Array(r.length).fill(0)};return[e.run({...o,get:()=>_u(e,r,o)},r)]},_u=(e,r,o)=>{let s=B(e.session.backend.glContext.version),p=r[0].dims.slice(),l=`
      void main() {
        vec4 result = ${r.map((c,n)=>`${s.texture2D}(X${n},TexCoords)`).join(" + ")};
        ${s.output} = result;
      }
    `;return{...o,output:{dims:p,type:r[0].type,textureType:0},hasMain:!0,shaderSource:l}},Su=e=>{if(!e||e.length===0)throw new Error("Sum requires inputs.");let r=e[0].dims.length;for(let o=1;o<e.length;o++){if(r!==e[o].dims.length)throw new Error("Input shapes are mismatched.");for(let s=0;s<r;s++)if(e[0].dims[s]!==e[o].dims[s])throw new Error("Input shapes are not matched.")}if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.");for(let o=1;o<e.length;o++)if(e[0].type!==e[o].type)throw new Error("Input types are not matched.")}}),jc,Ou,Eu,Ng=I(()=>{"use strict";tn(),V(),jc=(e,r)=>{Eu(r);let o={name:"Tile",inputNames:["A"],inputTypes:[0]};return[e.run({...o,get:()=>Ou(e,r,o)},r)]},Ou=(e,r,o)=>{let s=r[0].dims.slice(),p=new Array(s.length),l=[];for(let a=0;a<s.length;a++)p[a]=s[a]*r[1].numberData[a],l.push(`inputIdx[${a}] = int(mod(float(outputIdx[${a}]), ${s[a]}.));`);let c=p.length,n=`
      float process(int outputIdx[${c}]) {
        int inputIdx[${c}];
        ${l.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...o,output:{dims:p,type:r[0].type,textureType:0},shaderSource:n}},Eu=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 input.");if(e[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(vr.indexOf(e[0].type)===-1)throw new Error("Invalid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invalid repeat type.")}}),Co,Bc,Vc,Iu,Pu,kg=I(()=>{"use strict";U(),Co=(e,r,o)=>{Iu(r);let s=C.unsqueezeShape(r[0].dims,o);return[e.reshapeUnpacked(r[0],s)]},Bc=(e,r)=>(Pu(r),Co(e,[r[0]],Array.from(r[1].integerData))),Vc=e=>e.attributes.getInts("axes"),Iu=e=>{if(!e||e.length!==1)throw new Error("Unsqueeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},Pu=e=>{if(!e||e.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),Mc,Fg=I(()=>{"use strict";xf(),Cf(),Lf(),jf(),Qo(),cg(),dg(),hg(),fg(),gg(),mg(),bg(),vg(),Jo(),xg(),Tg(),_g(),Sg(),Og(),Eg(),Ig(),Pg(),Ag(),$g(),Dg(),Ng(),ei(),Ep(),kg(),Tc(),Mc=[["Abs","","6+",np],["Acos","","7+",op],["Add","","7+",Rl],["And","","7+",jl],["Asin","","7+",ip],["Atan","","7+",ap],["AveragePool","","7+",ic,ac],["BatchNormalization","","7+",kl,Fl],["Cast","","6+",Kl,Zl],["Ceil","","6+",lp],["Clip","","6-10",So,sp],["Clip","","11+",up],["Concat","","4+",Yl,Ql],["Conv","","1+",Io,Po],["ConvTranspose","","1+",Bp,Vp],["Cos","","7+",pp],["Div","","7+",Bl],["Dropout","","7+",Oo],["DepthToSpace","","1+",zp,Up],["Equal","","7+",Vl],["Elu","","6+",cp,dp],["Exp","","6+",hp],["Flatten","","1+",Gp,Hp],["Floor","","6+",fp],["FusedConv","com.microsoft","1+",Io,Po],["Gather","","1+",qp,Wp],["Gemm","","7-10",Ao,Xp],["Gemm","","11+",Ao,Kp],["GlobalAveragePool","","1+",sc,uc],["GlobalMaxPool","","1+",cc],["Greater","","7+",Ml],["Identity","","1+",Oo],["ImageScaler","","1+",Zp,Jp],["InstanceNormalization","","6+",Yp,Qp],["LeakyRelu","","6+",gp,mp],["Less","","7+",zl],["LRN","","1+",ec,tc],["Log","","6+",bp],["MatMul","","1+",Dp,Np],["MaxPool","","1+",lc,pc],["Mul","","7+",Ul],["Neg","","6+",yp],["Not","","1+",wp],["Or","","7+",Gl],["Pad","","2-10",$o,rc],["Pad","","11+",nc,oc],["Pow","","7+",Hl],["PRelu","","7+",ql],["ReduceLogSum","","1+",bc,et],["ReduceMax","","1+",fc,et],["ReduceMean","","1+",hc,et],["ReduceMin","","1+",gc,et],["ReduceProd","","1+",mc,et],["ReduceSum","","1-12",dc,et],["ReduceSumSquare","","1+",yc,et],["Relu","","6+",vp],["Reshape","","5+",wc],["Resize","","10",ko,_c],["Resize","","11+",ko,Sc],["Shape","","1+",Oc],["Sigmoid","","6+",xp],["Sin","","7+",Tp],["Slice","","10+",Pc],["Slice","","1-9",Ec,Ic],["Softmax","","1-12",Ac,$c],["Softmax","","13+",Nc,Dc],["Split","","2-12",kc,Fc],["Sqrt","","6+",_p],["Squeeze","","1-12",Fo,Lc],["Squeeze","","13+",Cc],["Sub","","7+",Wl],["Sum","","6+",Rc],["Tan","","7+",Sp],["Tanh","","6+",Op],["Tile","","6+",jc],["Transpose","","1+",gr,Mp],["Upsample","","7-8",Do,vc],["Upsample","","9",Do,xc],["Unsqueeze","","1-12",Co,Vc],["Unsqueeze","","13+",Bc],["Xor","","7+",Xl]]});function Cg(e){let r={},o;for(;(o=Lo.exec(e))!==null;){let s=o[3].split(",").map(p=>{let l=p.trim().split(" ");return l&&l.length===2?{type:l[0],name:l[1]}:null}).filter(p=>p!==null);r[o[2]]={params:s,body:o[4]}}for(let s in r){let p=zc.replace("__FUNC__",s),l=new RegExp(p,"gm");for(;(o=l.exec(e))!==null;){let c=o[1],n=o[2],a=o[3].split(","),t=c?`${c} ${n};`:"",u=r[s].body,i="";r[s].params.forEach((h,m)=>{h&&(i+=`${h.type} ${h.name} = ${a[m]};
`)}),u=`${i}
 ${u}`,u=u.replace("return",`${n} = `);let d=`
      ${t}
      {
        ${u}
      }
      `;e=e.replace(o[0],d)}}return e=e.replace(Lo,""),e}var Lo,zc,Lg=I(()=>{"use strict";Lo=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,zc="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function nr(e,r){let o=[],s=[],p=r!=null&&Array.isArray(r)&&r.length===0,l=r==null||p?null:Rg(r,e).sort(),c=0;for(let n=0;n<e.length;++n){if(l!=null){if(l[c]===n&&e[n]!==1)throw new Error(`Can't squeeze axis ${n} since its dim '${e[n]}' is not 1`);(l[c]==null||l[c]>n)&&e[n]===1&&(o.push(e[n]),s.push(n)),l[c]<=n&&c++}e[n]!==1&&(o.push(e[n]),s.push(n))}return{newShape:o,keptDims:s}}function Rg(e,r){let o=r.length;return e=e==null?r.map((s,p)=>p):[].concat(e),Hr(e.every(s=>s>=-o&&s<o),()=>`All values in axis param must be in range [-${o}, ${o}) but got axis ${e}`),Hr(e.every(jg),()=>`All values in axis param must be integers but got axis ${e}`),e.map(s=>s<0?o+s:s)}function jg(e){return e%1===0}function Bg(e){if(e.length===0)return 1;let r=e[0];for(let o=1;o<e.length;o++)r*=e[o];return r}function Au(e){let r=Math.ceil(Math.sqrt(e));return[r,Math.ceil(e/r)]}var Uc,Gc=I(()=>{"use strict";Re(),U(),Uc=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,r){let o=this.computeTexture(e,r);return r&&r.isPacked&&(o[0]/=2,o[1]/=2),r&&r.reverseWH?[o[1],o[0]]:o}computeTexture(e,r){let o=r&&r.isPacked;if(e.length===0)return o?[2,2]:[1,1];let s=this.maxTextureSize;if(r&&r.breakAxis!==void 0){let c=r.breakAxis>=e.length?1:e.slice(r.breakAxis).reduce((a,t)=>a*t),n=r.breakAxis<=0?1:e.slice(0,r.breakAxis).reduce((a,t)=>a*t);if(c>s||n>s)ee.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${r.breakAxis}`);else return[c,n]}let p=e.slice(0);o&&(s=s*2,p=p.map((c,n)=>n>=p.length-2?p[n]%2===0?p[n]:p[n]+1:p[n]),p.length===1&&(p=[2,p[0]])),p.length!==2&&(p=nr(p).newShape);let l=Bg(p);return p.length<=1&&l<=s?[1,l]:p.length===2&&p[0]<=s&&p[1]<=s?p:p.length===3&&p[0]*p[1]<=s&&p[2]<=s?[p[0]*p[1],p[2]]:p.length===3&&p[0]<=s&&p[1]*p[2]<=s?[p[0],p[1]*p[2]]:p.length===4&&p[0]*p[1]*p[2]<=s&&p[3]<=s?[p[0]*p[1]*p[2],p[3]]:p.length===4&&p[0]<=s&&p[1]*p[2]*p[3]<=s?[p[0],p[1]*p[2]*p[3]]:o?Au(l/4).map(c=>c*2):Au(l)}}}),Hc,Vg=I(()=>{"use strict";U(),nt(),Y(),Gc(),qe(),Hc=class extends kt{constructor(e){super(e)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let e="offsetToCoords";return{offsetToCoords:new D(`
      vec2 ${e}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let e="coordsToOffset";return{coordsToOffset:new D(`
      int ${e}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){let r=e.unpackedShape,o=[e.width,e.height],s={},p="getOutputCoords";switch(r.length){case 0:s[p]=this.getOutputScalarCoords();break;case 1:s[p]=this.getOutputPacked1DCoords(r,o);break;case 2:s[p]=this.getOutputPacked2DCoords(r,o);break;case 3:s[p]=this.getOutputPacked3DCoords(r,o);break;default:s[p]=this.getOutputPackedNDCoords(r,o)}let l=`
      void setOutput(vec4 val) {
        ${B(this.context.glContext.version).output} = val;
      }
    `,c="floatTextureSetRGBA";return s[c]=new D(l),s}getUnpackedOutputSamplingSnippet(e){let r=e.unpackedShape,o=[e.width,e.height],s={},p="getOutputCoords";switch(r.length){case 0:s[p]=this.getOutputScalarCoords();break;case 1:s[p]=this.getOutputUnpacked1DCoords(r,o);break;case 2:s[p]=this.getOutputUnpacked2DCoords(r,o);break;case 3:s[p]=this.getOutputUnpacked3DCoords(r,o);break;case 4:s[p]=this.getOutputUnpacked4DCoords(r,o);break;case 5:s[p]=this.getOutputUnpacked5DCoords(r,o);break;case 6:s[p]=this.getOutputUnpacked6DCoords(r,o);break;default:throw new Error(`Unsupported output dimensionality: ${r.length}`)}let l=`
        void setOutput(float val) {
          ${B(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,c="floatTextureSetR";return s[c]=new D(l),s}getOutputScalarCoords(){return new D(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(e,r){let o=r,s="";return o[0]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${o[1]}.0);
          }
        `,new D(s)):o[1]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${o[0]}.0);
          }
        `,new D(s)):(s=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${o[0]}, ${o[1]}));
          return 2 * (resTexRC.y * ${o[0]} + resTexRC.x);
        }
      `,new D(s))}getOutputPacked2DCoords(e,r){let o="";if(er.arraysEqual(e,r))return o=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${r[0]}, ${r[1]}));
        }
      `,new D(o);let s=r,p=Math.ceil(e[1]/2);return o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));

          int index = resTexRC.y * ${s[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${p}) * 2;
          int c = 2 * (index / ${p});

          return ivec2(r, c);
        }
      `,new D(o)}getOutputPacked3DCoords(e,r){let o=[r[0],r[1]],s=Math.ceil(e[2]/2),p=s*Math.ceil(e[1]/2),l=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          int b = index / ${p};
          index -= b * ${p};

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec3(b, r, c);
        }
      `;return new D(l)}getOutputPackedNDCoords(e,r){let o=[r[0],r[1]],s=Math.ceil(e[e.length-1]/2),p=s*Math.ceil(e[e.length-2]/2),l=p,c="",n="b, r, c";for(let t=2;t<e.length-1;t++)l*=e[e.length-t-1],c=`
      int b${t} = index / ${l};
      index -= b${t} * ${l};
    `+c,n=`b${t}, `+n;let a=`
      ivec${e.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${o[0]}, ${o[1]}));
        int index = resTexRC.y * ${o[0]} + resTexRC.x;

        ${c}

        int b = index / ${p};
        index -= b * ${p};

        // reverse r and c order for packed texture
        int r = imod(index, ${s}) * 2;
        int c = 2 * (index / ${s});

        return ivec${e.length}(${n});
      }
    `;return new D(a)}getOutputUnpacked1DCoords(e,r){let o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          return resTexRC.y * ${r[0]} + resTexRC.x;
        }
      `;return new D(o)}getOutputUnpacked2DCoords(e,r){let o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          int r = index / ${e[1]};
          int c = index - r * ${e[1]};
          return ivec2(r, c);
        }
      `;return new D(o)}getOutputUnpacked3DCoords(e,r){let o="",s=e.length,p=null;s<2&&(p=[]),p=new Array(s-1),p[s-2]=e[s-1];for(let n=s-3;n>=0;--n)p[n]=p[n+1]*e[n+1];let l=["r","c","d"],c=p.map((n,a)=>{let t=`int ${l[a]} = index / ${n}`,u=a===p.length-1?`int ${l[a+1]} = index - ${l[a]} * ${n}`:`index -= ${l[a]} * ${n}`;return`${t}; ${u};`}).join("");return o=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${c}
          return ivec3(r, c, d);
        }
      `,new D(o)}getOutputUnpacked4DCoords(e,r){let o="",s=e.length,p=null;s<2&&(p=[]),p=new Array(s-1),p[s-2]=e[s-1];for(let n=s-3;n>=0;--n)p[n]=p[n+1]*e[n+1];let l=["r","c","d","d2"],c=p.map((n,a)=>{let t=`int ${l[a]} = index / ${n}`,u=a===p.length-1?`int ${l[a+1]} = index - ${l[a]} * ${n}`:`index -= ${l[a]} * ${n}`;return`${t}; ${u};`}).join("");return o=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${c}
          return ivec4(r, c, d, d2);
        }
      `,new D(o)}getOutputUnpacked5DCoords(e,r){let o="",s=e.length,p=null;s<2&&(p=[]),p=new Array(s-1),p[s-2]=e[s-1];for(let n=s-3;n>=0;--n)p[n]=p[n+1]*e[n+1];let l=["r","c","d","d2","d3"],c=p.map((n,a)=>{let t=`int ${l[a]} = index / ${n}`,u=a===p.length-1?`int ${l[a+1]} = index - ${l[a]} * ${n}`:`index -= ${l[a]} * ${n}`;return`${t}; ${u};`}).join("");return o=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${c}
          return ivec5(r, c, d, d2, d3);
        }
      `,new D(o)}getOutputUnpacked6DCoords(e,r){let o="",s=e.length,p=null;s<2&&(p=[]),p=new Array(s-1),p[s-2]=e[s-1];for(let n=s-3;n>=0;--n)p[n]=p[n+1]*e[n+1];let l=["r","c","d","d2","d3","d4"],c=p.map((n,a)=>{let t=`int ${l[a]} = index / ${n}`,u=a===p.length-1?`int ${l[a+1]} = index - ${l[a]} * ${n}`:`index -= ${l[a]} * ${n}`;return`${t}; ${u};`}).join("");return o=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${r[0]}, ${r[1]}));
         int index = resTexRC.y * ${r[0]} + resTexRC.x;
         ${c}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new D(o)}getCommonUtilFuncs(){let e={},r="uvFromFlat";e[r]=new D(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),r="packedUVfrom1D",e[r]=new D(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom2D",e[r]=new D(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom3D",e[r]=new D(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="sampleTexture";let o=B(this.context.glContext.version);return e[r]=new D(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${o.texture2D}(textureSampler, uv).r;
        }`),e}getInputsSamplingSnippets(){let e={},r=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((o,s)=>{let p=this.context.inputTextureLayouts[s],l=In(o);p.isPacked?e[l]=this.getPackedSamplerFromInput(l,o,p):e[l]=this.getUnpackedSamplerFromInput(l,o,p);let c=af(o);p.unpackedShape.length<=r.unpackedShape.length&&(p.isPacked?e[c]=this.getPackedSamplerAtOutputCoords(c,p,r,o):e[c]=this.getUnpackedSamplerAtOutputCoords(c,p,r,o))}),e}getPackedSamplerAtOutputCoords(e,r,o,s){let p=r.unpackedShape,l=o.unpackedShape,c=In(s),n=p.length,a=l.length,t=Me.getBroadcastDims(p,l),u=rt(a),i=a-n,d,h=$t();n===0?d="":a<2&&t.length>=1?d="coords = 0;":d=t.map($=>`coords.${h[$+i]} = 0;`).join(`
`);let m="";a<2&&n>0?m="coords":m=p.map(($,F)=>`coords.${h[F+i]}`).join(", ");let b="return outputValue;",x=C.size(p)===1,E=C.size(l)===1;if(n===1&&!x&&!E)b=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(x&&!E)a===1?b=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:b=`
          return vec4(outputValue.x);
        `;else if(t.length){let $=n-2,F=n-1;t.indexOf($)>-1&&t.indexOf(F)>-1?b="return vec4(outputValue.x);":t.indexOf($)>-1?b="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":t.indexOf(F)>-1&&(b="return vec4(outputValue.xx, outputValue.zz);")}let w=`
        int lastDim = coords.${h[a-1]};
        coords.${h[a-1]} = coords.${h[a-2]};
        coords.${h[a-2]} = lastDim;
      `,S=`
      vec4 ${e}() {
        ${u} coords = getOutputCoords();
        ${w}
        ${d}
        vec4 outputValue = ${c}(${m});
        ${b}
      }
    `;return new D(S,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,r,o,s){let p=[o.width,o.height],l=[r.width,r.height],c=r.unpackedShape.length,n=o.unpackedShape.length,a=r.unpackedShape,t=o.unpackedShape,u=In(s);if(c===n&&er.arraysEqual(l,p)){let w=`
          float ${e}() {
            return sampleTexture(${s}, TexCoords);
          }
        `;return new D(w,["coordinates.sampleTexture"])}let i=rt(n),d=Me.getBroadcastDims(a,t),h=n-c,m,b=$t();c===0?m="":n<2&&d.length>=1?m="coords = 0;":m=d.map(w=>`coords.${b[w+h]} = 0;`).join(`
`);let x="";n<2&&c>0?x="coords":x=r.unpackedShape.map((w,S)=>`coords.${b[S+h]}`).join(", ");let E=`
        float ${e}() {
          ${i} coords = getOutputCoords();
          ${m}
          return ${u}(${x});
        }
      `;return new D(E,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,r,o){switch(o.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,r);case 1:return this.getPackedSampler1D(e,r,o);case 2:return this.getPackedSampler2D(e,r,o);case 3:return this.getPackedSampler3D(e,r,o);default:return this.getPackedSamplerND(e,r,o)}}getUnpackedSamplerFromInput(e,r,o){let s=o.unpackedShape;switch(s.length){case 0:return this.getUnpackedSamplerScalar(e,r,o);case 1:return this.getUnpackedSampler1D(e,r,o);case 2:return this.getUnpackedSampler2D(e,r,o);case 3:return this.getUnpackedSampler3D(e,r,o);case 4:return this.getUnpackedSampler4D(e,r,o);case 5:return this.getUnpackedSampler5D(e,r,o);case 6:return this.getUnpackedSampler6D(e,r,o);default:throw new Error(`Unsupported dimension ${s.length}-D`)}}getPackedSamplerScalar(e,r){let o=B(this.context.glContext.version),s=`
          vec4 ${e}() {
            return ${o.texture2D}(${r}, halfCR);
          }
        `;return new D(s)}getPackedSampler1D(e,r,o){let s=[o.width,o.height],p=[s[1],s[0]],l=B(this.context.glContext.version),c=`vec4 ${e}(int index) {
      vec2 uv = packedUVfrom1D(
      ${p[0]}, ${p[1]}, index);
      return ${l.texture2D}(${r}, uv);
    }`;return new D(c,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,r,o){let s=o.unpackedShape,p=[o.width,o.height],l=B(this.context.glContext.version),c=p[0],n=p[1];if(p!=null&&er.arraysEqual(s,p)){let i=`vec4 ${e}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${c}.0);
        return ${l.texture2D}(${r}, uv);
      }`;return new D(i)}let a=p,t=Math.ceil(s[1]/2),u=`vec4 ${e}(int row, int col) {
      vec2 uv = packedUVfrom2D(${a[1]}, ${a[0]}, ${t}, row, col);
      return ${l.texture2D}(${r}, uv);
    }`;return new D(u,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,r,o){let s=o.unpackedShape,p=[o.width,o.height],l=[p[0],p[1]],c=B(this.context.glContext.version);if(s[0]===1){let d=s.slice(1),h=[1,2],m=Gt(s,d),b=["b","row","col"],x=JSON.parse(JSON.stringify(o));x.unpackedShape=m;let E=this.getPackedSamplerFromInput(e,r,x),w=`${E.routineBody}
      vec4 ${e}(int b, int row, int col) {
        return ${e}(${Ht(b,h)});
      } `;return new D(w,E.dependencies)}let n=l[0],a=l[1],t=Math.ceil(s[2]/2),u=t*Math.ceil(s[1]/2),i=`vec4 ${e}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${a}, ${n}, ${u}, ${t}, b, row, col);
      return ${c.texture2D}(${r}, uv);}`;return new D(i,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,r,o){let s=o.unpackedShape,p=s.length,l=[o.width,o.height],c=B(this.context.glContext.version),n=[l[0],l[1]],a=n[1],t=n[0],u=Math.ceil(s[p-1]/2),i=u*Math.ceil(s[p-2]/2),d="int b, int row, int col",h=`b * ${i} + (row / 2) * ${u} + (col / 2)`;for(let b=2;b<p-1;b++)d=`int b${b}, `+d,i*=s[p-b-1],h=`b${b} * ${i} + `+h;let m=`vec4 ${e}(${d}) {
      int index = ${h};
      int texR = index / ${t};
      int texC = index - texR * ${t};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}, ${a});
      return ${c.texture2D}(${r}, uv);
    }`;return new D(m)}getUnpackedSamplerScalar(e,r,o){let[s,p]=[o.width,o.height];if(s===1&&p===1){let c=`
          float ${e}() {
            return sampleTexture(${r}, halfCR);
          }
        `;return new D(c,["coordinates.sampleTexture"])}let l=`
        float ${e}() {
          int offset_${r} = coordsToOffset(TexCoords, ${s}, ${p});
          vec2 uv = uvFromFlat(${s}, ${p}, offset_${r});
          return sampleTexture(${r}, uv);
        }
      `;return new D(l,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,r,o){let s=o.width,p=o.height;if(p===1&&s===1){let c=`
        float ${e}(int index) {
          return sampleTexture(${r}, halfCR);
        }
      `;return new D(c,["coordinates.sampleTexture"])}if(p===1){let c=`
          float ${e}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${s}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new D(c,["coordinates.sampleTexture"])}if(s===1){let c=`
          float ${e}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${p}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new D(c,["coordinates.sampleTexture"])}let l=`
        float ${e}(int index) {
          vec2 uv = uvFromFlat(${s}, ${p}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new D(l,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,r,o){let s=o.unpackedShape,p=[o.height,o.width];if(p!=null&&er.arraysEqual(s,p)){let i=p[1],d=p[0],h=`
          float ${e}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${i}.0, ${d}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new D(h,["coordinates.sampleTexture"])}let{newShape:l,keptDims:c}=nr(s),n=l;if(n.length<s.length){let i=Gt(s,n),d=JSON.parse(JSON.stringify(o));d.unpackedShape=i;let h=["col","row"],m=`
          ${this.getUnpackedSamplerFromInput(e,r,d).routineBody}
          float ${e}(int row, int col) {
            return ${e}(${Ht(h,c)});
          }
        `;return new D(m,["coordinates.sampleTexture"])}let a=p[1],t=p[0];if(t===1){let i=`
          float ${e}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${a}, ${t});
            float index = dot(vec3(row, col, offset_${r}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${a}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new D(i,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(a===1){let i=`
          float ${e}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${a}, ${t});
            float index = dot(vec3(row, col, offset_${r}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${t}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new D(i,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let u=`
        float ${e}(int row, int col) {
          int index = col * ${s[1]} + row;
          vec2 uv = uvFromFlat(${a}, ${t}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new D(u,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,r,o){let s=o.unpackedShape,p=s[1]*s[2],l=s[2],{newShape:c,keptDims:n}=nr(s),a=c;if(a.length<s.length){let d=Gt(s,a),h=["batch","col","row"],m=JSON.parse(JSON.stringify(o));m.unpackedShape=d;let b=this.getUnpackedSamplerFromInput(e,r,m),x=n.reverse(),E=`
          ${b.routineBody}
          float ${e}(int batch, int row, int col) {
            return ${e}(${Ht(h,x)});
          }
        `;return new D(E,b.dependencies)}let t=o.width,u=o.height,i=`
          float ${e}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${p} + col * ${l} + row;
            vec2 uv = uvFromFlat(${t}, ${u}, index);
            return sampleTexture(${r}, uv);
          }
      `;return new D(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,r,o){let s=o.unpackedShape,p=s[3],l=s[2]*p,c=s[1]*l,n=o.width,a=o.height,t=`
        float ${e}(int row, int col, int depth, int depth2) {
          int index = row * ${c} + col * ${l} +
              depth2 * ${p} + depth;
          vec2 uv = uvFromFlat(${n}, ${a}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new D(t,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,r,o){let s=o.unpackedShape,p=s[4],l=s[3]*p,c=s[2]*l,n=s[1]*c,{newShape:a,keptDims:t}=nr(s);if(a.length<s.length){let h=Gt(s,a),m=["row","col","depth","depth2","depth3"],b=JSON.parse(JSON.stringify(o));b.unpackedShape=h;let x=`
          ${this.getUnpackedSamplerFromInput(e,r,b).routineBody}
          float ${e}(int row, int col, int depth, int depth2, int depth3) {
            return ${e}(${Ht(m,t)});
          }
        `;return new D(x,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let u=o.width,i=o.height,d=`
        float ${e}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${n} + col * ${c} + depth * ${l} +
          depth3 * ${p} + depth2;
          vec2 uv = uvFromFlat(${u}, ${i}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new D(d,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,r,o){let s=o.unpackedShape,p=s[5],l=s[4]*p,c=s[3]*l,n=s[2]*c,a=s[1]*n,{newShape:t,keptDims:u}=nr(s);if(t.length<s.length){let m=Gt(s,t),b=["row","col","depth","depth2","depth3","depth4"],x=JSON.parse(JSON.stringify(o));x.unpackedShape=m;let E=`
            ${this.getUnpackedSamplerFromInput(e,r,x).routineBody}
            float ${e}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e}(${Ht(b,u)});
            }
          `;return new D(E,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let i=o.width,d=o.height,h=`
          float ${e}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${a} + col * ${n} + depth * ${c} +
            depth2 * ${l} + depth3 * ${p} + depth4;
            vec2 uv = uvFromFlat(${i}, ${d}, index);
            return sampleTexture(${r}, uv);
          }
        `;return new D(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let e=this.context.outputTextureLayout,r=e.shape.length,o=e.strides,s=e.width,p=e.height,l=[];for(let n=0;n<r-1;++n)l.push(`
        c[${n}] = offset / ${o[n]};`),l.push(`
        offset -= c[${n}] * ${o[n]};`);l.push(`
        c[${r-1}] = offset;`);let c=`
      void toVec(vec2 texCoords, out int c[${r}]) {
        int offset = coordsToOffset(texCoords, ${s}, ${p});
        ${l.join("")}
      }
      void toVec(int offset, out int c[${r}]) {
        ${l.join("")}
      }
    `;return{toVec:new D(c,["coordinates.coordsToOffset"])}}valueFrom(){let e={};return this.context.programInfo.inputNames.forEach((r,o)=>{let s=this.context.inputTextureLayouts[o],p=(s.unpackedShape.length>0?s.unpackedShape:s.shape).length,l=`_${r}`;e[l]=new D(this.getValueFromSingle(r,p,s.width,s.height,!1),[`shapeUtils.indicesToOffset${l}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),l=l+"_T",e[l]=new D(this.getValueFromSingle(r,p,s.width,s.height,!0),[`shapeUtils.indicesToOffset${l}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),e}getValueFromSingle(e,r,o,s,p){let l=`_${e}`;p&&(l=l+"_T");let c=B(this.context.glContext.version);return`
        float ${l}(int m[${r}]) {
          int offset = indicesToOffset${l}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${s});
          float value = getColorAsFloat(${c.texture2D}(${e}, coords));
          return value;
        }
        `}getPackedValueFrom(e,r,o,s,p){let l=`_${e}_Pack`;p&&(l=l+"_T");let c=B(this.context.glContext.version);return`
        vec4 ${l}(int m[${r}]) {
          int offset = indicesToOffset_${e}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${s});
          return ${c.texture2D}(${e}, coords);
        }
        `}}}),qc,Mg=I(()=>{"use strict";nt(),qc=class Ro extends kt{constructor(r){super(r)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new D(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new D(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let r=Ro.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new D(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${r}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let r=Ro.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new D(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${r}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let r=new ArrayBuffer(4),o=new Uint32Array(r),s=new Uint8Array(r);if(o[0]=3735928559,s[0]===239)return!0;if(s[0]===222)return!1;throw new Error("unknown endianness")}}}),Wc,zg=I(()=>{"use strict";nt(),Y(),Wc=class extends kt{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=B(this.context.glContext.version);return{setFragColor:new D(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new D(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),Xc,Ug=I(()=>{"use strict";nt(),Xc=class or extends kt{constructor(r){super(r)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let r=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((s,p)=>{let l=this.context.inputTextureLayouts[p].unpackedShape;if(l.length<=r){let c=l.length,n=r-c,a=`bcastIndices_${s}`,t="";for(let i=0;i<c;++i)t+=`
          realIndices[${i}] = int( mod(float(bcastedIndices[${n+i}]), ${l[i]}.0) );
          `;let u=`
        void ${a} (int bcastedIndices[${r}], out int realIndices[${c}]) {
          ${t}
        }
        `;o[a]=new D(u)}}),o}bcastMatmulIndex(){let r=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((s,p)=>{let l=this.context.inputTextureLayouts[p].shape;if(!(l.length<2||l.length>r)){let c=l.length,n=r-c,a=`bcastMatmulIndices_${s}`,t="";for(let i=0;i<c-2;++i)t+=`
          realIndices[${i}] = int( mod(float(bcastedIndices[${n+i}]), ${l[i]}.0) );
          `;let u=`
        void ${a}(int bcastedIndices[${r}], out int realIndices[${c}]) {
          ${t}
          realIndices[${c-1}] = bcastedIndices[${r-1}];
          realIndices[${c-2}] = bcastedIndices[${r-2}];
        }
        `;o[a]=new D(u)}}),o}indicesToOffset(){let r={};return this.context.programInfo.inputNames.forEach((o,s)=>{let p=this.context.inputTextureLayouts[s].shape,l=this.context.inputTextureLayouts[s].strides,c=p.length,n=`indicesToOffset_${o}`;r[n]=new D(or.indexToOffsetSingle(n,c,l)),n=`indicesToOffset_${o}_T`,r[n]=new D(or.indexToOffsetSingle(n,c,l.slice().reverse()))}),r}static indexToOffsetSingle(r,o,s){let p="";for(let l=o-1;l>=0;--l)p+=`
        offset += indices[${l}] * ${s[l]};
        `;return`
      int ${r}(int indices[${o}]) {
        int offset = 0;
        ${p}
        return offset;
      }
      `}offsetToIndices(){let r={};return this.context.programInfo.inputNames.forEach((o,s)=>{let p=this.context.inputTextureLayouts[s].shape,l=this.context.inputTextureLayouts[s].strides,c=p.length,n=`offsetToIndices_${o}`;r[n]=new D(or.offsetToIndicesSingle(n,c,l)),n=`offsetToIndices_${o}_T`,r[n]=new D(or.offsetToIndicesSingle(n,c,l.slice().reverse()))}),r}static offsetToIndicesSingle(r,o,s){let p=[];for(let l=0;l<o-1;++l)p.push(`
      indices[${l}] = offset / ${s[l]};`),p.push(`
        offset -= indices[${l}] * ${s[l]};`);return p.push(`
      indices[${o-1}] = offset;`),`
      void ${r}(int offset, out int indices[${o}]) {
        ${p.join("")}
      }
      `}incrementIndices(){let r={};return this.context.programInfo.inputNames.forEach((o,s)=>{let p=this.context.inputTextureLayouts[s].shape,l=p.length,c=`incrementIndices_${o}`,n="";for(let t=0;t<l;++t)n+=`
        shape[${t}] = ${p[t]};`;let a=`
        void ${c}(int axis, out int indices[${l}]) {
          int shape[${l}];
          ${n};
          for(int i = ${l} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;r[c]=new D(a)}),r}}}),Kc,Gg=I(()=>{"use strict";nt(),Kc=class extends kt{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let e=this.context.outputTextureLayout.shape.length,r={add:"+=",sub:"-=",mul:"*=",div:"/="},o={};for(let s in r){let p=`${s}Vec`,l="";for(let n=0;n<e;++n)l+=`
          dest[${n}] ${r[s]} src[${n}];
          `;let c=`
        void ${p}(int src[${e}], out int dest[${e}]) {
          ${l}
        }
        `;o[p]=new D(c)}return o}copyVec(){let e=this.context.outputTextureLayout.shape.length,r="";for(let s=0;s<e;++s)r+=`
        dest[${s}] = src[${s}];
        `;let o=`
      void copyVec(int src[${e}], out int dest[${e}]) {
        ${r}
      }
      `;return{copyVec:new D(o)}}setVecItem(){let e=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index =${e} + index;
        if (index == 0)
            m[0] = value;
        `;for(let s=1;s<e-1;++s)r+=`
        else if (index == ${s})
            m[${s}] = value;
            `;r+=`
        else
            m[${e-1}] = value;
        `;let o=`
      void setVecItem(out int m[${e}], int index, int value) {
        ${r}
      }
        `;return{setVecItem:new D(o)}}getVecItem(){let e=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index = ${e} + index;
        if (index == 0)
            return m[0];
      `;for(let s=1;s<e-1;++s)r+=`
        else if (index == ${s})
            return m[${s}];
      `;r+=`
        else
            return m[${e-1}];
        `;let o=`
      int getVecItem(int m[${e}], int index) {
        ${r}
      }
    `;return{getVecItem:new D(o)}}}}),jo,Hg=I(()=>{"use strict";Vg(),Mg(),zg(),Ug(),Gg(),jo={encoding:qc,fragcolor:Wc,vec:Kc,shapeUtils:Xc,coordinates:Hc}}),Zc,qg=I(()=>{"use strict";nt(),Lg(),Hg(),Y(),Zc=class{constructor(e,r,o,s){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new Cl(e,r,o,s),Object.keys(jo).forEach(l=>{let c=new jo[l](this.context);this.libs[l]=c});let p=this.glslLibRoutineDependencyGraph;for(let l in this.libs){let c=this.libs[l].getFunctions();for(let n in c){let a=l+"."+n,t;p[a]?(t=p[a],t.routineBody=c[n].routineBody):(t=new _o(a,c[n].routineBody),p[a]=t);let u=c[n].dependencies;if(u)for(let i=0;i<u.length;++i)if(p[u[i]])t.addDependency(p[u[i]]);else{let d=new _o(u[i]);p[u[i]]=d,t.addDependency(d)}}}}preprocess(){let e=this.context.programInfo,r=e.shaderSource;return this.context.programInfo.hasMain||(r=`${r}
      ${of(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),r=Cg(r),`${nf(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(r)}
    ${r}`}getImports(e){let r=this.selectGlslLibRoutinesToBeIncluded(e);if(r.length===0)return"";let o="";for(let s=0;s<r.length;++s)if(r[s].routineBody)o+=r[s].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${r[s].name}`);return o}selectGlslLibRoutinesToBeIncluded(e){let r=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(o=>{let s=o.split(".")[1];e.indexOf(s)!==-1&&r.push(this.glslLibRoutineDependencyGraph[o])}),Ll.returnOrderedNodes(r)}getUniforms(e,r){let o=[];if(e)for(let s of e)o.push(`uniform sampler2D ${s};`);if(r)for(let s of r)o.push(`uniform ${s.type} ${s.name}${s.arrayLength?`[${s.arrayLength}]`:""};`);return o.join(`
`)}}}),Jc,Wg=I(()=>{"use strict";ze(),Re(),qg(),Y(),Jc=class{constructor(e,r,o){this.profiler=e,this.glContext=r,this.textureLayoutStrategy=o,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,r){this.repo.set(e,r)}run(e,r,o){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let s=this.glContext.gl,p=e.program;s.useProgram(p);try{this.bindOutput(o),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],r)}catch(l){throw ee.error("ProgramManager",e.programInfo.shaderSource),l}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,r,o){return this.profiler.event("backend","ProgramManager.build",()=>{let s=new Zc(this.glContext,e,r,o),p=s.preprocess(),l=this.compile(p);return{programInfo:e,program:l,uniformLocations:this.getUniformLocations(l,s.context.programInfo.inputNames,s.context.programInfo.variables),attribLocations:this.getAttribLocations(l)}})}compile(e){if(!this.vertexShader){ee.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let s=rf(this.glContext.version);this.vertexShader=this.glContext.compileShader(s,this.glContext.gl.VERTEX_SHADER)}j.debug&&ee.verbose("ProrgramManager",`FragShader:
${e}
`);let r=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),o=this.glContext.createProgram(this.vertexShader,r);return this.glContext.deleteShader(r),o}bindOutput(e){let r=e.width,o=e.height;ee.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${r}/${o}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,r,o)}bindAttributes(e){let r=e.position,o=e.textureCoord;this.glContext.setVertexAttributes(r,o),this.attributesBound=!0}bindUniforms(e,r,o){let s=this.glContext.gl,p=0;for(let{name:l,type:c,location:n,arrayLength:a}of e){let t=r.find(u=>u.name===l)?.data;if(c!=="sampler2D"&&!t)throw new Error(`variable '${l}' does not have data defined in program info`);switch(c){case"sampler2D":this.bindTexture(o[p],n,p),p++;break;case"float":a?s.uniform1fv(n,t):s.uniform1f(n,t);break;case"int":a?s.uniform1iv(n,t):s.uniform1i(n,t);break;default:throw new Error(`Uniform not implemented: ${c}`)}}}bindTexture(e,r,o){this.glContext.bindTextureToUniform(e.texture,o,r)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,r,o){let s=[];if(r)for(let p of r)s.push({name:p,type:"sampler2D",location:this.getUniformLocation(e,p)});if(o)for(let p of o)s.push({...p,location:this.getUniformLocation(e,p.name)});return s}getUniformLocation(e,r){let o=this.glContext.gl.getUniformLocation(e,r);if(o===null)throw new Error(`Uniform ${r} not found.`);return o}getAttribLocation(e,r){return this.glContext.gl.getAttribLocation(e,r)}}}),Yc,Xg=I(()=>{"use strict";Re(),Wr(),Yc=class{constructor(e,r,o,s){this.glContext=e,this.layoutStrategy=r,this.profiler=o,this.config=s,this.pendingRead=new Map,s.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,r,o,s){let p=this.toEncoderType(e),l=this.glContext.getEncoder(p,r.channels||1,s);if(r.isPacked&&s===1)throw new Error("not implemented");let c=r.width,n=r.height,a,t;if(this.config.reuseTextures){a=`${c}x${n}_${l.format}_${l.internalFormat}_${l.textureType}`,t=this.inUseTextures.get(a),t||(t=[],this.inUseTextures.set(a,t));let i=this.idleTextures.get(a);if(i&&i.length>0){let d=i.pop();return t.push(d),s===1&&this.glContext.updateTexture(d,c,n,l,this.toTextureData(e,o)),d}}ee.verbose("TextureManager",`Creating new texture of size ${r.width}x${r.height}`);let u=this.glContext.allocateTexture(c,n,l,this.toTextureData(e,o));return this.config.reuseTextures&&(t.push(u),this.textureLookup.set(u,a)),u}readTexture(e,r,o){return o||(o=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let s=e.shape.reduce((l,c)=>l*c)*o,p=this.glContext.readTexture(e.texture,e.width,e.height,s,this.toEncoderType(r),o);return this.toTensorData(r,p)})}async readTextureAsync(e,r,o){let s=e.tensor.dataId;if(o||(o=1),this.pendingRead.has(s)){let p=this.pendingRead.get(s);return new Promise(l=>p?.push(l))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(s,[]);let p=e.shape.reduce((a,t)=>a*t)*o;await this.glContext.createAndWaitForFence();let l=this.glContext.readTexture(e.texture,e.width,e.height,p,this.toEncoderType(r),o),c=this.toTensorData(r,l),n=this.pendingRead.get(s);return this.pendingRead.delete(s),n?.forEach(a=>a(c)),c})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let r=e.shape.reduce((s,p)=>s*p),o=this.glContext.readTexture(e.texture,e.width,e.height,r*4,"byte",4);return new Float32Array(o.buffer,o.byteOffset,r)})}releaseTexture(e,r){let o;if(this.config.reuseTextures&&(o=this.textureLookup.get(e.texture),o)){r&&this.textureLookup.delete(o);let s=this.inUseTextures.get(o);if(s){let p=s.indexOf(e.texture);if(p!==-1){s.splice(p,1);let l=this.idleTextures.get(o);l||(l=[],this.idleTextures.set(o,l)),l.push(e.texture)}}}(!o||r)&&(ee.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,r){switch(e){case"int16":return r instanceof Int16Array?r:Int16Array.from(r);case"int32":return r instanceof Int32Array?r:Int32Array.from(r);case"int8":return r instanceof Int8Array?r:Int8Array.from(r);case"uint16":return r instanceof Uint16Array?r:Uint16Array.from(r);case"uint32":return r instanceof Uint32Array?r:Uint32Array.from(r);case"uint8":case"bool":return r instanceof Uint8Array?r:Uint8Array.from(r);case"float32":return r instanceof Float32Array?r:Float32Array.from(r);case"float64":return r instanceof Float64Array?r:Float64Array.from(r);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,r){if(r)return r instanceof Float32Array?r:new Float32Array(r)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),Qc,Kg=I(()=>{"use strict";Re(),Rh(),vf(),Fg(),Wg(),Gc(),Xg(),Qc=class{constructor(e,r){this.backend=e,this.context=r,this.layoutStrategy=new Uc(e.glContext.maxTextureSize),this.programManager=new Jc(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new Yc(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Nl(this)}onGraphInitialized(e){let r=e.getValues().filter(o=>o.from===-1&&o.tensor).map(o=>o.tensor.dataId);this.initializers=new Set(r)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,r){return r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,o=!1){ee.verbose("WebGLSessionHandler","Storing Texture data in cache"),o?this.packedTextureDataCache.set(e,r):this.unpackedTextureDataCache.set(e,r)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,r,o){let s=Ch(e,r,Mc);return{impl:s.opImpl,context:s.opInit?s.opInit(e,o):e}}}});function Zg(e){let r=0;for(;r<e.length&&e[r]();++r);return r-1}var Bo,Jg=I(()=>{"use strict";ze(),Wr(),Wr(),qe(),Bo=class{constructor(e,r){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=r,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,r,o,s){let p=this.gl,l=p.createTexture();p.bindTexture(p.TEXTURE_2D,l),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MIN_FILTER,p.NEAREST),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MAG_FILTER,p.NEAREST),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_S,p.CLAMP_TO_EDGE),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_T,p.CLAMP_TO_EDGE);let c=s?o.encode(s,e*r):null;return p.texImage2D(p.TEXTURE_2D,0,o.internalFormat,e,r,0,o.format,o.textureType,c),this.checkError(),l}updateTexture(e,r,o,s,p){let l=this.gl;l.bindTexture(l.TEXTURE_2D,e);let c=s.encode(p,r*o);l.texSubImage2D(l.TEXTURE_2D,0,0,0,r,o,s.format,s.textureType,c),this.checkError()}attachFramebuffer(e,r,o){let s=this.gl;s.bindTexture(s.TEXTURE_2D,e),s.bindFramebuffer(s.FRAMEBUFFER,this.framebuffer),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0),this.checkError(),s.viewport(0,0,r,o),s.scissor(0,0,r,o)}readTexture(e,r,o,s,p,l){let c=this.gl;l||(l=1),this.frameBufferBound||this.attachFramebuffer(e,r,o);let n=this.getEncoder(p,l),a=n.allocate(r*o);return c.bindTexture(c.TEXTURE_2D,e),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,e,0),c.readPixels(0,0,r,o,c.RGBA,n.textureType,a),this.checkError(),n.decode(a,s)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,r){let o=this.gl;o.vertexAttribPointer(e,3,o.FLOAT,!1,20,0),o.enableVertexAttribArray(e),r!==-1&&(o.vertexAttribPointer(r,2,o.FLOAT,!1,20,12),o.enableVertexAttribArray(r)),this.checkError()}createProgram(e,r){let o=this.gl,s=o.createProgram();return o.attachShader(s,e),o.attachShader(s,r),o.linkProgram(s),s}compileShader(e,r){let o=this.gl,s=o.createShader(r);if(!s)throw new Error(`createShader() returned null with type ${r}`);if(o.shaderSource(s,e),o.compileShader(s),o.getShaderParameter(s,o.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${o.getShaderInfoLog(s)}
Shader source:
${e}`);return s}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,r,o){let s=this.gl;s.activeTexture(s.TEXTURE0+r),this.checkError(),s.bindTexture(s.TEXTURE_2D,e),this.checkError(),s.uniform1i(o,r),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(j.debug){let e=this.gl,r=e.getError(),o="";switch(r){case e.NO_ERROR:return;case e.INVALID_ENUM:o="INVALID_ENUM";break;case e.INVALID_VALUE:o="INVALID_VALUE";break;case e.INVALID_OPERATION:o="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:o="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:o="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:o="CONTEXT_LOST_WEBGL";break;default:o=`Unknown WebGL Error: ${r.toString(16)}`}throw new Error(o)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,r,o=0){if(this.version===2)return new Al(this.gl,r);switch(e){case"float":return o===1||this.isRenderFloat32Supported?new xo(this.gl,r):new xo(this.gl,r,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new $l(this.gl,r);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let r=0;r<this.maxTextureImageUnits;++r)e.activeTexture(e.TEXTURE0+r),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,r=e.createBuffer();if(!r)throw new Error("createBuffer() returned null");let o=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,o,e.STATIC_DRAW),this.checkError(),r}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let o=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,o,1,1,0,e.RGBA,e.FLOAT,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let p=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),p}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,r,o,s,p,l;try{r=e.createTexture(),o=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,r);let c=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,c,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0),e.enable(e.BLEND),s=e.createShader(e.VERTEX_SHADER),!s||(e.shaderSource(s,"void main(){}"),e.compileShader(s),p=e.createShader(e.FRAGMENT_SHADER),!p)||(e.shaderSource(p,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(p),l=e.createProgram(),!l)?!1:(e.attachShader(l,s),e.attachShader(l,p),e.linkProgram(l),e.useProgram(l),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),l&&e.deleteProgram(l),s&&e.deleteShader(s),p&&e.deleteShader(p),o&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(o)),r&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(r))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension,o=e.createQuery();return e.beginQuery(r.TIME_ELAPSED_EXT,o),o}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension;e.endQuery(r.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let r=!1,o=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let s=this.gl,p=this.disjointTimerQueryWebgl2Extension;r=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE),o=s.getParameter(p.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return r&&!o}getTimerResult(e){let r=0;if(this.version===2){let o=this.gl;r=o.getQueryParameter(e,o.QUERY_RESULT),o.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return r/1e6}async waitForQueryAndGetTime(e){return await Ia(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let r,o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),s===null?r=()=>!0:r=()=>{let p=o.clientWaitSync(s,0,0);return p===o.ALREADY_SIGNALED||p===o.CONDITION_SATISFIED},{query:s,isFencePassed:r}}async pollFence(e){return new Promise(r=>{this.addItemToPoll(()=>e.isFencePassed(),()=>r())})}pollItems(){let e=Zg(this.itemsToPoll.map(r=>r.isDoneFn));for(let r=0;r<=e;++r){let{resolveFn:o}=this.itemsToPoll[r];o()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,r){this.itemsToPoll.push({isDoneFn:e,resolveFn:r}),!(this.itemsToPoll.length>1)&&await Ia(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function ed(e){let r;if((!e||e==="webgl2")&&"webgl2"in gt?r=gt.webgl2:(!e||e==="webgl")&&"webgl"in gt&&(r=gt.webgl),!r)try{let s=Qg();r=$u(s,e)}catch{let s=Yg();r=$u(s,e)}e=e||r.version===1?"webgl":"webgl2";let o=r.gl;return gt[e]=r,o.isContextLost()?(delete gt[e],ed(e)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),r)}function $u(e,r){let o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},s,p=o;if((!r||r==="webgl2")&&(s=e.getContext("webgl2",p),s))try{return new Bo(s,2)}catch(l){ee.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${l}`)}if((!r||r==="webgl")&&(s=e.getContext("webgl",p)||e.getContext("experimental-webgl",p),s))try{return new Bo(s,1)}catch(l){ee.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${l}`)}throw new Error("WebGL is not supported")}function Yg(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let e=document.createElement("canvas");return e.width=1,e.height=1,e}function Qg(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var gt,em=I(()=>{"use strict";Re(),Jg(),gt={}}),td,tm=I(()=>{"use strict";ze(),Re(),Kg(),em(),td=class{get contextId(){return j.webgl.contextId}set contextId(e){j.webgl.contextId=e}get matmulMaxBatchSize(){return j.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){j.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return j.webgl.textureCacheMode}set textureCacheMode(e){j.webgl.textureCacheMode=e}get pack(){return j.webgl.pack}set pack(e){j.webgl.pack=e}get async(){return j.webgl.async}set async(e){j.webgl.async=e}initialize(){try{return this.glContext=ed(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),ee.setWithEnv(j),j.webgl.context||Object.defineProperty(j.webgl,"context",{value:this.glContext.gl}),ee.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return ee.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new Qc(this,e)}dispose(){this.glContext.dispose()}}});async function rd(e){if(e){let r=typeof e=="string"?[e]:e;for(let o of r){let s=ri.get(o);if(s)return s;let p=await rm(o);if(p)return p}}else return rd(["webgl"]);throw new Error("no available backend to use")}async function rm(e){let r=nd;if(typeof r[e]<"u"&&nm(r[e])){let o=r[e],s=o.initialize();if(typeof s=="object"&&"then"in s&&(s=await s),s)return ri.set(e,o),o}}function nm(e){let r=e;return"initialize"in r&&typeof r.initialize=="function"&&"createSessionHandler"in r&&typeof r.createSessionHandler=="function"&&"dispose"in r&&typeof r.dispose=="function"}var ri,nd,om=I(()=>{"use strict";tm(),ri=new Map,nd={webgl:new td}}),Du,od,im=I(()=>{"use strict";Re(),Du=class{constructor(e,r){this.op=e,this.node=r}},od=class{constructor(e,r,o){this.graph=e,this.profiler=o,this.initialize(r)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let r=this.graph.getNodes();if(r.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((o,s)=>new Du(o,r[s])),this.reset(),this._starter=[],this._ops.forEach((o,s)=>{let p=!0;for(let l of o.node.inputs)if(!this._values[l]&&this.graph.getInputIndices().indexOf(l)===-1){p=!1;break}p&&this._starter.push(s)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,r){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let o=e.createInferenceHandler(),s=this.graph.getInputIndices();if(r.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${r.length} expected: ${s.length}`);r.forEach((t,u)=>{let i=s[u];this._values[i]=t});let p=this._starter.slice(0),l=this.graph.getValues(),c=this.graph.getNodes(),n=0;for(;n<p.length;){let t=p[n++],u=this._ops[t],i=u.node.inputs.map(b=>this._values[b]);if(i.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${u.node}`);let d=i;ee.verbose("ExecPlan",`Running op:${u.node.name} (${d.map((b,x)=>`'${u.node.inputs[x]}': ${b.type}[${b.dims.join(",")}]`).join(", ")})`);let h=await this.profiler.event("node",u.node.name,async()=>u.op.impl(o,d,u.op.context));if(h.length!==u.node.outputs.length)throw new Error("the size of output does not match model definition.");h.forEach((b,x)=>{let E=u.node.outputs[x];if(this._values[E])throw new Error(`output [${E}] already has value: op:${u.node.name}`);this._values[E]=b});let m=new Set;h.forEach((b,x)=>{let E=u.node.outputs[x];for(let w of l[E].to){let S=c[w],$=!0;for(let F of S.inputs)if(!this._values[F]){$=!1;break}$&&m.add(w)}}),p.push(...m)}let a=[];for(let t=0;t<this.graph.getOutputIndices().length;t++){let u=this.graph.getOutputIndices()[t],i=this._values[u];if(i===void 0)throw new Error(`required output [${u}] does not have value`);u===0?await i.getData():i.data,a.push(i)}return ee.verbose("ExecPlan","disposing of inferenceHandler"),o.dispose(),a})}}}),R,Oe,Vo,am=I(()=>{"use strict";Qr(),R=It(br()),Dt(),U(),Oe=H.experimental.fbs,Vo=class ir{constructor(r){if(this._attributes=new Map,r!=null){for(let o of r)o instanceof R.onnx.AttributeProto?this._attributes.set(o.name,[ir.getValue(o),ir.getType(o)]):o instanceof Oe.Attribute&&this._attributes.set(o.name(),[ir.getValue(o),ir.getType(o)]);if(this._attributes.size<r.length)throw new Error("duplicated attribute names")}}set(r,o,s){this._attributes.set(r,[s,o])}delete(r){this._attributes.delete(r)}getFloat(r,o){return this.get(r,"float",o)}getInt(r,o){return this.get(r,"int",o)}getString(r,o){return this.get(r,"string",o)}getTensor(r,o){return this.get(r,"tensor",o)}getFloats(r,o){return this.get(r,"floats",o)}getInts(r,o){return this.get(r,"ints",o)}getStrings(r,o){return this.get(r,"strings",o)}getTensors(r,o){return this.get(r,"tensors",o)}get(r,o,s){let p=this._attributes.get(r);if(p===void 0){if(s!==void 0)return s;throw new Error(`required attribute not found: ${r}`)}if(p[1]!==o)throw new Error(`type mismatch: expected ${o} but got ${p[1]}`);return p[0]}static getType(r){let o=r instanceof R.onnx.AttributeProto?r.type:r.type();switch(o){case R.onnx.AttributeProto.AttributeType.FLOAT:return"float";case R.onnx.AttributeProto.AttributeType.INT:return"int";case R.onnx.AttributeProto.AttributeType.STRING:return"string";case R.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case R.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case R.onnx.AttributeProto.AttributeType.INTS:return"ints";case R.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case R.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${R.onnx.AttributeProto.AttributeType[o]}`)}}static getValue(r){let o=r instanceof R.onnx.AttributeProto?r.type:r.type();if(o===R.onnx.AttributeProto.AttributeType.GRAPH||o===R.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let s=this.getValueNoCheck(r);if(o===R.onnx.AttributeProto.AttributeType.INT&&Ve.isLong(s))return Ve.longToNumber(s);if(o===R.onnx.AttributeProto.AttributeType.INTS){let p=s,l=new Array(p.length);for(let c=0;c<p.length;c++){let n=p[c];l[c]=Ve.longToNumber(n)}return l}if(o===R.onnx.AttributeProto.AttributeType.TENSOR)return r instanceof R.onnx.AttributeProto?Pe.fromProto(s):Pe.fromOrtTensor(s);if(o===R.onnx.AttributeProto.AttributeType.TENSORS){if(r instanceof R.onnx.AttributeProto)return s.map(p=>Pe.fromProto(p));if(r instanceof Oe.Attribute)return s.map(p=>Pe.fromOrtTensor(p))}return o===R.onnx.AttributeProto.AttributeType.STRING&&r instanceof R.onnx.AttributeProto?mo(s):o===R.onnx.AttributeProto.AttributeType.STRINGS&&r instanceof R.onnx.AttributeProto?s.map(mo):s}static getValueNoCheck(r){return r instanceof R.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(r):this.getValueNoCheckFromOrtFormat(r)}static getValueNoCheckFromOnnxFormat(r){switch(r.type){case R.onnx.AttributeProto.AttributeType.FLOAT:return r.f;case R.onnx.AttributeProto.AttributeType.INT:return r.i;case R.onnx.AttributeProto.AttributeType.STRING:return r.s;case R.onnx.AttributeProto.AttributeType.TENSOR:return r.t;case R.onnx.AttributeProto.AttributeType.GRAPH:return r.g;case R.onnx.AttributeProto.AttributeType.FLOATS:return r.floats;case R.onnx.AttributeProto.AttributeType.INTS:return r.ints;case R.onnx.AttributeProto.AttributeType.STRINGS:return r.strings;case R.onnx.AttributeProto.AttributeType.TENSORS:return r.tensors;case R.onnx.AttributeProto.AttributeType.GRAPHS:return r.graphs;default:throw new Error(`unsupported attribute type: ${R.onnx.AttributeProto.AttributeType[r.type]}`)}}static getValueNoCheckFromOrtFormat(r){switch(r.type()){case Oe.AttributeType.FLOAT:return r.f();case Oe.AttributeType.INT:return r.i();case Oe.AttributeType.STRING:return r.s();case Oe.AttributeType.TENSOR:return r.t();case Oe.AttributeType.GRAPH:return r.g();case Oe.AttributeType.FLOATS:return r.floatsArray();case Oe.AttributeType.INTS:{let o=[];for(let s=0;s<r.intsLength();s++)o.push(r.ints(s));return o}case Oe.AttributeType.STRINGS:{let o=[];for(let s=0;s<r.stringsLength();s++)o.push(r.strings(s));return o}case Oe.AttributeType.TENSORS:{let o=[];for(let s=0;s<r.tensorsLength();s++)o.push(r.tensors(s));return o}default:throw new Error(`unsupported attribute type: ${Oe.AttributeType[r.type()]}`)}}}}),Kn,Kt,Mo,He,Zn,Nu,sm=I(()=>{"use strict";am(),Qr(),Kn=It(br()),Dt(),U(),Kt=H.experimental.fbs,Mo={from:(e,r)=>new Nu(e,r)},He=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=Ee.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},Zn=class{constructor(e,r){e instanceof Kn.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new Vo(e.attribute)):e instanceof Kt.Node&&(this.name=r??e.name(),this.opType=e.opType(),this.attributes=new Vo(Ee.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Nu=class{constructor(e,r){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof Kn.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof Kt.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let o=new Map;if(!e.input)throw new Error("missing information in graph: input");let s=[];for(let p of e.input){if(r.has(p.name))throw new Error(`duplicated input name: ${p.name}`);let l=this._allData.push(new He(p))-1;r.set(p.name,l),s.push(p.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let p of e.initializer){let l=r.get(p.name);if(l===void 0){let c=new He;c.type={shape:{dims:Ee.tensorDimsFromProto(p.dims)},tensorType:Ee.tensorDataTypeFromProto(p.dataType)},l=this._allData.push(c)-1,r.set(p.name,l)}this._allData[l]._from=-1,this._allData[l].tensor=Pe.fromProto(p)}for(let p=0;p<this._allData.length;p++)this._allData[p].tensor||(this._allInputIndices.push(p),this._allInputNames.push(s[p]));if(!e.output)throw new Error("missing information in graph: output");for(let p of e.output){if(r.has(p.name))throw new Error(`duplicated output name: ${p.name}`);let l=this._allData.push(new He(p))-1;r.set(p.name,l),this._allOutputIndices.push(l),this._allOutputNames.push(p.name)}if(!e.node)throw new Error("missing information in graph: node");for(let p of e.node){if(!p.name)for(let c=0;;c++){let n=`unnamed_${p.opType}_${c}`;if(!o.has(n)){p.name=n;break}}if(o.has(p.name))throw new Error(`duplicated node name: ${p.name}`);let l=this._nodes.push(new Zn(p))-1;o.set(p.name,l)}for(let p=0;p<this._nodes.length;p++){let l=this._nodes[p],c=e.node[p];if(!c.output)throw new Error(`missing output for node: ${c.name}`);for(let n of c.output){let a=r.get(n);if(typeof a>"u"&&(a=this._allData.push(new He)-1,r.set(n,a)),l.outputs.push(a),this._allData[a]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${a}`);if(this._allData[a]._from=p,c.opType==="Constant"){if(!c.attribute||c.attribute.length!==1||!c.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!c.output||c.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");l.outputs.pop(),l.executeNode=!1,this._allData[a]._from=-1,this._allData[a].tensor=Pe.fromProto(c.attribute[0].t)}}}for(let p=0;p<this._nodes.length;p++){let l=this._nodes[p],c=e.node[p];if(!c.input)throw new Error(`missing input for node: ${c.name}`);for(let n of c.input){let a=r.get(n);if(typeof a>"u"){if(n===""&&(c.input.length===3||c.input.length===4)&&c.opType==="Resize")continue;throw new Error(`unrecognized input '${n}' for node: ${c.name}`)}l.inputs.push(a),this._allData[a]._to.push(p)}}return!0}buildGraphFromOrtFormat(e){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let o=new Map,s=[];for(let p=0;p<e.inputsLength();p++){let l=e.inputs(p);if(r.has(l))throw new Error(`duplicated input name: ${l}`);for(let c=0;c<e.nodeArgsLength();c++)if(e.nodeArgs(c)?.name()===l){let n=new He;if(e.nodeArgs(c)?.type()?.valueType()!==Kt.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let a=e.nodeArgs(c).type().value(new Kt.TensorTypeAndShape),t=Ee.tensorDataTypeFromProto(a.elemType()),u=a.shape(),i=[];for(let h=0;h<u.dimLength();h++)i.push(Ve.longToNumber(u.dim(h).value().dimValue()));n.type={shape:{dims:i},tensorType:t};let d=this._allData.push(n)-1;r.set(l,d),s.push(l)}}for(let p=0;p<e.initializersLength();p++){let l=e.initializers(p),c=r.get(l.name());if(c===void 0){let n=new He,a=Ee.tensorDimsFromORTFormat(l),t=Ee.tensorDataTypeFromProto(l.dataType());n.type={shape:{dims:a},tensorType:t},c=this._allData.push(n)-1,r.set(l.name(),c)}this._allData[c]._from=-1,this._allData[c].tensor=Pe.fromOrtTensor(l)}for(let p=0;p<this._allData.length;p++)this._allData[p].tensor||(this._allInputIndices.push(p),this._allInputNames.push(s[p]));for(let p=0;p<e.outputsLength();p++){let l=e.outputs(p);if(r.has(l))throw new Error(`duplicated output name: ${l}`);let c=this._allData.push(new He)-1;r.set(l,c),this._allOutputIndices.push(c),this._allOutputNames.push(l)}if(!e.nodes)throw new Error("missing information in graph: node");for(let p=0;p<e.nodesLength();p++){let l=e.nodes(p),c=l.name();if(!c)for(let a=0;c=`unnamed_${l.opType()}_${a}`,!!o.has(c);a++);if(o.has(c))throw new Error(`duplicated node name: ${c}`);let n=this._nodes.push(new Zn(l,c))-1;o.set(c,n)}for(let p=0;p<this._nodes.length;p++){let l=this._nodes[p],c=e.nodes(p);if(c==null)throw new Error(`No node exists at index ${p}`);if(c?.outputsLength()===0)throw new Error(`missing output for node: ${c.name}`);for(let n=0;n<c?.outputsLength();n++){let a=c?.outputs(n),t=r.get(a);if(typeof t>"u"&&(t=this._allData.push(new He)-1,r.set(a,t)),l.outputs.push(t),this._allData[t]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${t}`);if(this._allData[t]._from=p,c.opType()==="Constant"){if(c.attributesLength()!==1||!c.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(c.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");l.outputs.pop(),l.executeNode=!1,this._allData[t]._from=-1,this._allData[t].tensor=Pe.fromOrtTensor(c.attributes(0).t())}}}for(let p=0;p<this._nodes.length;p++){let l=this._nodes[p],c=e.nodes(p);if(c.inputsLength()===0)throw new Error(`missing input for node: ${c.name}`);for(let n=0;n<c.inputsLength();n++){let a=c.inputs(n),t=r.get(a);if(typeof t>"u")throw new Error(`unrecognized input '${a}' for node: ${c.name()}`);l.inputs.push(t),this._allData[t]._to.push(p)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(s=>{this._allData[s]._to.forEach(p=>{e.add(p)})});let r=Array.from(e),o=new Array(this._nodes.length).fill("white");for(;r.length>0;){let s=r.pop();o[s]==="gray"?o[s]="black":(r.push(s),o[s]="gray",this._nodes[s].outputs.forEach(p=>{let l=this._allData[p];if(typeof l.tensor<"u")throw new Error("node outputs should not be initialized");if(l._from!==s)throw new Error("from property of the Value object doesn't match index of Node being processed");l._to.forEach(c=>{if(o[c]==="gray")throw new Error("model graph is cyclic");o[c]==="white"&&r.push(c)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,r=new Array(this._nodes.length,0),o=0;for(let s=0;s<this._nodes.length;s++)r[s]=o,this._nodes[s].executeNode?(o!==s&&(this._nodes[o]=this._nodes[s]),o++):this._nodes[s].outputs.forEach(p=>{this._allData[p]._from=-2});this._nodes.splice(o,this._nodes.length-o);for(let s=0;s<this._allData.length;s++){let p=this._allData[s];p._from!==void 0&&p._from!==-1&&p._from!==-2&&(p._from=r[p._from]);for(let l=0;l<p._to.length;l++)if(p._to[l]>=0)p._to[l]=r[p._to[l]];else throw new Error("Trying to update a removed node")}e=0;for(let s=0;s<this._allData.length;s++){if(this._allData[s].from===-2&&this._allOutputIndices.indexOf(s+e)===-1){e++,this._allData.splice(s,1),s--;continue}if(e>0){let p=-1;this._allData[s].from!==void 0&&this._allData[s].from!==-1?(p=this._nodes[this._allData[s].from].outputs.indexOf(s+e),p!==-1&&(this._nodes[this._allData[s].from].outputs[p]=s)):(p=this._allInputIndices.indexOf(s+e),p!==-1&&(this._allInputIndices[p]=s)),this._allData[s].to.forEach(l=>{p=this._nodes[l].inputs.indexOf(s+e),p!==-1&&(this._nodes[l].inputs[p]=s)}),this._allData[s].to.length===0&&(p=this._allOutputIndices.indexOf(s+e),p!==-1&&(this._allOutputIndices[p]=s))}}}deleteNode(e){let r=this._nodes[e];if(r.outputs.length>1){for(let c=1;c<r.outputs.length;c++)if(this._allData[r.outputs[c]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let o=r.inputs[0],s=r.outputs[0],p=this._allData[s].to;for(let c=0;c<r.inputs.length;c++){let n=this._allData[r.inputs[c]].to.indexOf(e);if(n===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[c]].to.splice(n,1)}this._allData[s]._to=[];let l=this._allOutputIndices.indexOf(s);if(l!==-1&&(this._allOutputIndices[l]=o),p&&p.length>0)for(let c of p){let n=this._nodes[c].inputs.indexOf(s);if(n===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[c].inputs[n]=o,this._allData[o].to.push(c)}}removeAllDropoutNodes(){let e=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let r=this._allData[e.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let o=this._nodes[r[0]];if(o.opType==="Clip")if(o.inputs.length===1)try{e.attributes.set("activation_params","floats",[o.attributes.getFloat("min"),o.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[hr,fr])}else if(o.inputs.length>=3&&this._allData[o.inputs[1]].tensor!==void 0&&this._allData[o.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[o.inputs[1]].tensor.floatData[0],this._allData[o.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",o.opType),this.deleteNode(r[0])}}}}}),ku,Fu,id,um=I(()=>{"use strict";Ko(),sm(),Qr(),ku=It(br()),U(),Fu=H.experimental.fbs,id=class{constructor(){}load(e,r,o){let s;if(!o)try{this.loadFromOnnxFormat(e,r);return}catch(p){if(o!==void 0)throw p;s=p}try{this.loadFromOrtFormat(e,r)}catch(p){throw o!==void 0?p:new Error(`Failed to load model as ONNX format: ${s}
as ORT format: ${p}`)}}loadFromOnnxFormat(e,r){let o=ku.onnx.ModelProto.decode(e);if(Ve.longToNumber(o.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=o.opsetImport.map(s=>({domain:s.domain,version:Ve.longToNumber(s.version)})),this._graph=Mo.from(o.graph,r)}loadFromOrtFormat(e,r){let o=new T.ByteBuffer(e),s=Fu.InferenceSession.getRootAsInferenceSession(o).model();if(Ve.longToNumber(s.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let p=0;p<s.opsetImportLength();p++){let l=s.opsetImport(p);this._opsets.push({domain:l?.domain(),version:Ve.longToNumber(l.version())})}this._graph=Mo.from(s.graph(),r)}get graph(){return this._graph}get opsets(){return this._opsets}}}),ad,lm=I(()=>{"use strict";om(),im(),Re(),um(),ad=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=bl.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,r,o){await this.profiler.event("session","Session.loadModel",async()=>{let s=await rd(this.backendHint);if(this.sessionHandler=s.createSessionHandler(this.context),this._model=new id,typeof e=="string"){let p=e.endsWith(".ort");{let l=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(l),p)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let p=new Uint8Array(e,r||0,o||e.byteLength);this.initialize(p)}})}initialize(e,r){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let o=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,o,r),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new od(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let r=this.normalizeAndValidateInputs(e),o=await this._executionPlan.execute(this.sessionHandler,r);return this.createOutput(o)})}normalizeAndValidateInputs(e){let r=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==r.length)throw new Error(`incorrect input array length: expected ${r.length} but got ${e.length}`)}else{if(e.size!==r.length)throw new Error(`incorrect input map size: expected ${r.length} but got ${e.size}`);let o=new Array(e.size),s=0;for(let p=0;p<r.length;++p){let l=e.get(r[p]);if(!l)throw new Error(`missing input tensor for: '${name}'`);o[s++]=l}e=o}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let o=this._model.graph.getInputIndices(),s=this._model.graph.getValues(),p=new Array(o.length);for(let l=0;l<o.length;++l){let c=s[o[l]];p[l]=c.type.shape.dims,this.context.graphInputTypes.push(c.type.tensorType),this.context.graphInputDims.push(e[l].dims)}this.validateInputTensorDims(p,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,r){for(let o=0;o<r.length;o++){let s=e[o],p=r[o].type;if(s!==p)throw new Error(`input tensor[${o}] check failed: expected type '${s}' but got ${p}`)}}validateInputTensorDims(e,r,o){for(let s=0;s<r.length;s++){let p=e[s],l=r[s].dims;if(!this.compareTensorDims(p,l,o))throw new Error(`input tensor[${s}] check failed: expected shape '[${p.join(",")}]' but got [${l.join(",")}]`)}}compareTensorDims(e,r,o){if(e.length!==r.length)return!1;for(let s=0;s<e.length;++s)if(e[s]!==r[s]&&(!o||e[s]!==0))return!1;return!0}createOutput(e){let r=this._model.graph.getOutputNames();if(e.length!==r.length)throw new Error("expected number of outputs do not match number of generated outputs");let o=new Map;for(let s=0;s<r.length;++s)o.set(r[s],e[s]);return o}initializeOps(e){let r=e.getNodes();this._ops=new Array(r.length);for(let o=0;o<r.length;o++)this._ops[o]=this.sessionHandler.resolve(r[o],this._model.opsets,e)}}}),sd,pm=I(()=>{"use strict";ze(),Dt(),sd=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,r,o){let s=new Map;for(let c in e)if(Object.hasOwnProperty.call(e,c)){let n=e[c];s.set(c,new Pe(n.dims,n.type,void 0,void 0,n.data))}let p=await this.session.run(s),l={};return p.forEach((c,n)=>{l[n]=new fe(c.type,c.data,c.dims)}),l}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),ud={};mr(ud,{onnxjsBackend:()=>ld});var Cu,ld,cm=I(()=>{"use strict";lm(),pm(),Cu=class{async init(){}async createInferenceSessionHandler(e,r){let o=new ad(r);return typeof e=="string"?await o.loadModel(e):await o.loadModel(e),new sd(o)}},ld=new Cu}),ni=I(()=>{"use strict"}),pd={};mr(pd,{default:()=>cd});var Jn,Yn,cd,dm=I(()=>{"use strict";Sd(),Ct(),rn(),Jn="ort-wasm-proxy-worker",Yn=globalThis.self?.name===Jn,Yn&&(self.onmessage=e=>{let{type:r,in:o}=e.data;try{switch(r){case"init-wasm":oi(o.wasm).then(()=>{li(o).then(()=>{postMessage({type:r})},s=>{postMessage({type:r,err:s})})},s=>{postMessage({type:r,err:s})});break;case"init-ep":{let{epName:s,env:p}=o;pi(p,s).then(()=>{postMessage({type:r})},l=>{postMessage({type:r,err:l})});break}case"copy-from":{let{buffer:s}=o,p=Zr(s);postMessage({type:r,out:p});break}case"create":{let{model:s,options:p}=o;ci(s,p).then(l=>{postMessage({type:r,out:l})},l=>{postMessage({type:r,err:l})});break}case"release":di(o),postMessage({type:r});break;case"run":{let{sessionId:s,inputIndices:p,inputs:l,outputIndices:c,options:n}=o;hi(s,p,l,c,new Array(c.length).fill(null),n).then(a=>{a.some(t=>t[3]!=="cpu")?postMessage({type:r,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:r,out:a},gi([...l,...a]))},a=>{postMessage({type:r,err:a})});break}case"end-profiling":fi(o),postMessage({type:r});break;default:}}catch(s){postMessage({type:r,err:s})}}),cd=Yn?null:e=>new Worker(e??Ot,{type:"module",name:Jn})}),dd={};mr(dd,{default:()=>hd});var Qn,eo,hd,hm=I(()=>{"use strict";eo=(Qn=Ur.url,async function(e={}){function r(){return ye.buffer!=we.buffer&&ie(),we}function o(){return ye.buffer!=we.buffer&&ie(),G}function s(){return ye.buffer!=we.buffer&&ie(),We}function p(){return ye.buffer!=we.buffer&&ie(),_r}function l(){return ye.buffer!=we.buffer&&ie(),vt}var c,n,a=Object.assign({},e),t=new Promise((f,g)=>{c=f,n=g}),u=typeof window=="object",i=typeof importScripts=="function",d=i&&self.name=="em-pthread";a.mountExternalData=(f,g)=>{f.startsWith("./")&&(f=f.substring(2)),(a.Ua||(a.Ua=new Map)).set(f,g)},a.unmountExternalData=()=>{delete a.Ua};var h,m,b=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor,x=Object.assign({},a),E="./this.program",w=(f,g)=>{throw g},S="";(u||i)&&(i?S=self.location.href:typeof document<"u"&&document.currentScript&&(S=document.currentScript.src),Qn&&(S=Qn),S=S.startsWith("blob:")?"":S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1),i&&(m=f=>{var g=new XMLHttpRequest;return g.open("GET",f,!1),g.responseType="arraybuffer",g.send(null),new Uint8Array(g.response)}),h=(f,g,y)=>{var v=new XMLHttpRequest;v.open("GET",f,!0),v.responseType="arraybuffer",v.onload=()=>{v.status==200||v.status==0&&v.response?g(v.response):y()},v.onerror=y,v.send(null)});var $,F=console.log.bind(console),be=console.error.bind(console),pe=F,Z=be;if(Object.assign(a,x),x=null,d){let f=function(g){try{var y=g.data,v=y.cmd;if(v==="load"){let _=[];self.onmessage=P=>_.push(P),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let P of _)f(P);self.onmessage=f};for(let P of y.handlers)a[P]&&!a[P].proxy||(a[P]=(...N)=>{postMessage({Za:"callHandler",kb:P,args:N})},P=="print"&&(pe=a[P]),P=="printErr"&&(Z=a[P]));ye=y.wasmMemory,ie(),Ae(y.wasmModule)}else if(v==="run"){fn(y.pthread_ptr,0,0,1,0,0),ln(y.pthread_ptr),Rd(),Si(),xr||=!0;try{jd(y.start_routine,y.arg)}catch(_){if(_!="unwind")throw _}}else v==="cancel"?_t()&&Dr(-1):y.target!=="setimmediate"&&(v==="checkMailbox"?xr&&Pr():v&&(Z(`worker: received unknown command ${v}`),Z(y)))}catch(_){throw la(),_}};var Rt=f,Ae,xr=!1;Z=function(...g){g=g.join(" "),console.error(g)},self.alert=function(...g){postMessage({Za:"alert",text:g.join(" "),nb:_t()})},a.instantiateWasm=(g,y)=>new Promise(v=>{Ae=_=>{_=new WebAssembly.Instance(_,yi()),y(_),v()}}),self.onunhandledrejection=g=>{throw g.reason||g},self.onmessage=f}a.wasmBinary&&($=a.wasmBinary);var ye,Tr,Ue,we,G,We,_r,xe,vt,oe=!1;function ie(){var f=ye.buffer;a.HEAP8=we=new Int8Array(f),a.HEAP16=new Int16Array(f),a.HEAPU8=G=new Uint8Array(f),a.HEAPU16=new Uint16Array(f),a.HEAP32=We=new Int32Array(f),a.HEAPU32=_r=new Uint32Array(f),a.HEAPF32=new Float32Array(f),a.HEAPF64=vt=new Float64Array(f),a.HEAP64=xe=new BigInt64Array(f),a.HEAPU64=new BigUint64Array(f)}if(!d){if(!((ye=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof b))throw Z("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");ie()}var ot=[],Xe=[],Sr=[],it=0,Ce=null,Te=null;function at(){if(--it==0&&(Ce!==null&&(clearInterval(Ce),Ce=null),Te)){var f=Te;Te=null,f()}}function te(f){throw Z(f="Aborted("+f+")"),oe=!0,Ue=1,f=new WebAssembly.RuntimeError(f+". Build with -sASSERTIONS for more info."),n(f),f}var ae,Ge=f=>f.startsWith("data:application/octet-stream;base64,"),jt=f=>f.startsWith("file://");function Or(f){if(f==ae&&$)return new Uint8Array($);if(m)return m(f);throw"both async and sync fetching of the wasm failed"}function bi(f,g,y){return function(v){if(!$&&(u||i)){if(typeof fetch=="function"&&!jt(v))return fetch(v,{credentials:"same-origin"}).then(_=>{if(!_.ok)throw`failed to load wasm binary file at '${v}'`;return _.arrayBuffer()}).catch(()=>Or(v));if(h)return new Promise((_,P)=>{h(v,N=>_(new Uint8Array(N)),P)})}return Promise.resolve().then(()=>Or(v))}(f).then(v=>WebAssembly.instantiate(v,g)).then(y,v=>{Z(`failed to asynchronously prepare wasm: ${v}`),te(v)})}function yi(){return{a:{j:Ld,b:Vd,E:Ai,g:Ni,V:ki,A:Li,C:Ri,W:ji,T:Bi,L:Vi,S:Mi,o:zi,B:Ui,y:Gi,U:Hi,z:qi,_:Md,Z:zd,P:Ud,w:Gd,F:Hd,k:qd,O:ln,Y:Wd,I:Xd,J:Kd,K:Zd,G:Ki,H:Zi,v:Jd,q:Yd,l:Qd,p:eh,e:th,X:rh,x:nh,d:Ji,f:oh,i:ih,u:ah,t:sh,s:uh,Q:ea,R:ta,D:un,h:ra,n:na,M:oa,m:ia,a:ye,r:sn,N:ua,c:ch}}}var wi={837620:(f,g,y,v,_)=>{if(a===void 0||!a.Ua)return 1;if((f=Vt(f>>>0)).startsWith("./")&&(f=f.substring(2)),!(f=a.Ua.get(f)))return 2;if(v>>>=0,(g>>>=0)+(y>>>=0)>f.byteLength)return 3;try{let P=f.subarray(g,g+y);switch(_){case 0:o().set(P,v>>>0);break;case 1:a.mb(v,P);break;default:return 4}return 0}catch{return 4}},838303:()=>typeof wasmOffsetConverter<"u"};function Ld(){return typeof wasmOffsetConverter<"u"}function on(f){this.name="ExitStatus",this.message=`Program terminated with exit(${f})`,this.status=f}var an=f=>{f.terminate(),f.onmessage=()=>{}},vi=f=>{Ke.length==0&&(Ei(),Oi(Ke[0]));var g=Ke.pop();if(!g)return 6;st.push(g),je[f.Ra]=g,g.Ra=f.Ra;var y={cmd:"run",start_routine:f.cb,arg:f.ab,pthread_ptr:f.Ra};return g.postMessage(y,f.ib),0},Bt=0,J=(f,g,...y)=>{for(var v=2*y.length,_=bn(),P=mn(8*v),N=P>>>3,K=0;K<y.length;K++){var ce=y[K];typeof ce=="bigint"?(xe[N+2*K]=1n,xe[N+2*K+1]=ce):(xe[N+2*K]=0n,l()[N+2*K+1>>>0]=ce)}return f=pa(f,0,v,P,g),Nr(_),f};function sn(f){if(d)return J(0,1,f);if(Ue=f,!(0<Bt)){for(var g of st)an(g);for(g of Ke)an(g);Ke=[],st=[],je=[],oe=!0}w(f,new on(f))}function xi(f){if(d)return J(1,0,f);un(f)}var un=f=>{if(Ue=f,d)throw xi(f),"unwind";sn(f)},Ke=[],st=[],Ti=[],je={},_i=f=>{var g=f.Ra;delete je[g],Ke.push(f),st.splice(st.indexOf(f),1),f.Ra=0,gn(g)};function Si(){Ti.forEach(f=>f())}var Oi=f=>new Promise(g=>{f.onmessage=_=>{var P=(_=_.data).cmd;if(_.targetThread&&_.targetThread!=_t()){var N=je[_.targetThread];N?N.postMessage(_,_.transferList):Z(`Internal error! Worker sent a message "${P}" to target pthread ${_.targetThread}, but that thread no longer exists!`)}else P==="checkMailbox"?Pr():P==="spawnThread"?vi(_):P==="cleanupThread"?_i(je[_.thread]):P==="killThread"?(_=_.thread,P=je[_],delete je[_],an(P),gn(_),st.splice(st.indexOf(P),1),P.Ra=0):P==="cancelThread"?je[_.thread].postMessage({cmd:"cancel"}):P==="loaded"?(f.loaded=!0,g(f)):P==="alert"?alert(`Thread ${_.threadId}: ${_.text}`):_.target==="setimmediate"?f.postMessage(_):P==="callHandler"?a[_.handler](..._.args):P&&Z(`worker sent an unknown command ${P}`)},f.onerror=_=>{throw Z(`worker sent an error! ${_.filename}:${_.lineno}: ${_.message}`),_};var y,v=[];for(y of[])a.hasOwnProperty(y)&&v.push(y);f.postMessage({cmd:"load",handlers:v,wasmMemory:ye,wasmModule:Tr})});function Ei(){var f=new Worker(new URL(Ur.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});Ke.push(f)}var Ii,Er=f=>{for(;0<f.length;)f.shift()(a)},Rd=()=>{var f=_t(),g=p()[f+52>>>2>>>0];f=p()[f+56>>>2>>>0],da(g,g-f),Nr(g)},Ir=[],jd=(f,g)=>{Bt=0;var y=Ir[f];y||(f>=Ir.length&&(Ir.length=f+1),Ir[f]=y=Ii.get(f)),f=y(g),0<Bt?Ue=f:Dr(f)};class Bd{constructor(g){this.Xa=g-24}}function Vd(f,g,y){var v=new Bd(f>>>=0);throw g>>>=0,y>>>=0,p()[v.Xa+16>>>2>>>0]=0,p()[v.Xa+4>>>2>>>0]=g,p()[v.Xa+8>>>2>>>0]=y,f}function Pi(f,g,y,v){return d?J(2,1,f,g,y,v):Ai(f,g,y,v)}function Ai(f,g,y,v){if(f>>>=0,g>>>=0,y>>>=0,v>>>=0,b===void 0)return Z("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var _=[];return d&&_.length===0?Pi(f,g,y,v):(f={cb:y,Ra:f,ab:v,ib:_},d?(f.Za="spawnThread",postMessage(f,_),0):vi(f))}var $i=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Di=(f,g,y)=>{var v=(g>>>=0)+y;for(y=g;f[y]&&!(y>=v);)++y;if(16<y-g&&f.buffer&&$i)return $i.decode(f.buffer instanceof b?f.slice(g,y):f.subarray(g,y));for(v="";g<y;){var _=f[g++];if(128&_){var P=63&f[g++];if((224&_)==192)v+=String.fromCharCode((31&_)<<6|P);else{var N=63&f[g++];65536>(_=(240&_)==224?(15&_)<<12|P<<6|N:(7&_)<<18|P<<12|N<<6|63&f[g++])?v+=String.fromCharCode(_):(_-=65536,v+=String.fromCharCode(55296|_>>10,56320|1023&_))}}else v+=String.fromCharCode(_)}return v},Vt=(f,g)=>(f>>>=0)?Di(o(),f,g):"";function Ni(f,g,y){return d?J(3,1,f,g,y):0}function ki(f,g){if(d)return J(4,1,f,g)}var Fi=f=>{for(var g=0,y=0;y<f.length;++y){var v=f.charCodeAt(y);127>=v?g++:2047>=v?g+=2:55296<=v&&57343>=v?(g+=4,++y):g+=3}return g},Ci=(f,g,y,v)=>{if(!(0<v))return 0;var _=y>>>=0;v=y+v-1;for(var P=0;P<f.length;++P){var N=f.charCodeAt(P);if(55296<=N&&57343>=N&&(N=65536+((1023&N)<<10)|1023&f.charCodeAt(++P)),127>=N){if(y>=v)break;g[y++>>>0]=N}else{if(2047>=N){if(y+1>=v)break;g[y++>>>0]=192|N>>6}else{if(65535>=N){if(y+2>=v)break;g[y++>>>0]=224|N>>12}else{if(y+3>=v)break;g[y++>>>0]=240|N>>18,g[y++>>>0]=128|N>>12&63}g[y++>>>0]=128|N>>6&63}g[y++>>>0]=128|63&N}}return g[y>>>0]=0,y-_},Mt=(f,g,y)=>Ci(f,o(),g,y);function Li(f,g){if(d)return J(5,1,f,g)}function Ri(f,g,y){if(d)return J(6,1,f,g,y)}function ji(f,g,y){return d?J(7,1,f,g,y):0}function Bi(f,g){if(d)return J(8,1,f,g)}function Vi(f,g,y){if(d)return J(9,1,f,g,y)}function Mi(f,g,y,v){if(d)return J(10,1,f,g,y,v)}function zi(f,g,y,v){if(d)return J(11,1,f,g,y,v)}function Ui(f,g,y,v){if(d)return J(12,1,f,g,y,v)}function Gi(f){if(d)return J(13,1,f)}function Hi(f,g){if(d)return J(14,1,f,g)}function qi(f,g,y){if(d)return J(15,1,f,g,y)}var Md=()=>{te("")},zd=()=>1;function Ud(f){fn(f>>>0,!i,1,!u,131072,!1),Si()}function ln(f){f>>>=0,typeof Atomics.jb=="function"&&(Atomics.jb(s(),f>>>2,f).value.then(Pr),f+=128,Atomics.store(s(),f>>>2,1))}var Pr=()=>{var f=_t();if(f&&(ln(f),f=ca,!oe))try{if(f(),!(0<Bt))try{d?Dr(Ue):un(Ue)}catch(g){g instanceof on||g=="unwind"||w(1,g)}}catch(g){g instanceof on||g=="unwind"||w(1,g)}};function Gd(f,g){(f>>>=0)==g>>>0?setTimeout(Pr):d?postMessage({targetThread:f,cmd:"checkMailbox"}):(f=je[f])&&f.postMessage({cmd:"checkMailbox"})}var pn=[];function Hd(f,g,y,v,_){for(g>>>=0,v/=2,pn.length=v,y=_>>>0>>>3,_=0;_<v;_++)pn[_]=xe[y+2*_]?xe[y+2*_+1]:l()[y+2*_+1>>>0];return(g?wi[g]:dh[f])(...pn)}function qd(f){f>>>=0,d?postMessage({cmd:"cleanupThread",thread:f}):_i(je[f])}function Wd(f){}function Xd(f,g){f=-9007199254740992>f||9007199254740992<f?NaN:Number(f),g>>>=0,f=new Date(1e3*f),s()[g>>>2>>>0]=f.getUTCSeconds(),s()[g+4>>>2>>>0]=f.getUTCMinutes(),s()[g+8>>>2>>>0]=f.getUTCHours(),s()[g+12>>>2>>>0]=f.getUTCDate(),s()[g+16>>>2>>>0]=f.getUTCMonth(),s()[g+20>>>2>>>0]=f.getUTCFullYear()-1900,s()[g+24>>>2>>>0]=f.getUTCDay(),f=(f.getTime()-Date.UTC(f.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[g+28>>>2>>>0]=f}var xt=f=>f%4==0&&(f%100!=0||f%400==0),Wi=[0,31,60,91,121,152,182,213,244,274,305,335],Xi=[0,31,59,90,120,151,181,212,243,273,304,334];function Kd(f,g){f=-9007199254740992>f||9007199254740992<f?NaN:Number(f),g>>>=0,f=new Date(1e3*f),s()[g>>>2>>>0]=f.getSeconds(),s()[g+4>>>2>>>0]=f.getMinutes(),s()[g+8>>>2>>>0]=f.getHours(),s()[g+12>>>2>>>0]=f.getDate(),s()[g+16>>>2>>>0]=f.getMonth(),s()[g+20>>>2>>>0]=f.getFullYear()-1900,s()[g+24>>>2>>>0]=f.getDay();var y=(xt(f.getFullYear())?Wi:Xi)[f.getMonth()]+f.getDate()-1|0;s()[g+28>>>2>>>0]=y,s()[g+36>>>2>>>0]=-60*f.getTimezoneOffset(),y=new Date(f.getFullYear(),6,1).getTimezoneOffset();var v=new Date(f.getFullYear(),0,1).getTimezoneOffset();f=0|(y!=v&&f.getTimezoneOffset()==Math.min(v,y)),s()[g+32>>>2>>>0]=f}function Zd(f){f>>>=0;var g=new Date(s()[f+20>>>2>>>0]+1900,s()[f+16>>>2>>>0],s()[f+12>>>2>>>0],s()[f+8>>>2>>>0],s()[f+4>>>2>>>0],s()[f>>>2>>>0],0),y=s()[f+32>>>2>>>0],v=g.getTimezoneOffset(),_=new Date(g.getFullYear(),6,1).getTimezoneOffset(),P=new Date(g.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(P,_);return 0>y?s()[f+32>>>2>>>0]=+(_!=P&&N==v):0<y!=(N==v)&&(_=Math.max(P,_),g.setTime(g.getTime()+6e4*((0<y?N:_)-v))),s()[f+24>>>2>>>0]=g.getDay(),y=(xt(g.getFullYear())?Wi:Xi)[g.getMonth()]+g.getDate()-1|0,s()[f+28>>>2>>>0]=y,s()[f>>>2>>>0]=g.getSeconds(),s()[f+4>>>2>>>0]=g.getMinutes(),s()[f+8>>>2>>>0]=g.getHours(),s()[f+12>>>2>>>0]=g.getDate(),s()[f+16>>>2>>>0]=g.getMonth(),s()[f+20>>>2>>>0]=g.getYear(),f=g.getTime(),BigInt(isNaN(f)?-1:f/1e3)}function Ki(f,g,y,v,_,P,N){return d?J(16,1,f,g,y,v,_,P,N):-52}function Zi(f,g,y,v,_,P){if(d)return J(17,1,f,g,y,v,_,P)}function Jd(f,g,y,v){f>>>=0,g>>>=0,y>>>=0,v>>>=0;var _=new Date().getFullYear(),P=new Date(_,0,1),N=new Date(_,6,1);_=P.getTimezoneOffset();var K=N.getTimezoneOffset(),ce=Math.max(_,K);p()[f>>>2>>>0]=60*ce,s()[g>>>2>>>0]=+(_!=K),P=(f=ge=>ge.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(P),N=f(N),K<_?(Mt(P,y,17),Mt(N,v,17)):(Mt(P,v,17),Mt(N,y,17))}var cn=[];function Yd(f,g,y){f>>>=0,g>>>=0,y>>>=0,cn.length=0;for(var v;v=o()[g++>>>0];){var _=v!=105;y+=(_&=v!=112)&&y%8?4:0,cn.push(v==112?p()[y>>>2>>>0]:v==106?xe[y>>>3]:v==105?s()[y>>>2>>>0]:l()[y>>>3>>>0]),y+=_?8:4}return wi[f](...cn)}var Qd=()=>{},eh=()=>Date.now();function th(f,g){return Z(Vt(f>>>0,g>>>0))}var Ji,rh=()=>{throw Bt+=1,"unwind"};function nh(){return 4294901760}Ji=()=>performance.timeOrigin+performance.now();var oh=()=>navigator.hardwareConcurrency;function ih(){return te("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function ah(f){f>>>=0;var g=o().length;if(f<=g||4294901760<f)return!1;for(var y=1;4>=y;y*=2){var v=g*(1+.2/y);v=Math.min(v,f+100663296);var _=Math;v=Math.max(f,v);e:{_=(_.min.call(_,4294901760,v+(65536-v%65536)%65536)-ye.buffer.byteLength+65535)/65536;try{ye.grow(_),ie();var P=1;break e}catch{}P=void 0}if(P)return!0}return!1}var Ar=()=>(te("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Tt={},Yi=f=>{f.forEach(g=>{var y=Ar();y&&(Tt[y]=g)})};function sh(){var f=Error().stack.toString().split(`
`);return f[0]=="Error"&&f.shift(),Yi(f),Tt.$a=Ar(),Tt.bb=f,Tt.$a}function uh(f,g,y){if(f>>>=0,g>>>=0,Tt.$a==f)var v=Tt.bb;else(v=Error().stack.toString().split(`
`))[0]=="Error"&&v.shift(),Yi(v);for(var _=3;v[_]&&Ar()!=f;)++_;for(f=0;f<y&&v[f+_];++f)s()[g+4*f>>>2>>>0]=Ar();return f}var dn,hn={},Qi=()=>{if(!dn){var f,g={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:E||"./this.program"};for(f in hn)hn[f]===void 0?delete g[f]:g[f]=hn[f];var y=[];for(f in g)y.push(`${f}=${g[f]}`);dn=y}return dn};function ea(f,g){if(d)return J(18,1,f,g);f>>>=0,g>>>=0;var y=0;return Qi().forEach((v,_)=>{var P=g+y;for(_=p()[f+4*_>>>2>>>0]=P,P=0;P<v.length;++P)r()[_++>>>0]=v.charCodeAt(P);r()[_>>>0]=0,y+=v.length+1}),0}function ta(f,g){if(d)return J(19,1,f,g);f>>>=0,g>>>=0;var y=Qi();p()[f>>>2>>>0]=y.length;var v=0;return y.forEach(_=>v+=_.length+1),p()[g>>>2>>>0]=v,0}function ra(f){return d?J(20,1,f):52}function na(f,g,y,v){return d?J(21,1,f,g,y,v):52}function oa(f,g,y,v){return d?J(22,1,f,g,y,v):70}var lh=[null,[],[]];function ia(f,g,y,v){if(d)return J(23,1,f,g,y,v);g>>>=0,y>>>=0,v>>>=0;for(var _=0,P=0;P<y;P++){var N=p()[g>>>2>>>0],K=p()[g+4>>>2>>>0];g+=8;for(var ce=0;ce<K;ce++){var ge=o()[N+ce>>>0],ve=lh[f];ge===0||ge===10?((f===1?pe:Z)(Di(ve,0)),ve.length=0):ve.push(ge)}_+=K}return p()[v>>>2>>>0]=_,0}var aa=[31,29,31,30,31,30,31,31,30,31,30,31],sa=[31,28,31,30,31,30,31,31,30,31,30,31],ph=(f,g)=>{r().set(f,g>>>0)};function ua(f,g,y,v){function _(O,z,re){for(O=typeof O=="number"?O.toString():O||"";O.length<z;)O=re[0]+O;return O}function P(O,z){return _(O,z,"0")}function N(O,z){function re(ma){return 0>ma?-1:0<ma?1:0}var ut;return(ut=re(O.getFullYear()-z.getFullYear()))===0&&(ut=re(O.getMonth()-z.getMonth()))===0&&(ut=re(O.getDate()-z.getDate())),ut}function K(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function ce(O){var z=O.Sa;for(O=new Date(new Date(O.Ta+1900,0,1).getTime());0<z;){var re=O.getMonth(),ut=(xt(O.getFullYear())?aa:sa)[re];if(!(z>ut-O.getDate())){O.setDate(O.getDate()+z);break}z-=ut-O.getDate()+1,O.setDate(1),11>re?O.setMonth(re+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1))}return re=new Date(O.getFullYear()+1,0,4),z=K(new Date(O.getFullYear(),0,4)),re=K(re),0>=N(z,O)?0>=N(re,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}f>>>=0,g>>>=0,y>>>=0,v>>>=0;var ge=p()[v+40>>>2>>>0];for(var ve in v={gb:s()[v>>>2>>>0],fb:s()[v+4>>>2>>>0],Va:s()[v+8>>>2>>>0],Ya:s()[v+12>>>2>>>0],Wa:s()[v+16>>>2>>>0],Ta:s()[v+20>>>2>>>0],Qa:s()[v+24>>>2>>>0],Sa:s()[v+28>>>2>>>0],ob:s()[v+32>>>2>>>0],eb:s()[v+36>>>2>>>0],hb:ge?Vt(ge):""},y=Vt(y),ge={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})y=y.replace(new RegExp(ve,"g"),ge[ve]);var fa="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ga="January February March April May June July August September October November December".split(" ");for(ve in ge={"%a":O=>fa[O.Qa].substring(0,3),"%A":O=>fa[O.Qa],"%b":O=>ga[O.Wa].substring(0,3),"%B":O=>ga[O.Wa],"%C":O=>P((O.Ta+1900)/100|0,2),"%d":O=>P(O.Ya,2),"%e":O=>_(O.Ya,2," "),"%g":O=>ce(O).toString().substring(2),"%G":ce,"%H":O=>P(O.Va,2),"%I":O=>((O=O.Va)==0?O=12:12<O&&(O-=12),P(O,2)),"%j":O=>{for(var z=0,re=0;re<=O.Wa-1;z+=(xt(O.Ta+1900)?aa:sa)[re++]);return P(O.Ya+z,3)},"%m":O=>P(O.Wa+1,2),"%M":O=>P(O.fb,2),"%n":()=>`
`,"%p":O=>0<=O.Va&&12>O.Va?"AM":"PM","%S":O=>P(O.gb,2),"%t":()=>"	","%u":O=>O.Qa||7,"%U":O=>P(Math.floor((O.Sa+7-O.Qa)/7),2),"%V":O=>{var z=Math.floor((O.Sa+7-(O.Qa+6)%7)/7);if(2>=(O.Qa+371-O.Sa-2)%7&&z++,z)z==53&&((re=(O.Qa+371-O.Sa)%7)==4||re==3&&xt(O.Ta)||(z=1));else{z=52;var re=(O.Qa+7-O.Sa-1)%7;(re==4||re==5&&xt(O.Ta%400-1))&&z++}return P(z,2)},"%w":O=>O.Qa,"%W":O=>P(Math.floor((O.Sa+7-(O.Qa+6)%7)/7),2),"%y":O=>(O.Ta+1900).toString().substring(2),"%Y":O=>O.Ta+1900,"%z":O=>{var z=0<=(O=O.eb);return O=Math.abs(O)/60,(z?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.hb,"%%":()=>"%"},y=y.replace(/%%/g,"\0\0"),ge)y.includes(ve)&&(y=y.replace(new RegExp(ve,"g"),ge[ve](v)));return ve=function(O){var z=Array(Fi(O)+1);return Ci(O,z,0,z.length),z}(y=y.replace(/\0\0/g,"%")),ve.length>g?0:(ph(ve,f),ve.length-1)}function ch(f,g,y,v){return ua(f>>>0,g>>>0,y>>>0,v>>>0)}d||function(){for(var f=a.numThreads-1;f--;)Ei();ot.unshift(()=>{it++,function(g){d?g():Promise.all(Ke.map(Oi)).then(g)}(()=>at())})}();var dh=[sn,xi,Pi,Ni,ki,Li,Ri,ji,Bi,Vi,Mi,zi,Ui,Gi,Hi,qi,Ki,Zi,ea,ta,ra,na,oa,ia],k=function(){function f(y,v){return k=y.exports,k=function(){var _=k,P=K=>()=>K()>>>0,N=K=>ce=>K(ce)>>>0;return(_=Object.assign({},_)).Ba=P(_.Ba),_.Ca=N(_.Ca),_.emscripten_main_runtime_thread_id=P(_.emscripten_main_runtime_thread_id),_.Oa=N(_.Oa),_.Pa=P(_.Pa),_}(),Ti.push(k.Ea),Ii=k.Fa,Xe.unshift(k.$),Tr=v,at(),k}var g=yi();if(it++,a.instantiateWasm)try{return a.instantiateWasm(g,f)}catch(y){Z(`Module.instantiateWasm callback failed with error: ${y}`),n(y)}return ae||=a.locateFile?Ge("ort-wasm-simd-threaded.wasm")?"ort-wasm-simd-threaded.wasm":a.locateFile?a.locateFile("ort-wasm-simd-threaded.wasm",S):S+"ort-wasm-simd-threaded.wasm":new URL("ort-wasm-simd-threaded.wasm",Ur.url).href,function(y,v){var _=ae;return $||typeof WebAssembly.instantiateStreaming!="function"||Ge(_)||jt(_)||typeof fetch!="function"?bi(_,y,v):fetch(_,{credentials:"same-origin"}).then(P=>WebAssembly.instantiateStreaming(P,y).then(v,function(N){return Z(`wasm streaming compile failed: ${N}`),Z("falling back to ArrayBuffer instantiation"),bi(_,y,v)}))}(g,function(y){f(y.instance,y.module)}).catch(n),{}}();a._OrtInit=(f,g)=>(a._OrtInit=k.aa)(f,g),a._OrtGetLastError=(f,g)=>(a._OrtGetLastError=k.ba)(f,g),a._OrtCreateSessionOptions=(f,g,y,v,_,P,N,K,ce,ge)=>(a._OrtCreateSessionOptions=k.ca)(f,g,y,v,_,P,N,K,ce,ge),a._OrtAppendExecutionProvider=(f,g)=>(a._OrtAppendExecutionProvider=k.da)(f,g),a._OrtAddFreeDimensionOverride=(f,g,y)=>(a._OrtAddFreeDimensionOverride=k.ea)(f,g,y),a._OrtAddSessionConfigEntry=(f,g,y)=>(a._OrtAddSessionConfigEntry=k.fa)(f,g,y),a._OrtReleaseSessionOptions=f=>(a._OrtReleaseSessionOptions=k.ga)(f),a._OrtCreateSession=(f,g,y)=>(a._OrtCreateSession=k.ha)(f,g,y),a._OrtReleaseSession=f=>(a._OrtReleaseSession=k.ia)(f),a._OrtGetInputOutputCount=(f,g,y)=>(a._OrtGetInputOutputCount=k.ja)(f,g,y),a._OrtGetInputName=(f,g)=>(a._OrtGetInputName=k.ka)(f,g),a._OrtGetOutputName=(f,g)=>(a._OrtGetOutputName=k.la)(f,g),a._OrtFree=f=>(a._OrtFree=k.ma)(f),a._OrtCreateTensor=(f,g,y,v,_,P)=>(a._OrtCreateTensor=k.na)(f,g,y,v,_,P),a._OrtGetTensorData=(f,g,y,v,_)=>(a._OrtGetTensorData=k.oa)(f,g,y,v,_),a._OrtReleaseTensor=f=>(a._OrtReleaseTensor=k.pa)(f),a._OrtCreateRunOptions=(f,g,y,v)=>(a._OrtCreateRunOptions=k.qa)(f,g,y,v),a._OrtAddRunConfigEntry=(f,g,y)=>(a._OrtAddRunConfigEntry=k.ra)(f,g,y),a._OrtReleaseRunOptions=f=>(a._OrtReleaseRunOptions=k.sa)(f),a._OrtCreateBinding=f=>(a._OrtCreateBinding=k.ta)(f),a._OrtBindInput=(f,g,y)=>(a._OrtBindInput=k.ua)(f,g,y),a._OrtBindOutput=(f,g,y,v)=>(a._OrtBindOutput=k.va)(f,g,y,v),a._OrtClearBoundOutputs=f=>(a._OrtClearBoundOutputs=k.wa)(f),a._OrtReleaseBinding=f=>(a._OrtReleaseBinding=k.xa)(f),a._OrtRunWithBinding=(f,g,y,v,_)=>(a._OrtRunWithBinding=k.ya)(f,g,y,v,_),a._OrtRun=(f,g,y,v,_,P,N,K)=>(a._OrtRun=k.za)(f,g,y,v,_,P,N,K),a._OrtEndProfiling=f=>(a._OrtEndProfiling=k.Aa)(f);var _t=()=>(_t=k.Ba)();a._malloc=f=>(a._malloc=k.Ca)(f),a._free=f=>(a._free=k.Da)(f);var $r,fn=(f,g,y,v,_,P)=>(fn=k.Ga)(f,g,y,v,_,P),la=()=>(la=k.Ha)(),pa=(f,g,y,v,_)=>(pa=k.Ia)(f,g,y,v,_),gn=f=>(gn=k.Ja)(f),Dr=f=>(Dr=k.Ka)(f),ca=()=>(ca=k.La)(),da=(f,g)=>(da=k.Ma)(f,g),Nr=f=>(Nr=k.Na)(f),mn=f=>(mn=k.Oa)(f),bn=()=>(bn=k.Pa)();function ha(){0<it||(d?(c(a),d||Er(Xe),startWorker(a)):(Er(ot),0<it||$r||($r=!0,a.calledRun=!0,oe||(d||Er(Xe),c(a),d||Er(Sr)))))}return a.___start_em_js=838360,a.___stop_em_js=838421,a.stackSave=()=>bn(),a.stackRestore=f=>Nr(f),a.stackAlloc=f=>mn(f),a.UTF8ToString=Vt,a.stringToUTF8=Mt,a.lengthBytesUTF8=Fi,Te=function f(){$r||ha(),$r||(Te=f)},ha(),t}),hd=eo,globalThis.self?.name==="em-pthread"&&eo()}),Ot,Lu,Ru,ju,to,fd,Bu,gd,rn=I(()=>{"use strict";ni(),Ot=Ur.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),Lu=typeof location>"u"?void 0:location.origin,Ru=(e,r)=>{try{let o=r??Ot;return(o?new URL(e,o):new URL(e)).origin===Lu}catch{return!1}},ju=async e=>{let r=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},to=(dm(),Gr(pd)).default,fd=async()=>{if(!Ot)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Ru(Ot))return[void 0,to()];let e=await ju(Ot);return[e,to(e)]},Bu=(hm(),Gr(dd)).default,gd=async(e,r,o)=>[void 0,Bu]}),ro,jr,Zt,no,Vu,Mu,oi,he,Ct=I(()=>{"use strict";rn(),jr=!1,Zt=!1,no=!1,Vu=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Mu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},oi=async e=>{if(jr)return Promise.resolve();if(Zt)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(no)throw new Error("previous call to 'initializeWebAssembly()' failed.");Zt=!0;let r=e.initTimeout,o=e.numThreads;if(!Mu())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=Vu();o>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+o+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=o=1);let p=e.wasmPaths,l=typeof p=="string"?p:void 0,c=p?.mjs,n=c?.href??c,a=p?.wasm,t=a?.href??a,u=e.wasmBinary,[i,d]=await gd(n,l,o>1),h=!1,m=[];if(r>0&&m.push(new Promise(b=>{setTimeout(()=>{h=!0,b()},r)})),m.push(new Promise((b,x)=>{let E={numThreads:o};u?E.wasmBinary=u:(t||l)&&(E.locateFile=(w,S)=>t??(l??S)+w),d(E).then(w=>{Zt=!1,jr=!0,ro=w,b(),i&&URL.revokeObjectURL(i)},w=>{Zt=!1,no=!0,x(w)})})),await Promise.race(m),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},he=()=>{if(jr&&ro)return ro;throw new Error("WebAssembly is not initialized yet.")}}),ue,Kr,se,ii=I(()=>{"use strict";Ct(),ue=(e,r)=>{let o=he(),s=o.lengthBytesUTF8(e)+1,p=o._malloc(s);return o.stringToUTF8(e,p,s),r.push(p),p},Kr=(e,r,o,s)=>{if(typeof e=="object"&&e!==null){if(o.has(e))throw new Error("Circular reference in options");o.add(e)}Object.entries(e).forEach(([p,l])=>{let c=r?r+p:p;if(typeof l=="object")Kr(l,c+".",o,s);else if(typeof l=="string"||typeof l=="number")s(c,l.toString());else if(typeof l=="boolean")s(c,l?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof l}`)})},se=e=>{let r=he(),o=r.stackSave();try{let s=r.stackAlloc(8);r._OrtGetLastError(s,s+4);let p=r.HEAP32[s/4],l=r.HEAPU32[s/4+1],c=l?r.UTF8ToString(l):"";throw new Error(`${e} ERROR_CODE: ${p}, ERROR_MESSAGE: ${c}`)}finally{r.stackRestore(o)}}}),md,fm=I(()=>{"use strict";Ct(),ii(),md=e=>{let r=he(),o=0,s=[],p=e||{};try{if(e?.logSeverityLevel===void 0)p.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)p.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(p.terminate=!1);let l=0;return e?.tag!==void 0&&(l=ue(e.tag,s)),o=r._OrtCreateRunOptions(p.logSeverityLevel,p.logVerbosityLevel,!!p.terminate,l),o===0&&se("Can't create run options."),e?.extra!==void 0&&Kr(e.extra,"",new WeakSet,(c,n)=>{let a=ue(c,s),t=ue(n,s);r._OrtAddRunConfigEntry(o,a,t)!==0&&se(`Can't set a run config entry: ${c} - ${n}.`)}),[o,s]}catch(l){throw o!==0&&r._OrtReleaseRunOptions(o),s.forEach(c=>r._free(c)),l}}}),zu,Uu,Gu,Hu,bd,gm=I(()=>{"use strict";Ct(),ii(),zu=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Uu=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Gu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let r=e.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(o=>(typeof o=="string"?o:o.name)==="webgpu")&&(e.enableMemPattern=!1)},Hu=(e,r,o)=>{for(let s of r){let p=typeof s=="string"?s:s.name;switch(p){case"webnn":if(p="WEBNN",typeof s!="string"){let c=s?.deviceType;if(c){let n=ue("deviceType",o),a=ue(c,o);he()._OrtAddSessionConfigEntry(e,n,a)!==0&&se(`Can't set a session config entry: 'deviceType' - ${c}.`)}}break;case"webgpu":if(p="JS",typeof s!="string"){let c=s;if(c?.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);let n=ue("preferredLayout",o),a=ue(c.preferredLayout,o);he()._OrtAddSessionConfigEntry(e,n,a)!==0&&se(`Can't set a session config entry: 'preferredLayout' - ${c.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${p}`)}let l=ue(p,o);he()._OrtAppendExecutionProvider(e,l)!==0&&se(`Can't append execution provider: ${p}.`)}},bd=e=>{let r=he(),o=0,s=[],p=e||{};Gu(p);try{let l=zu(p.graphOptimizationLevel??"all"),c=Uu(p.executionMode??"sequential"),n=typeof p.logId=="string"?ue(p.logId,s):0,a=p.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let t=p.logVerbosityLevel??0;if(!Number.isInteger(t)||t<0||t>4)throw new Error(`log verbosity level is not valid: ${t}`);let u=typeof p.optimizedModelFilePath=="string"?ue(p.optimizedModelFilePath,s):0;if(o=r._OrtCreateSessionOptions(l,!!p.enableCpuMemArena,!!p.enableMemPattern,c,!!p.enableProfiling,0,n,a,t,u),o===0&&se("Can't create session options."),p.executionProviders&&Hu(o,p.executionProviders,s),p.enableGraphCapture!==void 0){if(typeof p.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${p.enableGraphCapture}`);let i=ue("enableGraphCapture",s),d=ue(p.enableGraphCapture.toString(),s);r._OrtAddSessionConfigEntry(o,i,d)!==0&&se(`Can't set a session config entry: 'enableGraphCapture' - ${p.enableGraphCapture}.`)}if(p.freeDimensionOverrides)for(let[i,d]of Object.entries(p.freeDimensionOverrides)){if(typeof i!="string")throw new Error(`free dimension override name must be a string: ${i}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let h=ue(i,s);r._OrtAddFreeDimensionOverride(o,h,d)!==0&&se(`Can't set a free dimension override: ${i} - ${d}.`)}return p.extra!==void 0&&Kr(p.extra,"",new WeakSet,(i,d)=>{let h=ue(i,s),m=ue(d,s);r._OrtAddSessionConfigEntry(o,h,m)!==0&&se(`Can't set a session config entry: ${i} - ${d}.`)}),[o,s]}catch(l){throw o!==0&&r._OrtReleaseSessionOptions(o),s.forEach(c=>r._free(c)),l}}}),ar,yd,sr,wd,vd,ai,si,xd,Td=I(()=>{"use strict";ar=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},yd=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},sr=(e,r)=>{let o=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],s=typeof r=="number"?r:r.reduce((p,l)=>p*l,1);return o>0?Math.ceil(s*o):void 0},wd=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},vd=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ai=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",si=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool",xd=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),ui,_d=I(()=>{"use strict";ni(),ui=async e=>{if(typeof e=="string")if(0)try{}catch(r){}else{let r=await fetch(e);if(!r.ok)throw new Error(`failed to load external data file: ${e}`);let o=r.headers.get("Content-Length"),s=o?parseInt(o,10):0;if(s<1073741824)return new Uint8Array(await r.arrayBuffer());{if(!r.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let p=r.body.getReader(),l;try{l=new ArrayBuffer(s)}catch(n){if(n instanceof RangeError){let a=Math.ceil(s/65536);l=new WebAssembly.Memory({initial:a,maximum:a}).buffer}else throw n}let c=0;for(;;){let{done:n,value:a}=await p.read();if(n)break;let t=a.byteLength;new Uint8Array(l,c,t).set(a),c+=t}return new Uint8Array(l,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),qu,li,pi,dt,Wu,Zr,ci,di,oo,hi,fi,gi,Sd=I(()=>{"use strict";fm(),gm(),Td(),Ct(),ii(),_d(),qu=(e,r)=>{he()._OrtInit(e,r)!==0&&se("Can't initialize onnxruntime.")},li=async e=>{qu(e.wasm.numThreads,vd(e.logLevel))},pi=async(e,r)=>{},dt=new Map,Wu=e=>{let r=he(),o=r.stackSave();try{let s=r.stackAlloc(8);return r._OrtGetInputOutputCount(e,s,s+4)!==0&&se("Can't get session input/output count."),[r.HEAP32[s/4],r.HEAP32[s/4+1]]}finally{r.stackRestore(o)}},Zr=e=>{let r=he(),o=r._malloc(e.byteLength);if(o===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return r.HEAPU8.set(e,o),[o,e.byteLength]},ci=async(e,r)=>{let o,s,p=he();Array.isArray(e)?[o,s]=e:e.buffer===p.HEAPU8.buffer?[o,s]=[e.byteOffset,e.byteLength]:[o,s]=Zr(e);let l=0,c=0,n=0,a=[],t=[],u=[];try{if([c,a]=bd(r),r?.externalData&&p.mountExternalData){let w=[];for(let S of r.externalData){let $=typeof S=="string"?S:S.path;w.push(ui(typeof S=="string"?S:S.data).then(F=>{p.mountExternalData($,F)}))}await Promise.all(w)}for(let w of r?.executionProviders??[])if((typeof w=="string"?w:w.name)==="webnn"){if(p.shouldTransferToMLTensor=!1,p.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof w!="string"){let S=w,$=S?.context,F=S?.gpuDevice,be=S?.deviceType,pe=S?.numThreads,Z=S?.powerPreference;$?p.currentContext=$:F?p.currentContext=await navigator.ml.createContext(F):p.currentContext=await navigator.ml.createContext({deviceType:be,numThreads:pe,powerPreference:Z})}else p.currentContext=await navigator.ml.createContext();break}l=await p._OrtCreateSession(o,s,c),l===0&&se("Can't create a session."),p.currentContext&&(p.jsepRegisterMLContext(l,p.currentContext),p.currentContext=void 0,p.shouldTransferToMLTensor=!0);let[i,d]=Wu(l),h=!!r?.enableGraphCapture,m=[],b=[],x=[];for(let w=0;w<i;w++){let S=p._OrtGetInputName(l,w);S===0&&se("Can't get an input name."),t.push(S),m.push(p.UTF8ToString(S))}for(let w=0;w<d;w++){let S=p._OrtGetOutputName(l,w);S===0&&se("Can't get an output name."),u.push(S);let $=p.UTF8ToString(S);b.push($)}return dt.set(l,[l,t,u,null,h,!1]),[l,m,b]}catch(i){throw t.forEach(d=>p._OrtFree(d)),u.forEach(d=>p._OrtFree(d)),n!==0&&p._OrtReleaseBinding(n),l!==0&&p._OrtReleaseSession(l),i}finally{p._free(o),c!==0&&p._OrtReleaseSessionOptions(c),a.forEach(i=>p._free(i)),p.unmountExternalData?.()}},di=e=>{let r=he(),o=dt.get(e);if(!o)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,p,l,c,n]=o;c&&(n&&r._OrtClearBoundOutputs(c.handle),r._OrtReleaseBinding(c.handle)),r.jsepOnReleaseSession?.(e),p.forEach(a=>r._OrtFree(a)),l.forEach(a=>r._OrtFree(a)),r._OrtReleaseSession(s),dt.delete(e)},oo=(e,r,o,s,p,l=!1)=>{if(!e){r.push(0);return}let c=he(),n=e[0],a=e[1],t=e[3],u,i;if(n==="string"&&(t==="gpu-buffer"||t==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(l&&t!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${p} when enableGraphCapture is true.`);if(t==="gpu-buffer"){let m=e[2].gpuBuffer;i=sr(ar(n),a);let b=c.jsepRegisterBuffer;if(!b)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');u=b(s,p,m,i)}else if(t==="ml-tensor"){let m=e[2].mlTensor;i=sr(ar(n),a);let b=c.jsepRegisterMLTensor;if(!b)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');u=b(m,ar(n),a)}else{let m=e[2];if(Array.isArray(m)){i=4*m.length,u=c._malloc(i),o.push(u);let b=u/4;for(let x=0;x<m.length;x++){if(typeof m[x]!="string")throw new TypeError(`tensor data at index ${x} is not a string`);c.HEAPU32[b++]=ue(m[x],o)}}else i=m.byteLength,u=c._malloc(i),o.push(u),c.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,i),u)}let d=c.stackSave(),h=c.stackAlloc(4*a.length);try{let m=h/4;a.forEach(x=>c.HEAP32[m++]=x);let b=c._OrtCreateTensor(ar(n),u,i,h,a.length,xd(t));b===0&&se(`Can't create tensor for input/output. session=${s}, index=${p}.`),r.push(b)}finally{c.stackRestore(d)}},hi=async(e,r,o,s,p,l)=>{let c=he(),n=dt.get(e);if(!n)throw new Error(`cannot run inference. invalid session id: ${e}`);let a=n[0],t=n[1],u=n[2],i=n[3],d=n[4],h=n[5],m=r.length,b=s.length,x=0,E=[],w=[],S=[],$=[],F=c.stackSave(),be=c.stackAlloc(m*4),pe=c.stackAlloc(m*4),Z=c.stackAlloc(b*4),Rt=c.stackAlloc(b*4);try{c.jsepOnRunStart?.(a),[x,E]=md(l);for(let G=0;G<m;G++)oo(o[G],w,$,e,r[G],d);for(let G=0;G<b;G++)oo(p[G],S,$,e,m+s[G],d);let Ae=be/4,xr=pe/4,ye=Z/4,Tr=Rt/4;for(let G=0;G<m;G++)c.HEAPU32[Ae++]=w[G],c.HEAPU32[xr++]=t[r[G]];for(let G=0;G<b;G++)c.HEAPU32[ye++]=S[G],c.HEAPU32[Tr++]=u[s[G]];let Ue;Ue=await c._OrtRun(a,pe,be,m,Rt,b,Z,x),Ue!==0&&se("failed to call OrtRun().");let we=[];for(let G=0;G<b;G++){let We=c.HEAPU32[Z/4+G];if(We===S[G]){we.push(p[G]);continue}let _r=c.stackSave(),xe=c.stackAlloc(4*4),vt=!1,oe,ie=0;try{c._OrtGetTensorData(We,xe,xe+4,xe+8,xe+12)!==0&&se(`Can't access output tensor data on index ${G}.`);let ot=xe/4,Xe=c.HEAPU32[ot++];ie=c.HEAPU32[ot++];let Sr=c.HEAPU32[ot++],it=c.HEAPU32[ot++],Ce=[];for(let te=0;te<it;te++)Ce.push(c.HEAPU32[Sr/4+te]);c._OrtFree(Sr);let Te=Ce.reduce((te,ae)=>te*ae,1);oe=yd(Xe);let at=i?.outputPreferredLocations[s[G]];if(oe==="string"){if(at==="gpu-buffer"||at==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let te=[],ae=ie/4;for(let Ge=0;Ge<Te;Ge++){let jt=c.HEAPU32[ae++],Or=Ge===Te-1?void 0:c.HEAPU32[ae]-jt;te.push(c.UTF8ToString(jt,Or))}we.push([oe,Ce,te,"cpu"])}else if(at==="gpu-buffer"&&Te>0){let te=c.jsepGetBuffer;if(!te)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let ae=te(ie),Ge=sr(Xe,Te);if(Ge===void 0||!ai(oe))throw new Error(`Unsupported data type: ${oe}`);vt=!0,we.push([oe,Ce,{gpuBuffer:ae,download:c.jsepCreateDownloader(ae,Ge,oe),dispose:()=>{c._OrtReleaseTensor(We)}},"gpu-buffer"])}else if(at==="ml-tensor"&&Te>0){let te=c.jsepEnsureTensor;if(!te)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(sr(Xe,Te)===void 0||!si(oe))throw new Error(`Unsupported data type: ${oe}`);let ae=await te(ie,Xe,Ce,!1);vt=!0,we.push([oe,Ce,{mlTensor:ae,download:c.jsepCreateMLTensorDownloader(ie,oe),dispose:()=>{c.jsepReleaseTensorId(ie),c._OrtReleaseTensor(We)}},"ml-tensor"])}else{let te=wd(oe),ae=new te(Te);new Uint8Array(ae.buffer,ae.byteOffset,ae.byteLength).set(c.HEAPU8.subarray(ie,ie+ae.byteLength)),we.push([oe,Ce,ae,"cpu"])}}finally{c.stackRestore(_r),oe==="string"&&ie&&c._free(ie),vt||c._OrtReleaseTensor(We)}}return i&&!d&&(c._OrtClearBoundOutputs(i.handle),dt.set(e,[a,t,u,i,d,!1])),we}finally{c.stackRestore(F),w.forEach(Ae=>c._OrtReleaseTensor(Ae)),S.forEach(Ae=>c._OrtReleaseTensor(Ae)),$.forEach(Ae=>c._free(Ae)),x!==0&&c._OrtReleaseRunOptions(x),E.forEach(Ae=>c._free(Ae))}},fi=e=>{let r=he(),o=dt.get(e);if(!o)throw new Error("invalid session id");let s=o[0],p=r._OrtEndProfiling(s);p===0&&se("Can't get an profile file name."),r._OrtFree(p)},gi=e=>{let r=[];for(let o of e){let s=o[2];!Array.isArray(s)&&"buffer"in s&&r.push(s.buffer)}return r}}),Ye,$e,St,Jt,Yt,Br,io,Vr,ht,ft,Xu,Od,Ed,Id,Pd,Ad,$d,Dd,Nd=I(()=>{"use strict";ze(),Sd(),Ct(),rn(),Ye=()=>!!j.wasm.proxy&&typeof document<"u",St=!1,Jt=!1,Yt=!1,Vr=new Map,ht=(e,r)=>{let o=Vr.get(e);o?o.push(r):Vr.set(e,[r])},ft=()=>{if(St||!Jt||Yt||!$e)throw new Error("worker not ready")},Xu=e=>{switch(e.data.type){case"init-wasm":St=!1,e.data.err?(Yt=!0,io[1](e.data.err)):(Jt=!0,io[0]()),Br&&(URL.revokeObjectURL(Br),Br=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let r=Vr.get(e.data.type);e.data.err?r.shift()[1](e.data.err):r.shift()[0](e.data.out);break}default:}},Od=async()=>{if(!Jt){if(St)throw new Error("multiple calls to 'initWasm()' detected.");if(Yt)throw new Error("previous call to 'initWasm()' failed.");if(St=!0,Ye())return new Promise((e,r)=>{$e?.terminate(),fd().then(([o,s])=>{try{$e=s,$e.onerror=l=>r(l),$e.onmessage=Xu,io=[e,r];let p={type:"init-wasm",in:j};$e.postMessage(p),Br=o}catch(p){r(p)}},r)});try{await oi(j.wasm),await li(j),Jt=!0}catch(e){throw Yt=!0,e}finally{St=!1}}},Ed=async e=>{if(Ye())return ft(),new Promise((r,o)=>{ht("init-ep",[r,o]);let s={type:"init-ep",in:{epName:e,env:j}};$e.postMessage(s)});await pi(j,e)},Id=async e=>Ye()?(ft(),new Promise((r,o)=>{ht("copy-from",[r,o]);let s={type:"copy-from",in:{buffer:e}};$e.postMessage(s,[e.buffer])})):Zr(e),Pd=async(e,r)=>{if(Ye()){if(r?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return ft(),new Promise((o,s)=>{ht("create",[o,s]);let p={type:"create",in:{model:e,options:{...r}}},l=[];e instanceof Uint8Array&&l.push(e.buffer),$e.postMessage(p,l)})}else return ci(e,r)},Ad=async e=>{if(Ye())return ft(),new Promise((r,o)=>{ht("release",[r,o]);let s={type:"release",in:e};$e.postMessage(s)});di(e)},$d=async(e,r,o,s,p,l)=>{if(Ye()){if(o.some(c=>c[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(p.some(c=>c))throw new Error("pre-allocated output tensor is not supported for proxy.");return ft(),new Promise((c,n)=>{ht("run",[c,n]);let a=o,t={type:"run",in:{sessionId:e,inputIndices:r,inputs:a,outputIndices:s,options:l}};$e.postMessage(t,gi(a))})}else return hi(e,r,o,s,p,l)},Dd=async e=>{if(Ye())return ft(),new Promise((r,o)=>{ht("end-profiling",[r,o]);let s={type:"end-profiling",in:e};$e.postMessage(s)});fi(e)}}),ao,Ku,kd,mm=I(()=>{"use strict";ze(),Nd(),Td(),ni(),_d(),ao=(e,r)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${r()}`)}},Ku=e=>{switch(e[3]){case"cpu":return new fe(e[0],e[2],e[1]);case"gpu-buffer":{let r=e[0];if(!ai(r))throw new Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:o,download:s,dispose:p}=e[2];return fe.fromGpuBuffer(o,{dataType:r,dims:e[1],download:s,dispose:p})}case"ml-tensor":{let r=e[0];if(!si(r))throw new Error(`not supported data type: ${r} for deserializing MLTensor tensor`);let{mlTensor:o,download:s,dispose:p}=e[2];return fe.fromMLTensor(o,{dataType:r,dims:e[1],download:s,dispose:p})}default:throw new Error(`invalid data location: ${e[3]}`)}},kd=class{async fetchModelAndCopyToWasmMemory(e){return Id(await ui(e))}async loadModel(e,r){Pt();let o;typeof e=="string"?o=await this.fetchModelAndCopyToWasmMemory(e):o=e,[this.sessionId,this.inputNames,this.outputNames]=await Pd(o,r),At()}async dispose(){return Ad(this.sessionId)}async run(e,r,o){Pt();let s=[],p=[];Object.entries(e).forEach(i=>{let d=i[0],h=i[1],m=this.inputNames.indexOf(d);if(m===-1)throw new Error(`invalid input '${d}'`);s.push(h),p.push(m)});let l=[],c=[];Object.entries(r).forEach(i=>{let d=i[0],h=i[1],m=this.outputNames.indexOf(d);if(m===-1)throw new Error(`invalid output '${d}'`);l.push(h),c.push(m)});let n=s.map((i,d)=>ao(i,()=>`input "${this.inputNames[p[d]]}"`)),a=l.map((i,d)=>i?ao(i,()=>`output "${this.outputNames[c[d]]}"`):null),t=await $d(this.sessionId,p,n,c,a,o),u={};for(let i=0;i<t.length;i++)u[this.outputNames[c[i]]]=l[i]??Ku(t[i]);return At(),u}startProfiling(){}endProfiling(){Dd(this.sessionId)}}}),Fd={};mr(Fd,{OnnxruntimeWebAssemblyBackend:()=>Uo,initializeFlags:()=>zo,wasmBackend:()=>Cd});var zo,Uo,Cd,bm=I(()=>{"use strict";ze(),Nd(),mm(),rn(),zo=()=>{if((typeof j.wasm.initTimeout!="number"||j.wasm.initTimeout<0)&&(j.wasm.initTimeout=0),j.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof j.wasm.proxy!="boolean"&&(j.wasm.proxy=!1),typeof j.wasm.trace!="boolean"&&(j.wasm.trace=!1),typeof j.wasm.numThreads!="number"||!Number.isInteger(j.wasm.numThreads)||j.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)j.wasm.numThreads=1;else{let e=typeof navigator>"u"?yh("node:os").cpus().length:navigator.hardwareConcurrency;j.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Uo=class{async init(e){zo(),await Od(),await Ed(e)}async createInferenceSessionHandler(e,r){let o=new kd;return await o.loadModel(e,r),Promise.resolve(o)}},Cd=new Uo});ze();ze();ze();var ym="1.20.1",xm=gl;{let e=(cm(),Gr(ud)).onnxjsBackend;dr("webgl",e,-10)}{let e=(bm(),Gr(Fd)).wasmBackend;dr("cpu",e,10),dr("wasm",e,10)}Object.defineProperty(j.versions,"web",{value:ym,enumerable:!0});var Lt=class e{constructor(){this.metrics=[]}static getInstance(){return this.instance||(this.instance=new e),this.instance}trackModelPerformance(r){let o=performance.now()-r;this.metrics.push({modelLoadTime:o,inferenceTime:0}),o>5e3&&console.warn("Model loading is taking longer than expected")}getMetrics(){return this.metrics}};var nn=class{constructor(){this.model=null;this.performance=Lt.getInstance();this.isInitializing=!1}async initialize(){if(this.model)return!0;if(this.isInitializing)return!1;this.isInitializing=!0;let r=performance.now();try{return this.model=await Yr.create("models/detector.onnx",{executionProviders:["wasm"],graphOptimizationLevel:"all"}),this.performance.trackModelPerformance(r),!0}catch(o){return console.error("Failed to initialize model:",o),!1}finally{this.isInitializing=!1}}async analyzeContent(r){this.model||await this.initialize();let o=Math.random()*.5+.3,s=Math.min(.9,o+.1);return{trustScore:{score:o,confidence:s,timestamp:Date.now()},factChecks:[],warnings:r.length<100?["Content too short for reliable analysis"]:[]}}};var mi=class{constructor(){this.detector=new nn,this.cache=new Map,this.performance=Lt.getInstance(),this.initialize()}async initialize(){await this.detector.initialize(),this.setupMessageListeners()}setupMessageListeners(){chrome.runtime.onMessage.addListener((r,o,s)=>{if(r.type==="ANALYZE_PAGE")return this.handleAnalysis(r.content,o.tab?.url).then(s),!0})}async handleAnalysis(r,o){if(!o)return null;if(this.cache.has(o))return this.cache.get(o);let s=performance.now();try{let p=await this.detector.analyzeContent(r);return this.performance.trackModelPerformance(s),this.cache.set(o,p),p}catch(p){return console.error("Analysis failed:",p),null}}};new mi;})();
/*! Bundled license information:

onnxruntime-web/dist/ort.bundle.min.mjs:
  (*!
   * ONNX Runtime Web v1.20.1
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

onnxruntime-web/dist/ort.bundle.min.mjs:
  (*! Bundled license information:
  
  long/index.js:
    (**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     *)
  *)
*/
