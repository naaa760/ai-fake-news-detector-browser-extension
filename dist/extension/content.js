"use strict";(()=>{var le=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(r,o)=>(typeof require<"u"?require:r)[o]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var zr={};var hh=Object.create,Zr=Object.defineProperty,fh=Object.getOwnPropertyDescriptor,gh=Object.getOwnPropertyNames,mh=Object.getPrototypeOf,bh=Object.prototype.hasOwnProperty,yh=(t=>typeof le<"u"?le:typeof Proxy<"u"?new Proxy(t,{get:(r,o)=>(typeof le<"u"?le:r)[o]}):t)(function(t){if(typeof le<"u")return le.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),I=(t,r)=>()=>(t&&(r=t(t=0)),r),nt=(t,r)=>()=>(r||t((r={exports:{}}).exports,r),r.exports),gr=(t,r)=>{for(var o in r)Zr(t,o,{get:r[o],enumerable:!0})},Zu=(t,r,o,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let p of gh(r))!bh.call(t,p)&&p!==o&&Zr(t,p,{get:()=>r[p],enumerable:!(s=fh(r,p))||s.enumerable});return t},Ie=(t,r,o)=>(o=t!=null?hh(mh(t)):{},Zu(r||!t||!t.__esModule?Zr(o,"default",{value:t,enumerable:!0}):o,t)),Ur=t=>Zu(Zr({},"__esModule",{value:!0}),t),Me,Zt,cr,ba,Go,Ho=I(()=>{"use strict";Me=new Map,Zt=[],cr=(t,r,o)=>{if(r&&typeof r.init=="function"&&typeof r.createInferenceSessionHandler=="function"){let s=Me.get(t);if(s===void 0)Me.set(t,{backend:r,priority:o});else{if(s.priority>o)return;if(s.priority===o&&s.backend!==r)throw new Error(`cannot register backend "${t}" using priority ${o}`)}if(o>=0){let p=Zt.indexOf(t);p!==-1&&Zt.splice(p,1);for(let l=0;l<Zt.length;l++)if(Me.get(Zt[l]).priority<=o){Zt.splice(l,0,t);return}Zt.push(t)}return}throw new TypeError("not a valid backend")},ba=async t=>{let r=Me.get(t);if(!r)return"backend not found.";if(r.initialized)return r.backend;if(r.aborted)return r.error;{let o=!!r.initPromise;try{return o||(r.initPromise=r.backend.init(t)),await r.initPromise,r.initialized=!0,r.backend}catch(s){return o||(r.error=`${s}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},Go=async t=>{let r=t.executionProviders||[],o=r.map(a=>typeof a=="string"?a:a.name),s=o.length===0?Zt:o,p,l=[],c=new Set;for(let a of s){let e=await ba(a);typeof e=="string"?l.push({name:a,err:e}):(p||(p=e),p===e&&c.add(a))}if(!p)throw new Error(`no available backend found. ERR: ${l.map(a=>`[${a.name}] ${a.err}`).join(", ")}`);for(let{name:a,err:e}of l)o.includes(a)&&console.warn(`removing requested execution provider "${a}" from session options because it is not available: ${e}`);let n=r.filter(a=>c.has(typeof a=="string"?a:a.name));return[p,new Proxy(t,{get:(a,e)=>e==="executionProviders"?n:Reflect.get(a,e)})]}}),wh=I(()=>{"use strict";Ho()}),Ju,vh=I(()=>{"use strict";Ju="1.20.1"}),yn,Dt,Yu=I(()=>{"use strict";vh(),yn="warning",Dt={wasm:{},webgl:{},webgpu:{},versions:{common:Ju},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);yn=t}},get logLevel(){return yn}},Object.defineProperty(Dt,"logLevel",{enumerable:!0})}),B,xh=I(()=>{"use strict";Yu(),B=Dt}),Qu,tl,Th=I(()=>{"use strict";Qu=(t,r)=>{let o=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);o.width=t.dims[3],o.height=t.dims[2];let s=o.getContext("2d");if(s!=null){let p,l;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(p=t.dims[2],l=t.dims[3]):(p=t.dims[3],l=t.dims[2]);let c=r?.format!==void 0?r.format:"RGB",n=r?.norm,a,e;n===void 0||n.mean===void 0?a=[255,255,255,255]:typeof n.mean=="number"?a=[n.mean,n.mean,n.mean,n.mean]:(a=[n.mean[0],n.mean[1],n.mean[2],0],n.mean[3]!==void 0&&(a[3]=n.mean[3])),n===void 0||n.bias===void 0?e=[0,0,0,0]:typeof n.bias=="number"?e=[n.bias,n.bias,n.bias,n.bias]:(e=[n.bias[0],n.bias[1],n.bias[2],0],n.bias[3]!==void 0&&(e[3]=n.bias[3]));let u=l*p,i=0,d=u,h=u*2,m=-1;c==="RGBA"?(i=0,d=u,h=u*2,m=u*3):c==="RGB"?(i=0,d=u,h=u*2):c==="RBG"&&(i=0,h=u,d=u*2);for(let b=0;b<l;b++)for(let x=0;x<p;x++){let E=(t.data[i++]-e[0])*a[0],w=(t.data[d++]-e[1])*a[1],S=(t.data[h++]-e[2])*a[2],$=m===-1?255:(t.data[m++]-e[3])*a[3];s.fillStyle="rgba("+E+","+w+","+S+","+$+")",s.fillRect(x,b,1,1)}if("toDataURL"in o)return o.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},tl=(t,r)=>{let o=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(o!=null){let p,l,c;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(p=t.dims[2],l=t.dims[1],c=t.dims[3]):(p=t.dims[3],l=t.dims[2],c=t.dims[1]);let n=r!==void 0&&r.format!==void 0?r.format:"RGB",a=r?.norm,e,u;a===void 0||a.mean===void 0?e=[255,255,255,255]:typeof a.mean=="number"?e=[a.mean,a.mean,a.mean,a.mean]:(e=[a.mean[0],a.mean[1],a.mean[2],255],a.mean[3]!==void 0&&(e[3]=a.mean[3])),a===void 0||a.bias===void 0?u=[0,0,0,0]:typeof a.bias=="number"?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(u[3]=a.bias[3]));let i=l*p;if(r!==void 0&&(r.format!==void 0&&c===4&&r.format!=="RGBA"||c===3&&r.format!=="RGB"&&r.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,h=0,m=1,b=2,x=3,E=0,w=i,S=i*2,$=-1;n==="RGBA"?(E=0,w=i,S=i*2,$=i*3):n==="RGB"?(E=0,w=i,S=i*2):n==="RBG"&&(E=0,S=i,w=i*2),s=o.createImageData(p,l);for(let F=0;F<l*p;h+=d,m+=d,b+=d,x+=d,F++)s.data[h]=(t.data[E++]-u[0])*e[0],s.data[m]=(t.data[w++]-u[1])*e[1],s.data[b]=(t.data[S++]-u[2])*e[2],s.data[x]=$===-1?255:(t.data[$++]-u[3])*e[3]}else throw new Error("Can not access image data");return s}}),Nr,el,rl,nl,ol,il,_h=I(()=>{"use strict";qo(),Nr=(t,r)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(r.height===void 0||r.width===void 0)throw new Error("Image height and width must be defined");if(r.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:o,width:s}=r,p=r.norm??{mean:255,bias:0},l,c;typeof p.mean=="number"?l=[p.mean,p.mean,p.mean,p.mean]:l=[p.mean[0],p.mean[1],p.mean[2],p.mean[3]??255],typeof p.bias=="number"?c=[p.bias,p.bias,p.bias,p.bias]:c=[p.bias[0],p.bias[1],p.bias[2],p.bias[3]??0];let n=r.format!==void 0?r.format:"RGBA",a=r.tensorFormat!==void 0&&r.tensorFormat!==void 0?r.tensorFormat:"RGB",e=o*s,u=a==="RGBA"?new Float32Array(e*4):new Float32Array(e*3),i=4,d=0,h=1,m=2,b=3,x=0,E=e,w=e*2,S=-1;n==="RGB"&&(i=3,d=0,h=1,m=2,b=-1),a==="RGBA"?S=e*3:a==="RBG"?(x=0,w=e,E=e*2):a==="BGR"&&(w=0,E=e,x=e*2);for(let $=0;$<e;$++,d+=i,m+=i,h+=i,b+=i)u[x++]=(t[d]+c[0])/l[0],u[E++]=(t[h]+c[1])/l[1],u[w++]=(t[m]+c[2])/l[2],S!==-1&&b!==-1&&(u[S++]=(t[b]+c[3])/l[3]);return a==="RGBA"?new It("float32",u,[1,4,o,s]):new It("float32",u,[1,3,o,s])},el=async(t,r)=>{let o=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,s=typeof ImageData<"u"&&t instanceof ImageData,p=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,l=typeof t=="string",c,n=r??{},a=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},e=u=>typeof HTMLCanvasElement<"u"&&u instanceof HTMLCanvasElement||u instanceof OffscreenCanvas?u.getContext("2d"):null;if(o){let u=a();u.width=t.width,u.height=t.height;let i=e(u);if(i!=null){let d=t.height,h=t.width;if(r!==void 0&&r.resizedHeight!==void 0&&r.resizedWidth!==void 0&&(d=r.resizedHeight,h=r.resizedWidth),r!==void 0){if(n=r,r.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");n.tensorFormat="RGBA",n.height=d,n.width=h}else n.tensorFormat="RGBA",n.height=d,n.width=h;i.drawImage(t,0,0),c=i.getImageData(0,0,h,d).data}else throw new Error("Can not access image data")}else if(s){let u,i;if(r!==void 0&&r.resizedWidth!==void 0&&r.resizedHeight!==void 0?(u=r.resizedHeight,i=r.resizedWidth):(u=t.height,i=t.width),r!==void 0&&(n=r),n.format="RGBA",n.height=u,n.width=i,r!==void 0){let d=a();d.width=i,d.height=u;let h=e(d);if(h!=null)h.putImageData(t,0,0),c=h.getImageData(0,0,i,u).data;else throw new Error("Can not access image data")}else c=t.data}else if(p){if(r===void 0)throw new Error("Please provide image config with format for Imagebitmap");let u=a();u.width=t.width,u.height=t.height;let i=e(u);if(i!=null){let d=t.height,h=t.width;return i.drawImage(t,0,0,h,d),c=i.getImageData(0,0,h,d).data,n.height=d,n.width=h,Nr(c,n)}else throw new Error("Can not access image data")}else{if(l)return new Promise((u,i)=>{let d=a(),h=e(d);if(!t||!h)return i();let m=new Image;m.crossOrigin="Anonymous",m.src=t,m.onload=()=>{d.width=m.width,d.height=m.height,h.drawImage(m,0,0,d.width,d.height);let b=h.getImageData(0,0,d.width,d.height);n.height=d.height,n.width=d.width,u(Nr(b.data,n))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(c!==void 0)return Nr(c,n);throw new Error("Input data provided is not supported - aborted tensor creation")},rl=(t,r)=>{let{width:o,height:s,download:p,dispose:l}=r,c=[1,s,o,4];return new It({location:"texture",type:"float32",texture:t,dims:c,download:p,dispose:l})},nl=(t,r)=>{let{dataType:o,dims:s,download:p,dispose:l}=r;return new It({location:"gpu-buffer",type:o??"float32",gpuBuffer:t,dims:s,download:p,dispose:l})},ol=(t,r)=>{let{dataType:o,dims:s,download:p,dispose:l}=r;return new It({location:"ml-tensor",type:o??"float32",mlTensor:t,dims:s,download:p,dispose:l})},il=(t,r,o)=>new It({location:"cpu-pinned",type:t,data:r,dims:o??[r.length]})}),me,Ye,wn,al,Sh=I(()=>{"use strict";me=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Ye=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),wn=!1,al=()=>{if(!wn){wn=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,r=typeof BigUint64Array<"u"&&BigUint64Array.from,o=typeof Float16Array<"u"&&Float16Array.from;t&&(me.set("int64",BigInt64Array),Ye.set(BigInt64Array,"int64")),r&&(me.set("uint64",BigUint64Array),Ye.set(BigUint64Array,"uint64")),o?(me.set("float16",Float16Array),Ye.set(Float16Array,"float16")):me.set("float16",Uint16Array)}}}),sl,ul,Oh=I(()=>{"use strict";qo(),sl=t=>{let r=1;for(let o=0;o<t.length;o++){let s=t[o];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${o}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${s}`);r*=s}return r},ul=(t,r)=>{switch(t.location){case"cpu":return new It(t.type,t.data,r);case"cpu-pinned":return new It({location:"cpu-pinned",data:t.data,type:t.type,dims:r});case"texture":return new It({location:"texture",texture:t.texture,type:t.type,dims:r});case"gpu-buffer":return new It({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:r});case"ml-tensor":return new It({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:r});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}),It,qo=I(()=>{"use strict";Th(),_h(),Sh(),Oh(),It=class{constructor(t,r,o){al();let s,p;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,s=t.type,p=t.dims,t.location){case"cpu-pinned":{let c=me.get(s);if(!c)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(t.data instanceof c))throw new TypeError(`buffer should be of type ${c.name}`);this.cpuData=t.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let c,n;if(typeof t=="string")if(s=t,n=o,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");c=r}else{let a=me.get(t);if(a===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16"&&a===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${a.name} as data.`);t==="uint64"||t==="int64"?c=a.from(r,BigInt):c=a.from(r)}else if(r instanceof a)c=r;else if(r instanceof Uint8ClampedArray)if(t==="uint8")c=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${s} tensor's data must be type of ${a}`)}else if(n=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let a=typeof t[0];if(a==="string")s="string",c=t;else if(a==="boolean")s="bool",c=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${a}.`)}else if(t instanceof Uint8ClampedArray)s="uint8",c=Uint8Array.from(t);else{let a=Ye.get(t.constructor);if(a===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);s=a,c=t}if(n===void 0)n=[c.length];else if(!Array.isArray(n))throw new TypeError("A tensor's dims must be a number array");p=n,this.cpuData=c,this.dataLocation="cpu"}let l=sl(p);if(this.cpuData&&l!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(l/2)===this.cpuData.length))throw new Error(`Tensor's size(${l}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=p,this.size=l}static async fromImage(t,r){return el(t,r)}static fromTexture(t,r){return rl(t,r)}static fromGpuBuffer(t,r){return nl(t,r)}static fromMLTensor(t,r){return ol(t,r)}static fromPinnedBuffer(t,r,o){return il(t,r,o)}toDataURL(t){return Qu(this,t)}toImageData(t){return tl(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return ul(this,t)}}}),ft,Wo=I(()=>{"use strict";qo(),ft=It}),so,vn,Pe,Ae,ll=I(()=>{"use strict";Yu(),so=(t,r)=>{(typeof Dt.trace>"u"?!Dt.wasm.trace:!Dt.trace)||console.timeStamp(`${t}::ORT::${r}`)},vn=(t,r)=>{let o=new Error().stack?.split(/\r\n|\r|\n/g)||[],s=!1;for(let p=0;p<o.length;p++){if(s&&!o[p].includes("TRACE_FUNC")){let l=`FUNC_${t}::${o[p].trim().split(" ")[1]}`;r&&(l+=`::${r}`),so("CPU",l);return}o[p].includes("TRACE_FUNC")&&(s=!0)}},Pe=t=>{(typeof Dt.trace>"u"?!Dt.wasm.trace:!Dt.trace)||vn("BEGIN",t)},Ae=t=>{(typeof Dt.trace>"u"?!Dt.wasm.trace:!Dt.trace)||vn("END",t)}}),pl,Eh=I(()=>{"use strict";Ho(),Wo(),ll(),pl=class cl{constructor(r){this.handler=r}async run(r,o,s){Pe();let p={},l={};if(typeof r!="object"||r===null||r instanceof ft||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof o=="object"){if(o===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(o instanceof ft)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(o)){if(o.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(let e of o){if(typeof e!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(e)===-1)throw new RangeError(`'fetches' contains invalid output name: ${e}.`);p[e]=null}if(typeof s=="object"&&s!==null)l=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,u=Object.getOwnPropertyNames(o);for(let i of this.outputNames)if(u.indexOf(i)!==-1){let d=o[i];(d===null||d instanceof ft)&&(e=!0,c=!1,p[i]=d)}if(e){if(typeof s=="object"&&s!==null)l=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else l=o}}else if(typeof o<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let e of this.inputNames)if(typeof r[e]>"u")throw new Error(`input '${e}' is missing in 'feeds'.`);if(c)for(let e of this.outputNames)p[e]=null;let n=await this.handler.run(r,p,l),a={};for(let e in n)if(Object.hasOwnProperty.call(n,e)){let u=n[e];u instanceof ft?a[e]=u:a[e]=new ft(u.type,u.data,u.dims)}return Ae(),a}async release(){return this.handler.dispose()}static async create(r,o,s,p){Pe();let l,c={};if(typeof r=="string"){if(l=r,typeof o=="object"&&o!==null)c=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(l=r,typeof o=="object"&&o!==null)c=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer){let u=r,i=0,d=r.byteLength;if(typeof o=="object"&&o!==null)c=o;else if(typeof o=="number"){if(i=o,!Number.isSafeInteger(i))throw new RangeError("'byteOffset' must be an integer.");if(i<0||i>=u.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${u.byteLength}).`);if(d=r.byteLength-i,typeof s=="number"){if(d=s,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||i+d>u.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${u.byteLength-i}].`);if(typeof p=="object"&&p!==null)c=p;else if(typeof p<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof o<"u")throw new TypeError("'options' must be an object.");l=new Uint8Array(u,i,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[n,a]=await Go(c),e=await n.createInferenceSessionHandler(l,a);return Ae(),new cl(e)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Jr,Ih=I(()=>{"use strict";Eh(),Jr=pl}),Ph=I(()=>{"use strict"}),Ah=I(()=>{"use strict"}),$h=I(()=>{"use strict"}),Dh=I(()=>{"use strict"}),ya,dl,Nh=I(()=>{"use strict";Ho(),Wo(),ya="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",dl=class hl{constructor(r,o,s){this.handler=r,this.hasOptimizerModel=o,this.hasEvalModel=s}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(r,o){let s=r.evalModel||"",p=r.optimizerModel||"",l=o||{},[c,n]=await Go(l);if(c.createTrainingSessionHandler){let a=await c.createTrainingSessionHandler(r.checkpointState,r.trainModel,s,p,n);return new hl(a,!!r.optimizerModel,!!r.evalModel)}else throw new Error(ya)}typeNarrowingForRunStep(r,o,s,p,l){let c={},n={};if(typeof s!="object"||s===null||s instanceof ft||Array.isArray(s))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof p=="object"){if(p===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(p instanceof ft)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(p)){if(p.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let e of p){if(typeof e!="string")throw new TypeError("'fetches' must be a string array or an object.");if(o.indexOf(e)===-1)throw new RangeError(`'fetches' contains invalid output name: ${e}.`);c[e]=null}if(typeof l=="object"&&l!==null)n=l;else if(typeof l<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,u=Object.getOwnPropertyNames(p);for(let i of o)if(u.indexOf(i)!==-1){let d=p[i];(d===null||d instanceof ft)&&(e=!0,a=!1,c[i]=d)}if(e){if(typeof l=="object"&&l!==null)n=l;else if(typeof l<"u")throw new TypeError("'options' must be an object.")}else n=p}}else if(typeof p<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let e of r)if(typeof s[e]>"u")throw new Error(`input '${e}' is missing in 'feeds'.`);if(a)for(let e of o)c[e]=null;return[c,n]}convertHandlerReturnTypeToMapOfTensors(r){let o={};for(let s in r)if(Object.hasOwnProperty.call(r,s)){let p=r[s];p instanceof ft?o[s]=p:o[s]=new ft(p.type,p.data,p.dims)}return o}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(r,o,s){let[p,l]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,r,o,s),c=await this.handler.runTrainStep(r,p,l);return this.convertHandlerReturnTypeToMapOfTensors(c)}async runOptimizerStep(r){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(r||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(r,o,s){if(this.hasEvalModel){let[p,l]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,r,o,s),c=await this.handler.runEvalStep(r,p,l);return this.convertHandlerReturnTypeToMapOfTensors(c)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(r=!0){return this.handler.getParametersSize(r)}async loadParametersBuffer(r,o=!0){let s=await this.getParametersSize(o);if(r.length!==4*s)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(r,o)}async getContiguousParameters(r=!0){return this.handler.getContiguousParameters(r)}async release(){return this.handler.dispose()}}}),fl,kh=I(()=>{"use strict";Nh(),fl=dl}),gl={};gr(gl,{InferenceSession:()=>Jr,TRACE:()=>so,TRACE_FUNC_BEGIN:()=>Pe,TRACE_FUNC_END:()=>Ae,Tensor:()=>ft,TrainingSession:()=>fl,env:()=>B,registerBackend:()=>cr});var zt=I(()=>{"use strict";wh(),xh(),Ih(),Wo(),Ph(),Ah(),ll(),$h(),Dh(),kh()});function be(t,r,o,s){if(r===void 0)return Fh(t);if(o===void 0)kr(t,r,1);else if(typeof o=="number"&&s===void 0)kr(t,r,o);else if(typeof o=="string"&&s===void 0)kr(t,o,1,r);else if(typeof o=="string"&&typeof s=="number")kr(t,o,s,r);else throw new TypeError("input is valid")}function Fh(t){return{verbose:be.verbose.bind(null,t),info:be.info.bind(null,t),warning:be.warning.bind(null,t),error:be.error.bind(null,t),fatal:be.fatal.bind(null,t)}}function kr(t,r,o,s){let p=Ee[s||""]||Ee[""];uo[t]<uo[p.minimalSeverity]||(p.logDateTime&&(r=`${new Date().toISOString()}|${r}`),p.logSourceLocation,ml[p.provider].log(t,r,s))}var wa,va,uo,ml,xn,Ee,tt,Tn,_n,bl,ze,Rt=I(()=>{"use strict";wa=class{log(t,r,o){}},va=class{log(t,r,o){console.log(`${this.color(t)} ${o?"\x1B[35m"+o+"\x1B[0m ":""}${r}`)}color(t){switch(t){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${t}`)}}},uo={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},ml={none:new wa,console:new va},xn={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Ee={"":xn},(t=>{function r(e,u){t("verbose",e,u)}t.verbose=r;function o(e,u){t("info",e,u)}t.info=o;function s(e,u){t("warning",e,u)}t.warning=s;function p(e,u){t("error",e,u)}t.error=p;function l(e,u){t("fatal",e,u)}t.fatal=l;function c(e){Ee={},n("",e||{})}t.reset=c;function n(e,u){if(e==="*")c(u);else{let i=Ee[e]||xn;Ee[e]={provider:u.provider||i.provider,minimalSeverity:u.minimalSeverity||i.minimalSeverity,logDateTime:u.logDateTime===void 0?i.logDateTime:u.logDateTime,logSourceLocation:u.logSourceLocation===void 0?i.logSourceLocation:u.logSourceLocation}}}t.set=n;function a(e){let u={};e.logLevel&&(u.minimalSeverity=e.logLevel),n("",u)}t.setWithEnv=a})(be||={}),tt=be,Tn=class{constructor(t,r,o,s,p,l){this.category=t,this.name=r,this.startTime=o,this.endCallback=s,this.timer=p,this.ctx=l}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},_n=class{constructor(t,r,o,s){this.category=t,this.name=r,this.startTime=o,this.endTime=s}},bl=class{constructor(t,r,o){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=t===void 0?1e4:t,this._flushBatchSize=r===void 0?10:r,this._flushIntervalInMilliseconds=o===void 0?5e3:o}static create(t){return t===void 0?new this:new this(t.maxNumberEvents,t.flushBatchSize,t.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=ze(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(t,r,o,s){let p=this._started?this.begin(t,r,s):void 0,l=!1,c=o();if(c&&typeof c.then=="function")return l=!0,new Promise((n,a)=>{c.then(async e=>{p&&await p.end(),n(e)},async e=>{p&&await p.end(),a(e)})});if(!l&&p){let n=p.end();if(n&&typeof n.then=="function")return new Promise((a,e)=>{n.then(()=>{a(c)},u=>{e(u)})})}return c}begin(t,r,o){if(!this._started)throw new Error("profiler is not started yet");if(o===void 0){let s=ze();return this.flush(s),new Tn(t,r,s,p=>this.endSync(p))}else{let s=o.beginTimer();return new Tn(t,r,0,async p=>this.end(p),s,o)}}async end(t){let r=await t.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new _n(t.category,t.name,t.startTime,r)),this.flush(r))}endSync(t){let r=ze();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new _n(t.category,t.name,t.startTime,r)),this.flush(r))}logOneEvent(t){tt.verbose(`Profiler.${t.category}`,`${(t.endTime-t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`)}flush(t){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||t-this._flushTime>=this._flushIntervalInMilliseconds){for(let r=this._flushPointer;this._flushPointer<r+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=ze()}}get started(){return this._started}},ze=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Ch(t,r,o){for(let s of o){let p=s[0],l=s[1],c=s[2],n=s[3],a=s[4];if(t.opType===p){for(let e of r)if((e.domain===l||e.domain==="ai.onnx"&&l==="")&&Lh(e.version,c))return{opImpl:n,opInit:a}}}throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${r.map(s=>`${s.domain||"ai.onnx"} v${s.version}`).join(", ")}`)}function Lh(t,r){if(r.endsWith("+")){let o=Number.parseInt(r.substring(0,r.length-1),10);return!isNaN(o)&&o<=t}else if(r.split("-").length===2){let o=r.split("-"),s=Number.parseInt(o[0],10),p=Number.parseInt(o[1],10);return!isNaN(s)&&!isNaN(p)&&s<=t&&t<=p}else return Number.parseInt(r,10)===t}var Rh=I(()=>{"use strict"}),Bh=nt(t=>{"use strict";t.__esModule=!0;var r=function(){function o(s){if(!s)throw new TypeError("Invalid argument; `value` has no value.");this.value=o.EMPTY,s&&o.isGuid(s)&&(this.value=s)}return o.isGuid=function(s){var p=s.toString();return s&&(s instanceof o||o.validator.test(p))},o.create=function(){return new o([o.gen(2),o.gen(1),o.gen(1),o.gen(1),o.gen(3)].join("-"))},o.createEmpty=function(){return new o("emptyguid")},o.parse=function(s){return new o(s)},o.raw=function(){return[o.gen(2),o.gen(1),o.gen(1),o.gen(1),o.gen(3)].join("-")},o.gen=function(s){for(var p="",l=0;l<s;l++)p+=((1+Math.random())*65536|0).toString(16).substring(1);return p},o.prototype.equals=function(s){return o.isGuid(s)&&this.value===s.toString()},o.prototype.isEmpty=function(){return this.value===o.EMPTY},o.prototype.toString=function(){return this.value},o.prototype.toJSON=function(){return{value:this.value}},o.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),o.EMPTY="00000000-0000-0000-0000-000000000000",o}();t.Guid=r});function W(t,r,o){this.low=t|0,this.high=r|0,this.unsigned=!!o}function dt(t){return(t&&t.__isLong__)===!0}function xa(t){var r=Math.clz32(t&-t);return t?31-r:r}function pe(t,r){var o,s,p;return r?(t>>>=0,(p=0<=t&&t<256)&&(s=po[t],s)?s:(o=M(t,0,!0),p&&(po[t]=o),o)):(t|=0,(p=-128<=t&&t<128)&&(s=lo[t],s)?s:(o=M(t,t<0?-1:0,!1),p&&(lo[t]=o),o))}function kt(t,r){if(isNaN(t))return r?jt:Nt;if(r){if(t<0)return jt;if(t>=co)return go}else{if(t<=-ho)return mt;if(t+1>=ho)return fo}return t<0?kt(-t,r).neg():M(t%ye|0,t/ye|0,r)}function M(t,r,o){return new W(t,r,o)}function Xo(t,r,o){if(t.length===0)throw Error("empty string");if(typeof r=="number"?(o=r,r=!1):r=!!r,t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return r?jt:Nt;if(o=o||10,o<2||36<o)throw RangeError("radix");var s;if((s=t.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Xo(t.substring(1),r,o).neg();for(var p=kt(sr(o,8)),l=Nt,c=0;c<t.length;c+=8){var n=Math.min(8,t.length-c),a=parseInt(t.substring(c,c+n),o);if(n<8){var e=kt(sr(o,n));l=l.mul(e).add(kt(a))}else l=l.mul(p),l=l.add(kt(a))}return l.unsigned=r,l}function Lt(t,r){return typeof t=="number"?kt(t,r):typeof t=="string"?Xo(t,r):M(t.low,t.high,typeof r=="boolean"?r:t.unsigned)}var _t,lo,po,sr,Sn,Ta,ye,co,ho,On,Nt,jt,ce,En,Fr,fo,go,mt,A,ee,yl=I(()=>{_t=null;try{_t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}W.prototype.__isLong__,Object.defineProperty(W.prototype,"__isLong__",{value:!0}),W.isLong=dt,lo={},po={},W.fromInt=pe,W.fromNumber=kt,W.fromBits=M,sr=Math.pow,W.fromString=Xo,W.fromValue=Lt,Sn=65536,Ta=1<<24,ye=Sn*Sn,co=ye*ye,ho=co/2,On=pe(Ta),Nt=pe(0),W.ZERO=Nt,jt=pe(0,!0),W.UZERO=jt,ce=pe(1),W.ONE=ce,En=pe(1,!0),W.UONE=En,Fr=pe(-1),W.NEG_ONE=Fr,fo=M(-1,2147483647,!1),W.MAX_VALUE=fo,go=M(-1,-1,!0),W.MAX_UNSIGNED_VALUE=go,mt=M(0,-2147483648,!1),W.MIN_VALUE=mt,A=W.prototype,A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*ye+(this.low>>>0):this.high*ye+(this.low>>>0)},A.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(mt)){var r=kt(t),o=this.div(r),s=o.mul(r).sub(this);return o.toString(t)+s.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var p=kt(sr(t,6),this.unsigned),l=this,c="";;){var n=l.div(p),a=l.sub(n.mul(p)).toInt()>>>0,e=a.toString(t);if(l=n,l.isZero())return e+c;for(;e.length<6;)e="0"+e;c=""+e+c}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(mt)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,r=31;r>0&&!(t&1<<r);r--);return this.high!=0?r+33:r+1},A.isZero=function(){return this.high===0&&this.low===0},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(this.low&1)===1},A.isEven=function(){return(this.low&1)===0},A.equals=function(t){return dt(t)||(t=Lt(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low},A.eq=A.equals,A.notEquals=function(t){return!this.eq(t)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(t){return this.comp(t)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(t){return this.comp(t)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(t){return this.comp(t)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(t){return this.comp(t)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(t){if(dt(t)||(t=Lt(t)),this.eq(t))return 0;var r=this.isNegative(),o=t.isNegative();return r&&!o?-1:!r&&o?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(mt)?mt:this.not().add(ce)},A.neg=A.negate,A.add=function(t){dt(t)||(t=Lt(t));var r=this.high>>>16,o=this.high&65535,s=this.low>>>16,p=this.low&65535,l=t.high>>>16,c=t.high&65535,n=t.low>>>16,a=t.low&65535,e=0,u=0,i=0,d=0;return d+=p+a,i+=d>>>16,d&=65535,i+=s+n,u+=i>>>16,i&=65535,u+=o+c,e+=u>>>16,u&=65535,e+=r+l,e&=65535,M(i<<16|d,e<<16|u,this.unsigned)},A.subtract=function(t){return dt(t)||(t=Lt(t)),this.add(t.neg())},A.sub=A.subtract,A.multiply=function(t){if(this.isZero())return this;if(dt(t)||(t=Lt(t)),_t){var r=_t.mul(this.low,this.high,t.low,t.high);return M(r,_t.get_high(),this.unsigned)}if(t.isZero())return this.unsigned?jt:Nt;if(this.eq(mt))return t.isOdd()?mt:Nt;if(t.eq(mt))return this.isOdd()?mt:Nt;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(On)&&t.lt(On))return kt(this.toNumber()*t.toNumber(),this.unsigned);var o=this.high>>>16,s=this.high&65535,p=this.low>>>16,l=this.low&65535,c=t.high>>>16,n=t.high&65535,a=t.low>>>16,e=t.low&65535,u=0,i=0,d=0,h=0;return h+=l*e,d+=h>>>16,h&=65535,d+=p*e,i+=d>>>16,d&=65535,d+=l*a,i+=d>>>16,d&=65535,i+=s*e,u+=i>>>16,i&=65535,i+=p*a,u+=i>>>16,i&=65535,i+=l*n,u+=i>>>16,i&=65535,u+=o*e+s*a+p*n+l*c,u&=65535,M(d<<16|h,u<<16|i,this.unsigned)},A.mul=A.multiply,A.divide=function(t){if(dt(t)||(t=Lt(t)),t.isZero())throw Error("division by zero");if(_t){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var r=(this.unsigned?_t.div_u:_t.div_s)(this.low,this.high,t.low,t.high);return M(r,_t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?jt:Nt;var o,s,p;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return jt;if(t.gt(this.shru(1)))return En;p=jt}else{if(this.eq(mt)){if(t.eq(ce)||t.eq(Fr))return mt;if(t.eq(mt))return ce;var l=this.shr(1);return o=l.div(t).shl(1),o.eq(Nt)?t.isNegative()?ce:Fr:(s=this.sub(t.mul(o)),p=o.add(s.div(t)),p)}else if(t.eq(mt))return this.unsigned?jt:Nt;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();p=Nt}for(s=this;s.gte(t);){o=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var c=Math.ceil(Math.log(o)/Math.LN2),n=c<=48?1:sr(2,c-48),a=kt(o),e=a.mul(t);e.isNegative()||e.gt(s);)o-=n,a=kt(o,this.unsigned),e=a.mul(t);a.isZero()&&(a=ce),p=p.add(a),s=s.sub(e)}return p},A.div=A.divide,A.modulo=function(t){if(dt(t)||(t=Lt(t)),_t){var r=(this.unsigned?_t.rem_u:_t.rem_s)(this.low,this.high,t.low,t.high);return M(r,_t.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return M(~this.low,~this.high,this.unsigned)},A.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},A.clz=A.countLeadingZeros,A.countTrailingZeros=function(){return this.low?xa(this.low):xa(this.high)+32},A.ctz=A.countTrailingZeros,A.and=function(t){return dt(t)||(t=Lt(t)),M(this.low&t.low,this.high&t.high,this.unsigned)},A.or=function(t){return dt(t)||(t=Lt(t)),M(this.low|t.low,this.high|t.high,this.unsigned)},A.xor=function(t){return dt(t)||(t=Lt(t)),M(this.low^t.low,this.high^t.high,this.unsigned)},A.shiftLeft=function(t){return dt(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?M(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):M(0,this.low<<t-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(t){return dt(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?M(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):M(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(t){return dt(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?M(this.low>>>t|this.high<<32-t,this.high>>>t,this.unsigned):t===32?M(this.high,0,this.unsigned):M(this.high>>>t-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.rotateLeft=function(t){var r;return dt(t)&&(t=t.toInt()),(t&=63)===0?this:t===32?M(this.high,this.low,this.unsigned):t<32?(r=32-t,M(this.low<<t|this.high>>>r,this.high<<t|this.low>>>r,this.unsigned)):(t-=32,r=32-t,M(this.high<<t|this.low>>>r,this.low<<t|this.high>>>r,this.unsigned))},A.rotl=A.rotateLeft,A.rotateRight=function(t){var r;return dt(t)&&(t=t.toInt()),(t&=63)===0?this:t===32?M(this.high,this.low,this.unsigned):t<32?(r=32-t,M(this.high<<r|this.low>>>t,this.low<<r|this.high>>>t,this.unsigned)):(t-=32,r=32-t,M(this.low<<r|this.high>>>t,this.high<<r|this.low>>>t,this.unsigned))},A.rotr=A.rotateRight,A.toSigned=function(){return this.unsigned?M(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:M(this.low,this.high,!0)},A.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var t=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]},A.toBytesBE=function(){var t=this.high,r=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,r>>>24,r>>>16&255,r>>>8&255,r&255]},W.fromBytes=function(t,r,o){return o?W.fromBytesLE(t,r):W.fromBytesBE(t,r)},W.fromBytesLE=function(t,r){return new W(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,r)},W.fromBytesBE=function(t,r){return new W(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],r)},ee=W}),T,Ko=I(()=>{T={},T.Offset,T.Table,T.SIZEOF_SHORT=2,T.SIZEOF_INT=4,T.FILE_IDENTIFIER_LENGTH=4,T.SIZE_PREFIX_LENGTH=4,T.Encoding={UTF8_BYTES:1,UTF16_STRING:2},T.int32=new Int32Array(2),T.float32=new Float32Array(T.int32.buffer),T.float64=new Float64Array(T.int32.buffer),T.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,T.Long=function(t,r){this.low=t|0,this.high=r|0},T.Long.create=function(t,r){return t==0&&r==0?T.Long.ZERO:new T.Long(t,r)},T.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},T.Long.prototype.equals=function(t){return this.low==t.low&&this.high==t.high},T.Long.ZERO=new T.Long(0,0),T.Builder=function(t){if(t)var r=t;else var r=1024;this.bb=T.ByteBuffer.allocate(r),this.space=r,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},T.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},T.Builder.prototype.forceDefaults=function(t){this.force_defaults=t},T.Builder.prototype.dataBuffer=function(){return this.bb},T.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},T.Builder.prototype.prep=function(t,r){t>this.minalign&&(this.minalign=t);for(var o=~(this.bb.capacity()-this.space+r)+1&t-1;this.space<o+t+r;){var s=this.bb.capacity();this.bb=T.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(o)},T.Builder.prototype.pad=function(t){for(var r=0;r<t;r++)this.bb.writeInt8(--this.space,0)},T.Builder.prototype.writeInt8=function(t){this.bb.writeInt8(this.space-=1,t)},T.Builder.prototype.writeInt16=function(t){this.bb.writeInt16(this.space-=2,t)},T.Builder.prototype.writeInt32=function(t){this.bb.writeInt32(this.space-=4,t)},T.Builder.prototype.writeInt64=function(t){this.bb.writeInt64(this.space-=8,t)},T.Builder.prototype.writeFloat32=function(t){this.bb.writeFloat32(this.space-=4,t)},T.Builder.prototype.writeFloat64=function(t){this.bb.writeFloat64(this.space-=8,t)},T.Builder.prototype.addInt8=function(t){this.prep(1,0),this.writeInt8(t)},T.Builder.prototype.addInt16=function(t){this.prep(2,0),this.writeInt16(t)},T.Builder.prototype.addInt32=function(t){this.prep(4,0),this.writeInt32(t)},T.Builder.prototype.addInt64=function(t){this.prep(8,0),this.writeInt64(t)},T.Builder.prototype.addFloat32=function(t){this.prep(4,0),this.writeFloat32(t)},T.Builder.prototype.addFloat64=function(t){this.prep(8,0),this.writeFloat64(t)},T.Builder.prototype.addFieldInt8=function(t,r,o){(this.force_defaults||r!=o)&&(this.addInt8(r),this.slot(t))},T.Builder.prototype.addFieldInt16=function(t,r,o){(this.force_defaults||r!=o)&&(this.addInt16(r),this.slot(t))},T.Builder.prototype.addFieldInt32=function(t,r,o){(this.force_defaults||r!=o)&&(this.addInt32(r),this.slot(t))},T.Builder.prototype.addFieldInt64=function(t,r,o){(this.force_defaults||!r.equals(o))&&(this.addInt64(r),this.slot(t))},T.Builder.prototype.addFieldFloat32=function(t,r,o){(this.force_defaults||r!=o)&&(this.addFloat32(r),this.slot(t))},T.Builder.prototype.addFieldFloat64=function(t,r,o){(this.force_defaults||r!=o)&&(this.addFloat64(r),this.slot(t))},T.Builder.prototype.addFieldOffset=function(t,r,o){(this.force_defaults||r!=o)&&(this.addOffset(r),this.slot(t))},T.Builder.prototype.addFieldStruct=function(t,r,o){r!=o&&(this.nested(r),this.slot(t))},T.Builder.prototype.nested=function(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},T.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},T.Builder.prototype.slot=function(t){this.vtable[t]=this.offset()},T.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},T.Builder.growByteBuffer=function(t){var r=t.capacity();if(r&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var o=r<<1,s=T.ByteBuffer.allocate(o);return s.setPosition(o-r),s.bytes().set(t.bytes(),o-r),s},T.Builder.prototype.addOffset=function(t){this.prep(T.SIZEOF_INT,0),this.writeInt32(this.offset()-t+T.SIZEOF_INT)},T.Builder.prototype.startObject=function(t){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=t;for(var r=0;r<t;r++)this.vtable[r]=0;this.isNested=!0,this.object_start=this.offset()},T.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var t=this.offset(),r=this.vtable_in_use-1;r>=0&&this.vtable[r]==0;r--);for(var o=r+1;r>=0;r--)this.addInt16(this.vtable[r]!=0?t-this.vtable[r]:0);var s=2;this.addInt16(t-this.object_start);var p=(o+s)*T.SIZEOF_SHORT;this.addInt16(p);var l=0,c=this.space;t:for(r=0;r<this.vtables.length;r++){var n=this.bb.capacity()-this.vtables[r];if(p==this.bb.readInt16(n)){for(var a=T.SIZEOF_SHORT;a<p;a+=T.SIZEOF_SHORT)if(this.bb.readInt16(c+a)!=this.bb.readInt16(n+a))continue t;l=this.vtables[r];break}}return l?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,l-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t},T.Builder.prototype.finish=function(t,r,o){var s=o?T.SIZE_PREFIX_LENGTH:0;if(r){var p=r;if(this.prep(this.minalign,T.SIZEOF_INT+T.FILE_IDENTIFIER_LENGTH+s),p.length!=T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+T.FILE_IDENTIFIER_LENGTH);for(var l=T.FILE_IDENTIFIER_LENGTH-1;l>=0;l--)this.writeInt8(p.charCodeAt(l))}this.prep(this.minalign,T.SIZEOF_INT+s),this.addOffset(t),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},T.Builder.prototype.finishSizePrefixed=function(t,r){this.finish(t,r,!0)},T.Builder.prototype.requiredField=function(t,r){var o=this.bb.capacity()-t,s=o-this.bb.readInt32(o),p=this.bb.readInt16(s+r)!=0;if(!p)throw new Error("FlatBuffers: field "+r+" must be set")},T.Builder.prototype.startVector=function(t,r,o){this.notNested(),this.vector_num_elems=r,this.prep(T.SIZEOF_INT,t*r),this.prep(o,t*r)},T.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},T.Builder.prototype.createString=function(t){if(t instanceof Uint8Array)var r=t;else for(var r=[],o=0;o<t.length;){var s,p=t.charCodeAt(o++);if(p<55296||p>=56320)s=p;else{var l=t.charCodeAt(o++);s=(p<<10)+l+-56613888}s<128?r.push(s):(s<2048?r.push(s>>6&31|192):(s<65536?r.push(s>>12&15|224):r.push(s>>18&7|240,s>>12&63|128),r.push(s>>6&63|128)),r.push(s&63|128))}this.addInt8(0),this.startVector(1,r.length,1),this.bb.setPosition(this.space-=r.length);for(var o=0,c=this.space,n=this.bb.bytes();o<r.length;o++)n[c++]=r[o];return this.endVector()},T.Builder.prototype.createLong=function(t,r){return T.Long.create(t,r)},T.ByteBuffer=function(t){this.bytes_=t,this.position_=0},T.ByteBuffer.allocate=function(t){return new T.ByteBuffer(new Uint8Array(t))},T.ByteBuffer.prototype.clear=function(){this.position_=0},T.ByteBuffer.prototype.bytes=function(){return this.bytes_},T.ByteBuffer.prototype.position=function(){return this.position_},T.ByteBuffer.prototype.setPosition=function(t){this.position_=t},T.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},T.ByteBuffer.prototype.readInt8=function(t){return this.readUint8(t)<<24>>24},T.ByteBuffer.prototype.readUint8=function(t){return this.bytes_[t]},T.ByteBuffer.prototype.readInt16=function(t){return this.readUint16(t)<<16>>16},T.ByteBuffer.prototype.readUint16=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8},T.ByteBuffer.prototype.readInt32=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24},T.ByteBuffer.prototype.readUint32=function(t){return this.readInt32(t)>>>0},T.ByteBuffer.prototype.readInt64=function(t){return new T.Long(this.readInt32(t),this.readInt32(t+4))},T.ByteBuffer.prototype.readUint64=function(t){return new T.Long(this.readUint32(t),this.readUint32(t+4))},T.ByteBuffer.prototype.readFloat32=function(t){return T.int32[0]=this.readInt32(t),T.float32[0]},T.ByteBuffer.prototype.readFloat64=function(t){return T.int32[T.isLittleEndian?0:1]=this.readInt32(t),T.int32[T.isLittleEndian?1:0]=this.readInt32(t+4),T.float64[0]},T.ByteBuffer.prototype.writeInt8=function(t,r){this.bytes_[t]=r},T.ByteBuffer.prototype.writeUint8=function(t,r){this.bytes_[t]=r},T.ByteBuffer.prototype.writeInt16=function(t,r){this.bytes_[t]=r,this.bytes_[t+1]=r>>8},T.ByteBuffer.prototype.writeUint16=function(t,r){this.bytes_[t]=r,this.bytes_[t+1]=r>>8},T.ByteBuffer.prototype.writeInt32=function(t,r){this.bytes_[t]=r,this.bytes_[t+1]=r>>8,this.bytes_[t+2]=r>>16,this.bytes_[t+3]=r>>24},T.ByteBuffer.prototype.writeUint32=function(t,r){this.bytes_[t]=r,this.bytes_[t+1]=r>>8,this.bytes_[t+2]=r>>16,this.bytes_[t+3]=r>>24},T.ByteBuffer.prototype.writeInt64=function(t,r){this.writeInt32(t,r.low),this.writeInt32(t+4,r.high)},T.ByteBuffer.prototype.writeUint64=function(t,r){this.writeUint32(t,r.low),this.writeUint32(t+4,r.high)},T.ByteBuffer.prototype.writeFloat32=function(t,r){T.float32[0]=r,this.writeInt32(t,T.int32[0])},T.ByteBuffer.prototype.writeFloat64=function(t,r){T.float64[0]=r,this.writeInt32(t,T.int32[T.isLittleEndian?0:1]),this.writeInt32(t+4,T.int32[T.isLittleEndian?1:0])},T.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+T.SIZEOF_INT+T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var t="",r=0;r<T.FILE_IDENTIFIER_LENGTH;r++)t+=String.fromCharCode(this.readInt8(this.position_+T.SIZEOF_INT+r));return t},T.ByteBuffer.prototype.__offset=function(t,r){var o=t-this.readInt32(t);return r<this.readInt16(o)?this.readInt16(o+r):0},T.ByteBuffer.prototype.__union=function(t,r){return t.bb_pos=r+this.readInt32(r),t.bb=this,t},T.ByteBuffer.prototype.__string=function(t,r){t+=this.readInt32(t);var o=this.readInt32(t),s="",p=0;if(t+=T.SIZEOF_INT,r===T.Encoding.UTF8_BYTES)return this.bytes_.subarray(t,t+o);for(;p<o;){var l,c=this.readUint8(t+p++);if(c<192)l=c;else{var n=this.readUint8(t+p++);if(c<224)l=(c&31)<<6|n&63;else{var a=this.readUint8(t+p++);if(c<240)l=(c&15)<<12|(n&63)<<6|a&63;else{var e=this.readUint8(t+p++);l=(c&7)<<18|(n&63)<<12|(a&63)<<6|e&63}}}l<65536?s+=String.fromCharCode(l):(l-=65536,s+=String.fromCharCode((l>>10)+55296,(l&1023)+56320))}return s},T.ByteBuffer.prototype.__indirect=function(t){return t+this.readInt32(t)},T.ByteBuffer.prototype.__vector=function(t){return t+this.readInt32(t)+T.SIZEOF_INT},T.ByteBuffer.prototype.__vector_len=function(t){return this.readInt32(t+this.readInt32(t))},T.ByteBuffer.prototype.__has_identifier=function(t){if(t.length!=T.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+T.FILE_IDENTIFIER_LENGTH);for(var r=0;r<T.FILE_IDENTIFIER_LENGTH;r++)if(t.charCodeAt(r)!=this.readInt8(this.position_+T.SIZEOF_INT+r))return!1;return!0},T.ByteBuffer.prototype.createLong=function(t,r){return T.Long.create(t,r)}}),H,Yr=I(()=>{"use strict";Ko(),(t=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.UNDEFINED=0]="UNDEFINED",c[c.FLOAT=1]="FLOAT",c[c.INT=2]="INT",c[c.STRING=3]="STRING",c[c.TENSOR=4]="TENSOR",c[c.GRAPH=5]="GRAPH",c[c.FLOATS=6]="FLOATS",c[c.INTS=7]="INTS",c[c.STRINGS=8]="STRINGS",c[c.TENSORS=9]="TENSORS",c[c.GRAPHS=10]="GRAPHS",c[c.SPARSE_TENSOR=11]="SPARSE_TENSOR",c[c.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(l=p.AttributeType||={})})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.UNKNOWN=0]="UNKNOWN",c[c.VALUE=1]="VALUE",c[c.PARAM=2]="PARAM"))(l=p.DimensionValueType||={})})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.UNDEFINED=0]="UNDEFINED",c[c.FLOAT=1]="FLOAT",c[c.UINT8=2]="UINT8",c[c.INT8=3]="INT8",c[c.UINT16=4]="UINT16",c[c.INT16=5]="INT16",c[c.INT32=6]="INT32",c[c.INT64=7]="INT64",c[c.STRING=8]="STRING",c[c.BOOL=9]="BOOL",c[c.FLOAT16=10]="FLOAT16",c[c.DOUBLE=11]="DOUBLE",c[c.UINT32=12]="UINT32",c[c.UINT64=13]="UINT64",c[c.COMPLEX64=14]="COMPLEX64",c[c.COMPLEX128=15]="COMPLEX128",c[c.BFLOAT16=16]="BFLOAT16",c[c.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",c[c.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",c[c.FLOAT8E5M2=19]="FLOAT8E5M2",c[c.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(l=p.TensorDataType||={})})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.Primitive=0]="Primitive",c[c.Fused=1]="Fused"))(l=p.NodeType||={})})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{let l;(c=>(c[c.NONE=0]="NONE",c[c.tensor_type=1]="tensor_type",c[c.sequence_type=2]="sequence_type",c[c.map_type=3]="map_type"))(l=p.TypeInfoValue||={})})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsShape(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}dim(n,a){let e=this.bb.__offset(this.bb_pos,4);return e?(a||new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,a){n.addFieldOffset(0,a,0)}static createDimVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startDimVector(n,a){n.startVector(4,a,4)}static endShape(n){return n.endObject()}static createShape(n,a){return l.startShape(n),l.addDim(n,a),l.endShape(n)}}p.Shape=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsDimension(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}value(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}denotation(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}static startDimension(n){n.startObject(2)}static addValue(n,a){n.addFieldOffset(0,a,0)}static addDenotation(n,a){n.addFieldOffset(1,a,0)}static endDimension(n){return n.endObject()}static createDimension(n,a,e){return l.startDimension(n),l.addValue(n,a),l.addDenotation(n,e),l.endDimension(n)}}p.Dimension=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsDimensionValue(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):0}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,a){n.addFieldInt8(0,a,0)}static addDimValue(n,a){n.addFieldInt64(1,a,n.createLong(0,0))}static addDimParam(n,a){n.addFieldOffset(2,a,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,a,e,u){return l.startDimensionValue(n),l.addDimType(n,a),l.addDimValue(n,e),l.addDimParam(n,u),l.endDimensionValue(n)}}p.DimensionValue=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTensorTypeAndShape(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}shape(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,a){n.addFieldInt32(0,a,0)}static addShape(n,a){n.addFieldOffset(1,a,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,a,e){return l.startTensorTypeAndShape(n),l.addElemType(n,a),l.addShape(n,e),l.endTensorTypeAndShape(n)}}p.TensorTypeAndShape=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsMapType(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}valueType(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,a){n.addFieldInt32(0,a,0)}static addValueType(n,a){n.addFieldOffset(1,a,0)}static endMapType(n){return n.endObject()}static createMapType(n,a,e){return l.startMapType(n),l.addKeyType(n,a),l.addValueType(n,e),l.endMapType(n)}}p.MapType=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSequenceType(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,a){n.addFieldOffset(0,a,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,a){return l.startSequenceType(n),l.addElemType(n,a),l.endSequenceType(n)}}p.SequenceType=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(n,a,e,u){return n.prep(4,12),n.writeInt32(u),n.writeInt32(e),n.writeInt32(a),n.offset()}}p.EdgeEnd=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsNodeEdge(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,a){let e=this.bb.__offset(this.bb_pos,6);return e?(a||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+e)+n*12,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,a){let e=this.bb.__offset(this.bb_pos,8);return e?(a||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+e)+n*12,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,a){n.addFieldInt32(0,a,0)}static addInputEdges(n,a){n.addFieldOffset(1,a,0)}static startInputEdgesVector(n,a){n.startVector(12,a,4)}static addOutputEdges(n,a){n.addFieldOffset(2,a,0)}static startOutputEdgesVector(n,a){n.startVector(12,a,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,a,e,u){return l.startNodeEdge(n),l.addNodeIndex(n,a),l.addInputEdges(n,e),l.addOutputEdges(n,u),l.endNodeEdge(n)}}p.NodeEdge=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsNode(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}domain(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__string(this.bb_pos+a,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):0}executionProviderType(n){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__string(this.bb_pos+a,n):null}inputs(n,a){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+n*4,a):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,a){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+n*4,a):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,a){let e=this.bb.__offset(this.bb_pos,24);return e?(a||new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.readInt32(this.bb.__vector(this.bb_pos+a)+n*4):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,a){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+n*4,a):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addDomain(n,a){n.addFieldOffset(2,a,0)}static addSinceVersion(n,a){n.addFieldInt32(3,a,0)}static addIndex(n,a){n.addFieldInt32(4,a,0)}static addOpType(n,a){n.addFieldOffset(5,a,0)}static addType(n,a){n.addFieldInt32(6,a,0)}static addExecutionProviderType(n,a){n.addFieldOffset(7,a,0)}static addInputs(n,a){n.addFieldOffset(8,a,0)}static createInputsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startInputsVector(n,a){n.startVector(4,a,4)}static addOutputs(n,a){n.addFieldOffset(9,a,0)}static createOutputsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startOutputsVector(n,a){n.startVector(4,a,4)}static addAttributes(n,a){n.addFieldOffset(10,a,0)}static createAttributesVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startAttributesVector(n,a){n.startVector(4,a,4)}static addInputArgCounts(n,a){n.addFieldOffset(11,a,0)}static createInputArgCountsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addInt32(a[e]);return n.endVector()}static startInputArgCountsVector(n,a){n.startVector(4,a,4)}static addImplicitInputs(n,a){n.addFieldOffset(12,a,0)}static createImplicitInputsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startImplicitInputsVector(n,a){n.startVector(4,a,4)}static endNode(n){return n.endObject()}static createNode(n,a,e,u,i,d,h,m,b,x,E,w,S,$){return l.startNode(n),l.addName(n,a),l.addDocString(n,e),l.addDomain(n,u),l.addSinceVersion(n,i),l.addIndex(n,d),l.addOpType(n,h),l.addType(n,m),l.addExecutionProviderType(n,b),l.addInputs(n,x),l.addOutputs(n,E),l.addAttributes(n,w),l.addInputArgCounts(n,S),l.addImplicitInputs(n,$),l.endNode(n)}}p.Node=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsValueInfo(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}type(n){let a=this.bb.__offset(this.bb_pos,8);return a?(n||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addType(n,a){n.addFieldOffset(2,a,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,a,e,u){return l.startValueInfo(n),l.addName(n,a),l.addDocString(n,e),l.addType(n,u),l.endValueInfo(n)}}p.ValueInfo=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTypeInfo(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):0}value(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__union(n,this.bb_pos+a):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,a){n.addFieldOffset(0,a,0)}static addValueType(n,a){n.addFieldInt8(1,a,0)}static addValue(n,a){n.addFieldOffset(2,a,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,a,e,u){return l.startTypeInfo(n),l.addDenotation(n,a),l.addValueType(n,e),l.addValue(n,u),l.endTypeInfo(n)}}p.TypeInfo=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsOperatorSetId(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,a){n.addFieldOffset(0,a,0)}static addVersion(n,a){n.addFieldInt64(1,a,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,a,e){return l.startOperatorSetId(n),l.addDomain(n,a),l.addVersion(n,e),l.endOperatorSetId(n)}}p.OperatorSetId=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTensor(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}dims(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}rawData(n){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint8(this.bb.__vector(this.bb_pos+a)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,a){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+n*4,a):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addDims(n,a){n.addFieldOffset(2,a,0)}static createDimsVector(n,a){n.startVector(8,a.length,8);for(let e=a.length-1;e>=0;e--)n.addInt64(a[e]);return n.endVector()}static startDimsVector(n,a){n.startVector(8,a,8)}static addDataType(n,a){n.addFieldInt32(3,a,0)}static addRawData(n,a){n.addFieldOffset(4,a,0)}static createRawDataVector(n,a){n.startVector(1,a.length,1);for(let e=a.length-1;e>=0;e--)n.addInt8(a[e]);return n.endVector()}static startRawDataVector(n,a){n.startVector(1,a,1)}static addStringData(n,a){n.addFieldOffset(5,a,0)}static createStringDataVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startStringDataVector(n,a){n.startVector(4,a,4)}static endTensor(n){return n.endObject()}static createTensor(n,a,e,u,i,d,h){return l.startTensor(n),l.addName(n,a),l.addDocString(n,e),l.addDims(n,u),l.addDataType(n,i),l.addRawData(n,d),l.addStringData(n,h),l.endTensor(n)}}p.Tensor=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSparseTensor(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}values(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}indices(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}dims(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,a){n.addFieldOffset(0,a,0)}static addIndices(n,a){n.addFieldOffset(1,a,0)}static addDims(n,a){n.addFieldOffset(2,a,0)}static createDimsVector(n,a){n.startVector(8,a.length,8);for(let e=a.length-1;e>=0;e--)n.addInt64(a[e]);return n.endVector()}static startDimsVector(n,a){n.startVector(8,a,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,a,e,u){return l.startSparseTensor(n),l.addValues(n,a),l.addIndices(n,e),l.addDims(n,u),l.endSparseTensor(n)}}p.SparseTensor=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsAttribute(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):0}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__string(this.bb_pos+a,n):null}t(n){let a=this.bb.__offset(this.bb_pos,16);return a?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}g(n){let a=this.bb.__offset(this.bb_pos,18);return a?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}floats(n){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.readFloat32(this.bb.__vector(this.bb_pos+a)+n*4):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,a){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+n*4,a):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,a){let e=this.bb.__offset(this.bb_pos,26);return e?(a||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,a){let e=this.bb.__offset(this.bb_pos,28);return e?(a||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addType(n,a){n.addFieldInt32(2,a,0)}static addF(n,a){n.addFieldFloat32(3,a,0)}static addI(n,a){n.addFieldInt64(4,a,n.createLong(0,0))}static addS(n,a){n.addFieldOffset(5,a,0)}static addT(n,a){n.addFieldOffset(6,a,0)}static addG(n,a){n.addFieldOffset(7,a,0)}static addFloats(n,a){n.addFieldOffset(8,a,0)}static createFloatsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addFloat32(a[e]);return n.endVector()}static startFloatsVector(n,a){n.startVector(4,a,4)}static addInts(n,a){n.addFieldOffset(9,a,0)}static createIntsVector(n,a){n.startVector(8,a.length,8);for(let e=a.length-1;e>=0;e--)n.addInt64(a[e]);return n.endVector()}static startIntsVector(n,a){n.startVector(8,a,8)}static addStrings(n,a){n.addFieldOffset(10,a,0)}static createStringsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startStringsVector(n,a){n.startVector(4,a,4)}static addTensors(n,a){n.addFieldOffset(11,a,0)}static createTensorsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startTensorsVector(n,a){n.startVector(4,a,4)}static addGraphs(n,a){n.addFieldOffset(12,a,0)}static createGraphsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startGraphsVector(n,a){n.startVector(4,a,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,a,e,u,i,d,h,m,b,x,E,w,S,$){return l.startAttribute(n),l.addName(n,a),l.addDocString(n,e),l.addType(n,u),l.addF(n,i),l.addI(n,d),l.addS(n,h),l.addT(n,m),l.addG(n,b),l.addFloats(n,x),l.addInts(n,E),l.addStrings(n,w),l.addTensors(n,S),l.addGraphs(n,$),l.endAttribute(n)}}p.Attribute=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsGraph(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,a){let e=this.bb.__offset(this.bb_pos,4);return e?(a||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,a){let e=this.bb.__offset(this.bb_pos,6);return e?(a||new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,a){let e=this.bb.__offset(this.bb_pos,8);return e?(a||new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,a){let e=this.bb.__offset(this.bb_pos,12);return e?(a||new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,a){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+n*4,a):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,a){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+n*4,a):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,a){let e=this.bb.__offset(this.bb_pos,18);return e?(a||new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,a){n.addFieldOffset(0,a,0)}static createInitializersVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startInitializersVector(n,a){n.startVector(4,a,4)}static addNodeArgs(n,a){n.addFieldOffset(1,a,0)}static createNodeArgsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startNodeArgsVector(n,a){n.startVector(4,a,4)}static addNodes(n,a){n.addFieldOffset(2,a,0)}static createNodesVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startNodesVector(n,a){n.startVector(4,a,4)}static addMaxNodeIndex(n,a){n.addFieldInt32(3,a,0)}static addNodeEdges(n,a){n.addFieldOffset(4,a,0)}static createNodeEdgesVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startNodeEdgesVector(n,a){n.startVector(4,a,4)}static addInputs(n,a){n.addFieldOffset(5,a,0)}static createInputsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startInputsVector(n,a){n.startVector(4,a,4)}static addOutputs(n,a){n.addFieldOffset(6,a,0)}static createOutputsVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startOutputsVector(n,a){n.startVector(4,a,4)}static addSparseInitializers(n,a){n.addFieldOffset(7,a,0)}static createSparseInitializersVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startSparseInitializersVector(n,a){n.startVector(4,a,4)}static endGraph(n){return n.endObject()}static createGraph(n,a,e,u,i,d,h,m,b){return l.startGraph(n),l.addInitializers(n,a),l.addNodeArgs(n,e),l.addNodes(n,u),l.addMaxNodeIndex(n,i),l.addNodeEdges(n,d),l.addInputs(n,h),l.addOutputs(n,m),l.addSparseInitializers(n,b),l.endGraph(n)}}p.Graph=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsModel(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,a){let e=this.bb.__offset(this.bb_pos,6);return e?(a||new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}producerVersion(n){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.__string(this.bb_pos+a,n):null}domain(n){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__string(this.bb_pos+a,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__string(this.bb_pos+a,n):null}graph(n){let a=this.bb.__offset(this.bb_pos,18);return a?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}graphDocString(n){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__string(this.bb_pos+a,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,a){n.addFieldInt64(0,a,n.createLong(0,0))}static addOpsetImport(n,a){n.addFieldOffset(1,a,0)}static createOpsetImportVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startOpsetImportVector(n,a){n.startVector(4,a,4)}static addProducerName(n,a){n.addFieldOffset(2,a,0)}static addProducerVersion(n,a){n.addFieldOffset(3,a,0)}static addDomain(n,a){n.addFieldOffset(4,a,0)}static addModelVersion(n,a){n.addFieldInt64(5,a,n.createLong(0,0))}static addDocString(n,a){n.addFieldOffset(6,a,0)}static addGraph(n,a){n.addFieldOffset(7,a,0)}static addGraphDocString(n,a){n.addFieldOffset(8,a,0)}static endModel(n){return n.endObject()}static createModel(n,a,e,u,i,d,h,m,b,x){return l.startModel(n),l.addIrVersion(n,a),l.addOpsetImport(n,e),l.addProducerName(n,u),l.addProducerVersion(n,i),l.addDomain(n,d),l.addModelVersion(n,h),l.addDocString(n,m),l.addGraph(n,b),l.addGraphDocString(n,x),l.endModel(n)}}p.Model=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsKernelCreateInfos(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb.__vector(this.bb_pos+a)+n*4):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,a){n.addFieldOffset(0,a,0)}static createNodeIndicesVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addInt32(a[e]);return n.endVector()}static startNodeIndicesVector(n,a){n.startVector(4,a,4)}static addKernelDefHashes(n,a){n.addFieldOffset(1,a,0)}static createKernelDefHashesVector(n,a){n.startVector(8,a.length,8);for(let e=a.length-1;e>=0;e--)n.addInt64(a[e]);return n.endVector()}static startKernelDefHashesVector(n,a){n.startVector(8,a,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,a,e){return l.startKernelCreateInfos(n),l.addNodeIndices(n,a),l.addKernelDefHashes(n,e),l.endKernelCreateInfos(n)}}p.KernelCreateInfos=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSubGraphSessionState(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}sessionState(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,a){n.addFieldOffset(0,a,0)}static addSessionState(n,a){n.addFieldOffset(1,a,0)}static endSubGraphSessionState(n){let a=n.endObject();return n.requiredField(a,4),a}static createSubGraphSessionState(n,a,e){return l.startSubGraphSessionState(n),l.addGraphId(n,a),l.addSessionState(n,e),l.endSubGraphSessionState(n)}}p.SubGraphSessionState=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSessionState(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}subGraphSessionStates(n,a){let e=this.bb.__offset(this.bb_pos,6);return e?(a||new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+n*4),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,a){n.addFieldOffset(0,a,0)}static addSubGraphSessionStates(n,a){n.addFieldOffset(1,a,0)}static createSubGraphSessionStatesVector(n,a){n.startVector(4,a.length,4);for(let e=a.length-1;e>=0;e--)n.addOffset(a[e]);return n.endVector()}static startSubGraphSessionStatesVector(n,a){n.startVector(4,a,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,a,e){return l.startSessionState(n),l.addKernels(n,a),l.addSubGraphSessionStates(n,e),l.endSessionState(n)}}p.SessionState=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={}),(t=>{let r;(o=>{let s;(p=>{class l{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsInferenceSession(n,a){return(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,a){return n.setPosition(n.position()+T.SIZE_PREFIX_LENGTH),(a||new l).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}model(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}sessionState(n){let a=this.bb.__offset(this.bb_pos,8);return a?(n||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,a){n.addFieldOffset(0,a,0)}static addModel(n,a){n.addFieldOffset(1,a,0)}static addSessionState(n,a){n.addFieldOffset(2,a,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,a){n.finish(a,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,a){n.finish(a,"ORTM",!0)}static createInferenceSession(n,a,e,u){return l.startInferenceSession(n),l.addOrtVersion(n,a),l.addModel(n,e),l.addSessionState(n,u),l.endInferenceSession(n)}}p.InferenceSession=l})(s=o.fbs||={})})(r=t.experimental||={})})(H||={})}),jh=nt((t,r)=>{"use strict";r.exports=o;function o(s,p){for(var l=new Array(arguments.length-1),c=0,n=2,a=!0;n<arguments.length;)l[c++]=arguments[n++];return new Promise(function(e,u){l[c]=function(i){if(a)if(a=!1,i)u(i);else{for(var d=new Array(arguments.length-1),h=0;h<d.length;)d[h++]=arguments[h];e.apply(null,d)}};try{s.apply(p||null,l)}catch(i){a&&(a=!1,u(i))}})}}),Vh=nt(t=>{"use strict";var r=t;r.length=function(c){var n=c.length;if(!n)return 0;for(var a=0;--n%4>1&&c.charAt(n)==="=";)++a;return Math.ceil(c.length*3)/4-a};var o=new Array(64),s=new Array(123);for(p=0;p<64;)s[o[p]=p<26?p+65:p<52?p+71:p<62?p-4:p-59|43]=p++;var p;r.encode=function(c,n,a){for(var e=null,u=[],i=0,d=0,h;n<a;){var m=c[n++];switch(d){case 0:u[i++]=o[m>>2],h=(m&3)<<4,d=1;break;case 1:u[i++]=o[h|m>>4],h=(m&15)<<2,d=2;break;case 2:u[i++]=o[h|m>>6],u[i++]=o[m&63],d=0;break}i>8191&&((e||(e=[])).push(String.fromCharCode.apply(String,u)),i=0)}return d&&(u[i++]=o[h],u[i++]=61,d===1&&(u[i++]=61)),e?(i&&e.push(String.fromCharCode.apply(String,u.slice(0,i))),e.join("")):String.fromCharCode.apply(String,u.slice(0,i))};var l="invalid encoding";r.decode=function(c,n,a){for(var e=a,u=0,i,d=0;d<c.length;){var h=c.charCodeAt(d++);if(h===61&&u>1)break;if((h=s[h])===void 0)throw Error(l);switch(u){case 0:i=h,u=1;break;case 1:n[a++]=i<<2|(h&48)>>4,i=h,u=2;break;case 2:n[a++]=(i&15)<<4|(h&60)>>2,i=h,u=3;break;case 3:n[a++]=(i&3)<<6|h,u=0;break}}if(u===1)throw Error(l);return a-e},r.test=function(c){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(c)}}),Mh=nt((t,r)=>{"use strict";r.exports=o;function o(){this._listeners={}}o.prototype.on=function(s,p,l){return(this._listeners[s]||(this._listeners[s]=[])).push({fn:p,ctx:l||this}),this},o.prototype.off=function(s,p){if(s===void 0)this._listeners={};else if(p===void 0)this._listeners[s]=[];else for(var l=this._listeners[s],c=0;c<l.length;)l[c].fn===p?l.splice(c,1):++c;return this},o.prototype.emit=function(s){var p=this._listeners[s];if(p){for(var l=[],c=1;c<arguments.length;)l.push(arguments[c++]);for(c=0;c<p.length;)p[c].fn.apply(p[c++].ctx,l)}return this}}),zh=nt((t,r)=>{"use strict";r.exports=o(o);function o(n){return typeof Float32Array<"u"?function(){var a=new Float32Array([-0]),e=new Uint8Array(a.buffer),u=e[3]===128;function i(b,x,E){a[0]=b,x[E]=e[0],x[E+1]=e[1],x[E+2]=e[2],x[E+3]=e[3]}function d(b,x,E){a[0]=b,x[E]=e[3],x[E+1]=e[2],x[E+2]=e[1],x[E+3]=e[0]}n.writeFloatLE=u?i:d,n.writeFloatBE=u?d:i;function h(b,x){return e[0]=b[x],e[1]=b[x+1],e[2]=b[x+2],e[3]=b[x+3],a[0]}function m(b,x){return e[3]=b[x],e[2]=b[x+1],e[1]=b[x+2],e[0]=b[x+3],a[0]}n.readFloatLE=u?h:m,n.readFloatBE=u?m:h}():function(){function a(u,i,d,h){var m=i<0?1:0;if(m&&(i=-i),i===0)u(1/i>0?0:2147483648,d,h);else if(isNaN(i))u(2143289344,d,h);else if(i>34028234663852886e22)u((m<<31|2139095040)>>>0,d,h);else if(i<11754943508222875e-54)u((m<<31|Math.round(i/1401298464324817e-60))>>>0,d,h);else{var b=Math.floor(Math.log(i)/Math.LN2),x=Math.round(i*Math.pow(2,-b)*8388608)&8388607;u((m<<31|b+127<<23|x)>>>0,d,h)}}n.writeFloatLE=a.bind(null,s),n.writeFloatBE=a.bind(null,p);function e(u,i,d){var h=u(i,d),m=(h>>31)*2+1,b=h>>>23&255,x=h&8388607;return b===255?x?NaN:m*(1/0):b===0?m*1401298464324817e-60*x:m*Math.pow(2,b-150)*(x+8388608)}n.readFloatLE=e.bind(null,l),n.readFloatBE=e.bind(null,c)}(),typeof Float64Array<"u"?function(){var a=new Float64Array([-0]),e=new Uint8Array(a.buffer),u=e[7]===128;function i(b,x,E){a[0]=b,x[E]=e[0],x[E+1]=e[1],x[E+2]=e[2],x[E+3]=e[3],x[E+4]=e[4],x[E+5]=e[5],x[E+6]=e[6],x[E+7]=e[7]}function d(b,x,E){a[0]=b,x[E]=e[7],x[E+1]=e[6],x[E+2]=e[5],x[E+3]=e[4],x[E+4]=e[3],x[E+5]=e[2],x[E+6]=e[1],x[E+7]=e[0]}n.writeDoubleLE=u?i:d,n.writeDoubleBE=u?d:i;function h(b,x){return e[0]=b[x],e[1]=b[x+1],e[2]=b[x+2],e[3]=b[x+3],e[4]=b[x+4],e[5]=b[x+5],e[6]=b[x+6],e[7]=b[x+7],a[0]}function m(b,x){return e[7]=b[x],e[6]=b[x+1],e[5]=b[x+2],e[4]=b[x+3],e[3]=b[x+4],e[2]=b[x+5],e[1]=b[x+6],e[0]=b[x+7],a[0]}n.readDoubleLE=u?h:m,n.readDoubleBE=u?m:h}():function(){function a(u,i,d,h,m,b){var x=h<0?1:0;if(x&&(h=-h),h===0)u(0,m,b+i),u(1/h>0?0:2147483648,m,b+d);else if(isNaN(h))u(0,m,b+i),u(2146959360,m,b+d);else if(h>17976931348623157e292)u(0,m,b+i),u((x<<31|2146435072)>>>0,m,b+d);else{var E;if(h<22250738585072014e-324)E=h/5e-324,u(E>>>0,m,b+i),u((x<<31|E/4294967296)>>>0,m,b+d);else{var w=Math.floor(Math.log(h)/Math.LN2);w===1024&&(w=1023),E=h*Math.pow(2,-w),u(E*4503599627370496>>>0,m,b+i),u((x<<31|w+1023<<20|E*1048576&1048575)>>>0,m,b+d)}}}n.writeDoubleLE=a.bind(null,s,0,4),n.writeDoubleBE=a.bind(null,p,4,0);function e(u,i,d,h,m){var b=u(h,m+i),x=u(h,m+d),E=(x>>31)*2+1,w=x>>>20&2047,S=4294967296*(x&1048575)+b;return w===2047?S?NaN:E*(1/0):w===0?E*5e-324*S:E*Math.pow(2,w-1075)*(S+4503599627370496)}n.readDoubleLE=e.bind(null,l,0,4),n.readDoubleBE=e.bind(null,c,4,0)}(),n}function s(n,a,e){a[e]=n&255,a[e+1]=n>>>8&255,a[e+2]=n>>>16&255,a[e+3]=n>>>24}function p(n,a,e){a[e]=n>>>24,a[e+1]=n>>>16&255,a[e+2]=n>>>8&255,a[e+3]=n&255}function l(n,a){return(n[a]|n[a+1]<<8|n[a+2]<<16|n[a+3]<<24)>>>0}function c(n,a){return(n[a]<<24|n[a+1]<<16|n[a+2]<<8|n[a+3])>>>0}}),Uh=nt((exports,module)=>{"use strict";module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}}),Gh=nt(t=>{"use strict";var r=t;r.length=function(o){for(var s=0,p=0,l=0;l<o.length;++l)p=o.charCodeAt(l),p<128?s+=1:p<2048?s+=2:(p&64512)===55296&&(o.charCodeAt(l+1)&64512)===56320?(++l,s+=4):s+=3;return s},r.read=function(o,s,p){var l=p-s;if(l<1)return"";for(var c=null,n=[],a=0,e;s<p;)e=o[s++],e<128?n[a++]=e:e>191&&e<224?n[a++]=(e&31)<<6|o[s++]&63:e>239&&e<365?(e=((e&7)<<18|(o[s++]&63)<<12|(o[s++]&63)<<6|o[s++]&63)-65536,n[a++]=55296+(e>>10),n[a++]=56320+(e&1023)):n[a++]=(e&15)<<12|(o[s++]&63)<<6|o[s++]&63,a>8191&&((c||(c=[])).push(String.fromCharCode.apply(String,n)),a=0);return c?(a&&c.push(String.fromCharCode.apply(String,n.slice(0,a))),c.join("")):String.fromCharCode.apply(String,n.slice(0,a))},r.write=function(o,s,p){for(var l=p,c,n,a=0;a<o.length;++a)c=o.charCodeAt(a),c<128?s[p++]=c:c<2048?(s[p++]=c>>6|192,s[p++]=c&63|128):(c&64512)===55296&&((n=o.charCodeAt(a+1))&64512)===56320?(c=65536+((c&1023)<<10)+(n&1023),++a,s[p++]=c>>18|240,s[p++]=c>>12&63|128,s[p++]=c>>6&63|128,s[p++]=c&63|128):(s[p++]=c>>12|224,s[p++]=c>>6&63|128,s[p++]=c&63|128);return p-l}}),Hh=nt((t,r)=>{"use strict";r.exports=o;function o(s,p,l){var c=l||8192,n=c>>>1,a=null,e=c;return function(u){if(u<1||u>n)return s(u);e+u>c&&(a=s(c),e=0);var i=p.call(a,e,e+=u);return e&7&&(e=(e|7)+1),i}}}),qh=nt((t,r)=>{"use strict";r.exports=s;var o=we();function s(n,a){this.lo=n>>>0,this.hi=a>>>0}var p=s.zero=new s(0,0);p.toNumber=function(){return 0},p.zzEncode=p.zzDecode=function(){return this},p.length=function(){return 1};var l=s.zeroHash="\0\0\0\0\0\0\0\0";s.fromNumber=function(n){if(n===0)return p;var a=n<0;a&&(n=-n);var e=n>>>0,u=(n-e)/4294967296>>>0;return a&&(u=~u>>>0,e=~e>>>0,++e>4294967295&&(e=0,++u>4294967295&&(u=0))),new s(e,u)},s.from=function(n){if(typeof n=="number")return s.fromNumber(n);if(o.isString(n))if(o.Long)n=o.Long.fromString(n);else return s.fromNumber(parseInt(n,10));return n.low||n.high?new s(n.low>>>0,n.high>>>0):p},s.prototype.toNumber=function(n){if(!n&&this.hi>>>31){var a=~this.lo+1>>>0,e=~this.hi>>>0;return a||(e=e+1>>>0),-(a+e*4294967296)}return this.lo+this.hi*4294967296},s.prototype.toLong=function(n){return o.Long?new o.Long(this.lo|0,this.hi|0,!!n):{low:this.lo|0,high:this.hi|0,unsigned:!!n}};var c=String.prototype.charCodeAt;s.fromHash=function(n){return n===l?p:new s((c.call(n,0)|c.call(n,1)<<8|c.call(n,2)<<16|c.call(n,3)<<24)>>>0,(c.call(n,4)|c.call(n,5)<<8|c.call(n,6)<<16|c.call(n,7)<<24)>>>0)},s.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},s.prototype.zzEncode=function(){var n=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^n)>>>0,this.lo=(this.lo<<1^n)>>>0,this},s.prototype.zzDecode=function(){var n=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^n)>>>0,this.hi=(this.hi>>>1^n)>>>0,this},s.prototype.length=function(){var n=this.lo,a=(this.lo>>>28|this.hi<<4)>>>0,e=this.hi>>>24;return e===0?a===0?n<16384?n<128?1:2:n<2097152?3:4:a<16384?a<128?5:6:a<2097152?7:8:e<128?9:10}}),we=nt(t=>{"use strict";var r=t;r.asPromise=jh(),r.base64=Vh(),r.EventEmitter=Mh(),r.float=zh(),r.inquire=Uh(),r.utf8=Gh(),r.pool=Hh(),r.LongBits=qh(),r.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),r.global=r.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||t,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(p){return typeof p=="number"&&isFinite(p)&&Math.floor(p)===p},r.isString=function(p){return typeof p=="string"||p instanceof String},r.isObject=function(p){return p&&typeof p=="object"},r.isset=r.isSet=function(p,l){var c=p[l];return c!=null&&p.hasOwnProperty(l)?typeof c!="object"||(Array.isArray(c)?c.length:Object.keys(c).length)>0:!1},r.Buffer=function(){try{var p=r.inquire("buffer").Buffer;return p.prototype.utf8Write?p:null}catch{return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(p){return typeof p=="number"?r.Buffer?r._Buffer_allocUnsafe(p):new r.Array(p):r.Buffer?r._Buffer_from(p):typeof Uint8Array>"u"?p:new Uint8Array(p)},r.Array=typeof Uint8Array<"u"?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(p){return p?r.LongBits.from(p).toHash():r.LongBits.zeroHash},r.longFromHash=function(p,l){var c=r.LongBits.fromHash(p);return r.Long?r.Long.fromBits(c.lo,c.hi,l):c.toNumber(!!l)};function o(p,l,c){for(var n=Object.keys(l),a=0;a<n.length;++a)(p[n[a]]===void 0||!c)&&(p[n[a]]=l[n[a]]);return p}r.merge=o,r.lcFirst=function(p){return p.charAt(0).toLowerCase()+p.substring(1)};function s(p){function l(c,n){if(!(this instanceof l))return new l(c,n);Object.defineProperty(this,"message",{get:function(){return c}}),Error.captureStackTrace?Error.captureStackTrace(this,l):Object.defineProperty(this,"stack",{value:new Error().stack||""}),n&&o(this,n)}return l.prototype=Object.create(Error.prototype,{constructor:{value:l,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return p},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),l}r.newError=s,r.ProtocolError=s("ProtocolError"),r.oneOfGetter=function(p){for(var l={},c=0;c<p.length;++c)l[p[c]]=1;return function(){for(var n=Object.keys(this),a=n.length-1;a>-1;--a)if(l[n[a]]===1&&this[n[a]]!==void 0&&this[n[a]]!==null)return n[a]}},r.oneOfSetter=function(p){return function(l){for(var c=0;c<p.length;++c)p[c]!==l&&delete this[p[c]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var p=r.Buffer;if(!p){r._Buffer_from=r._Buffer_allocUnsafe=null;return}r._Buffer_from=p.from!==Uint8Array.from&&p.from||function(l,c){return new p(l,c)},r._Buffer_allocUnsafe=p.allocUnsafe||function(l){return new p(l)}}}),wl=nt((t,r)=>{"use strict";r.exports=u;var o=we(),s,p=o.LongBits,l=o.base64,c=o.utf8;function n(w,S,$){this.fn=w,this.len=S,this.next=void 0,this.val=$}function a(){}function e(w){this.head=w.head,this.tail=w.tail,this.len=w.len,this.next=w.states}function u(){this.len=0,this.head=new n(a,0,0),this.tail=this.head,this.states=null}var i=function(){return o.Buffer?function(){return(u.create=function(){return new s})()}:function(){return new u}};u.create=i(),u.alloc=function(w){return new o.Array(w)},o.Array!==Array&&(u.alloc=o.pool(u.alloc,o.Array.prototype.subarray)),u.prototype._push=function(w,S,$){return this.tail=this.tail.next=new n(w,S,$),this.len+=S,this};function d(w,S,$){S[$]=w&255}function h(w,S,$){for(;w>127;)S[$++]=w&127|128,w>>>=7;S[$]=w}function m(w,S){this.len=w,this.next=void 0,this.val=S}m.prototype=Object.create(n.prototype),m.prototype.fn=h,u.prototype.uint32=function(w){return this.len+=(this.tail=this.tail.next=new m((w=w>>>0)<128?1:w<16384?2:w<2097152?3:w<268435456?4:5,w)).len,this},u.prototype.int32=function(w){return w<0?this._push(b,10,p.fromNumber(w)):this.uint32(w)},u.prototype.sint32=function(w){return this.uint32((w<<1^w>>31)>>>0)};function b(w,S,$){for(;w.hi;)S[$++]=w.lo&127|128,w.lo=(w.lo>>>7|w.hi<<25)>>>0,w.hi>>>=7;for(;w.lo>127;)S[$++]=w.lo&127|128,w.lo=w.lo>>>7;S[$++]=w.lo}u.prototype.uint64=function(w){var S=p.from(w);return this._push(b,S.length(),S)},u.prototype.int64=u.prototype.uint64,u.prototype.sint64=function(w){var S=p.from(w).zzEncode();return this._push(b,S.length(),S)},u.prototype.bool=function(w){return this._push(d,1,w?1:0)};function x(w,S,$){S[$]=w&255,S[$+1]=w>>>8&255,S[$+2]=w>>>16&255,S[$+3]=w>>>24}u.prototype.fixed32=function(w){return this._push(x,4,w>>>0)},u.prototype.sfixed32=u.prototype.fixed32,u.prototype.fixed64=function(w){var S=p.from(w);return this._push(x,4,S.lo)._push(x,4,S.hi)},u.prototype.sfixed64=u.prototype.fixed64,u.prototype.float=function(w){return this._push(o.float.writeFloatLE,4,w)},u.prototype.double=function(w){return this._push(o.float.writeDoubleLE,8,w)};var E=o.Array.prototype.set?function(w,S,$){S.set(w,$)}:function(w,S,$){for(var F=0;F<w.length;++F)S[$+F]=w[F]};u.prototype.bytes=function(w){var S=w.length>>>0;if(!S)return this._push(d,1,0);if(o.isString(w)){var $=u.alloc(S=l.length(w));l.decode(w,$,0),w=$}return this.uint32(S)._push(E,S,w)},u.prototype.string=function(w){var S=c.length(w);return S?this.uint32(S)._push(c.write,S,w):this._push(d,1,0)},u.prototype.fork=function(){return this.states=new e(this),this.head=this.tail=new n(a,0,0),this.len=0,this},u.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new n(a,0,0),this.len=0),this},u.prototype.ldelim=function(){var w=this.head,S=this.tail,$=this.len;return this.reset().uint32($),$&&(this.tail.next=w.next,this.tail=S,this.len+=$),this},u.prototype.finish=function(){for(var w=this.head.next,S=this.constructor.alloc(this.len),$=0;w;)w.fn(w.val,S,$),$+=w.len,w=w.next;return S},u._configure=function(w){s=w,u.create=i(),s._configure()}}),Wh=nt((t,r)=>{"use strict";r.exports=p;var o=wl();(p.prototype=Object.create(o.prototype)).constructor=p;var s=we();function p(){o.call(this)}p._configure=function(){p.alloc=s._Buffer_allocUnsafe,p.writeBytesBuffer=s.Buffer&&s.Buffer.prototype instanceof Uint8Array&&s.Buffer.prototype.set.name==="set"?function(c,n,a){n.set(c,a)}:function(c,n,a){if(c.copy)c.copy(n,a,0,c.length);else for(var e=0;e<c.length;)n[a++]=c[e++]}},p.prototype.bytes=function(c){s.isString(c)&&(c=s._Buffer_from(c,"base64"));var n=c.length>>>0;return this.uint32(n),n&&this._push(p.writeBytesBuffer,n,c),this};function l(c,n,a){c.length<40?s.utf8.write(c,n,a):n.utf8Write?n.utf8Write(c,a):n.write(c,a)}p.prototype.string=function(c){var n=s.Buffer.byteLength(c);return this.uint32(n),n&&this._push(l,n,c),this},p._configure()}),vl=nt((t,r)=>{"use strict";r.exports=n;var o=we(),s,p=o.LongBits,l=o.utf8;function c(h,m){return RangeError("index out of range: "+h.pos+" + "+(m||1)+" > "+h.len)}function n(h){this.buf=h,this.pos=0,this.len=h.length}var a=typeof Uint8Array<"u"?function(h){if(h instanceof Uint8Array||Array.isArray(h))return new n(h);throw Error("illegal buffer")}:function(h){if(Array.isArray(h))return new n(h);throw Error("illegal buffer")},e=function(){return o.Buffer?function(h){return(n.create=function(m){return o.Buffer.isBuffer(m)?new s(m):a(m)})(h)}:a};n.create=e(),n.prototype._slice=o.Array.prototype.subarray||o.Array.prototype.slice,n.prototype.uint32=function(){var h=4294967295;return function(){if(h=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(h=(h|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return h;if((this.pos+=5)>this.len)throw this.pos=this.len,c(this,10);return h}}(),n.prototype.int32=function(){return this.uint32()|0},n.prototype.sint32=function(){var h=this.uint32();return h>>>1^-(h&1)|0};function u(){var h=new p(0,0),m=0;if(this.len-this.pos>4){for(;m<4;++m)if(h.lo=(h.lo|(this.buf[this.pos]&127)<<m*7)>>>0,this.buf[this.pos++]<128)return h;if(h.lo=(h.lo|(this.buf[this.pos]&127)<<28)>>>0,h.hi=(h.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return h;m=0}else{for(;m<3;++m){if(this.pos>=this.len)throw c(this);if(h.lo=(h.lo|(this.buf[this.pos]&127)<<m*7)>>>0,this.buf[this.pos++]<128)return h}return h.lo=(h.lo|(this.buf[this.pos++]&127)<<m*7)>>>0,h}if(this.len-this.pos>4){for(;m<5;++m)if(h.hi=(h.hi|(this.buf[this.pos]&127)<<m*7+3)>>>0,this.buf[this.pos++]<128)return h}else for(;m<5;++m){if(this.pos>=this.len)throw c(this);if(h.hi=(h.hi|(this.buf[this.pos]&127)<<m*7+3)>>>0,this.buf[this.pos++]<128)return h}throw Error("invalid varint encoding")}n.prototype.bool=function(){return this.uint32()!==0};function i(h,m){return(h[m-4]|h[m-3]<<8|h[m-2]<<16|h[m-1]<<24)>>>0}n.prototype.fixed32=function(){if(this.pos+4>this.len)throw c(this,4);return i(this.buf,this.pos+=4)},n.prototype.sfixed32=function(){if(this.pos+4>this.len)throw c(this,4);return i(this.buf,this.pos+=4)|0};function d(){if(this.pos+8>this.len)throw c(this,8);return new p(i(this.buf,this.pos+=4),i(this.buf,this.pos+=4))}n.prototype.float=function(){if(this.pos+4>this.len)throw c(this,4);var h=o.float.readFloatLE(this.buf,this.pos);return this.pos+=4,h},n.prototype.double=function(){if(this.pos+8>this.len)throw c(this,4);var h=o.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,h},n.prototype.bytes=function(){var h=this.uint32(),m=this.pos,b=this.pos+h;if(b>this.len)throw c(this,h);if(this.pos+=h,Array.isArray(this.buf))return this.buf.slice(m,b);if(m===b){var x=o.Buffer;return x?x.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,m,b)},n.prototype.string=function(){var h=this.bytes();return l.read(h,0,h.length)},n.prototype.skip=function(h){if(typeof h=="number"){if(this.pos+h>this.len)throw c(this,h);this.pos+=h}else do if(this.pos>=this.len)throw c(this);while(this.buf[this.pos++]&128);return this},n.prototype.skipType=function(h){switch(h){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(h=this.uint32()&7)!==4;)this.skipType(h);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+h+" at offset "+this.pos)}return this},n._configure=function(h){s=h,n.create=e(),s._configure();var m=o.Long?"toLong":"toNumber";o.merge(n.prototype,{int64:function(){return u.call(this)[m](!1)},uint64:function(){return u.call(this)[m](!0)},sint64:function(){return u.call(this).zzDecode()[m](!1)},fixed64:function(){return d.call(this)[m](!0)},sfixed64:function(){return d.call(this)[m](!1)}})}}),Xh=nt((t,r)=>{"use strict";r.exports=p;var o=vl();(p.prototype=Object.create(o.prototype)).constructor=p;var s=we();function p(l){o.call(this,l)}p._configure=function(){s.Buffer&&(p.prototype._slice=s.Buffer.prototype.slice)},p.prototype.string=function(){var l=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+l,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+l,this.len))},p._configure()}),Kh=nt((t,r)=>{"use strict";r.exports=s;var o=we();(s.prototype=Object.create(o.EventEmitter.prototype)).constructor=s;function s(p,l,c){if(typeof p!="function")throw TypeError("rpcImpl must be a function");o.EventEmitter.call(this),this.rpcImpl=p,this.requestDelimited=!!l,this.responseDelimited=!!c}s.prototype.rpcCall=function p(l,c,n,a,e){if(!a)throw TypeError("request must be specified");var u=this;if(!e)return o.asPromise(p,u,l,c,n,a);if(!u.rpcImpl){setTimeout(function(){e(Error("already ended"))},0);return}try{return u.rpcImpl(l,c[u.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(i,d){if(i)return u.emit("error",i,l),e(i);if(d===null){u.end(!0);return}if(!(d instanceof n))try{d=n[u.responseDelimited?"decodeDelimited":"decode"](d)}catch(h){return u.emit("error",h,l),e(h)}return u.emit("data",d,l),e(null,d)})}catch(i){u.emit("error",i,l),setTimeout(function(){e(i)},0);return}},s.prototype.end=function(p){return this.rpcImpl&&(p||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Zh=nt(t=>{"use strict";var r=t;r.Service=Kh()}),Jh=nt((t,r)=>{"use strict";r.exports={}}),Yh=nt(t=>{"use strict";var r=t;r.build="minimal",r.Writer=wl(),r.BufferWriter=Wh(),r.Reader=vl(),r.BufferReader=Xh(),r.util=we(),r.rpc=Zh(),r.roots=Jh(),r.configure=o;function o(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}o()}),Qh=nt((t,r)=>{"use strict";r.exports=Yh()}),mr=nt((t,r)=>{"use strict";var o=Qh(),s=o.Reader,p=o.Writer,l=o.util,c=o.roots.default||(o.roots.default={});c.onnx=function(){var n={};return n.Version=function(){var a={},e=Object.create(a);return e[a[0]="_START_VERSION"]=0,e[a[1]="IR_VERSION_2017_10_10"]=1,e[a[2]="IR_VERSION_2017_10_30"]=2,e[a[3]="IR_VERSION_2017_11_3"]=3,e[a[4]="IR_VERSION_2019_1_22"]=4,e[a[5]="IR_VERSION_2019_3_18"]=5,e[a[6]="IR_VERSION_2019_9_19"]=6,e[a[7]="IR_VERSION_2020_5_8"]=7,e[a[8]="IR_VERSION_2021_7_30"]=8,e[a[9]="IR_VERSION"]=9,e}(),n.AttributeProto=function(){function a(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.name="",a.prototype.refAttrName="",a.prototype.docString="",a.prototype.type=0,a.prototype.f=0,a.prototype.i=l.Long?l.Long.fromBits(0,0,!1):0,a.prototype.s=l.newBuffer([]),a.prototype.t=null,a.prototype.g=null,a.prototype.sparseTensor=null,a.prototype.tp=null,a.prototype.floats=l.emptyArray,a.prototype.ints=l.emptyArray,a.prototype.strings=l.emptyArray,a.prototype.tensors=l.emptyArray,a.prototype.graphs=l.emptyArray,a.prototype.sparseTensors=l.emptyArray,a.prototype.typeProtos=l.emptyArray,a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&u.uint32(10).string(e.name),e.f!=null&&Object.hasOwnProperty.call(e,"f")&&u.uint32(21).float(e.f),e.i!=null&&Object.hasOwnProperty.call(e,"i")&&u.uint32(24).int64(e.i),e.s!=null&&Object.hasOwnProperty.call(e,"s")&&u.uint32(34).bytes(e.s),e.t!=null&&Object.hasOwnProperty.call(e,"t")&&c.onnx.TensorProto.encode(e.t,u.uint32(42).fork()).ldelim(),e.g!=null&&Object.hasOwnProperty.call(e,"g")&&c.onnx.GraphProto.encode(e.g,u.uint32(50).fork()).ldelim(),e.floats!=null&&e.floats.length){u.uint32(58).fork();for(var i=0;i<e.floats.length;++i)u.float(e.floats[i]);u.ldelim()}if(e.ints!=null&&e.ints.length){u.uint32(66).fork();for(var i=0;i<e.ints.length;++i)u.int64(e.ints[i]);u.ldelim()}if(e.strings!=null&&e.strings.length)for(var i=0;i<e.strings.length;++i)u.uint32(74).bytes(e.strings[i]);if(e.tensors!=null&&e.tensors.length)for(var i=0;i<e.tensors.length;++i)c.onnx.TensorProto.encode(e.tensors[i],u.uint32(82).fork()).ldelim();if(e.graphs!=null&&e.graphs.length)for(var i=0;i<e.graphs.length;++i)c.onnx.GraphProto.encode(e.graphs[i],u.uint32(90).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&u.uint32(106).string(e.docString),e.tp!=null&&Object.hasOwnProperty.call(e,"tp")&&c.onnx.TypeProto.encode(e.tp,u.uint32(114).fork()).ldelim(),e.typeProtos!=null&&e.typeProtos.length)for(var i=0;i<e.typeProtos.length;++i)c.onnx.TypeProto.encode(e.typeProtos[i],u.uint32(122).fork()).ldelim();if(e.type!=null&&Object.hasOwnProperty.call(e,"type")&&u.uint32(160).int32(e.type),e.refAttrName!=null&&Object.hasOwnProperty.call(e,"refAttrName")&&u.uint32(170).string(e.refAttrName),e.sparseTensor!=null&&Object.hasOwnProperty.call(e,"sparseTensor")&&c.onnx.SparseTensorProto.encode(e.sparseTensor,u.uint32(178).fork()).ldelim(),e.sparseTensors!=null&&e.sparseTensors.length)for(var i=0;i<e.sparseTensors.length;++i)c.onnx.SparseTensorProto.encode(e.sparseTensors[i],u.uint32(186).fork()).ldelim();return u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.AttributeProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.name=e.string();break}case 21:{d.refAttrName=e.string();break}case 13:{d.docString=e.string();break}case 20:{d.type=e.int32();break}case 2:{d.f=e.float();break}case 3:{d.i=e.int64();break}case 4:{d.s=e.bytes();break}case 5:{d.t=c.onnx.TensorProto.decode(e,e.uint32());break}case 6:{d.g=c.onnx.GraphProto.decode(e,e.uint32());break}case 22:{d.sparseTensor=c.onnx.SparseTensorProto.decode(e,e.uint32());break}case 14:{d.tp=c.onnx.TypeProto.decode(e,e.uint32());break}case 7:{if(d.floats&&d.floats.length||(d.floats=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.floats.push(e.float());else d.floats.push(e.float());break}case 8:{if(d.ints&&d.ints.length||(d.ints=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.ints.push(e.int64());else d.ints.push(e.int64());break}case 9:{d.strings&&d.strings.length||(d.strings=[]),d.strings.push(e.bytes());break}case 10:{d.tensors&&d.tensors.length||(d.tensors=[]),d.tensors.push(c.onnx.TensorProto.decode(e,e.uint32()));break}case 11:{d.graphs&&d.graphs.length||(d.graphs=[]),d.graphs.push(c.onnx.GraphProto.decode(e,e.uint32()));break}case 23:{d.sparseTensors&&d.sparseTensors.length||(d.sparseTensors=[]),d.sparseTensors.push(c.onnx.SparseTensorProto.decode(e,e.uint32()));break}case 15:{d.typeProtos&&d.typeProtos.length||(d.typeProtos=[]),d.typeProtos.push(c.onnx.TypeProto.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&!l.isString(e.refAttrName))return"refAttrName: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(e.type!=null&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(e.f!=null&&e.hasOwnProperty("f")&&typeof e.f!="number")return"f: number expected";if(e.i!=null&&e.hasOwnProperty("i")&&!l.isInteger(e.i)&&!(e.i&&l.isInteger(e.i.low)&&l.isInteger(e.i.high)))return"i: integer|Long expected";if(e.s!=null&&e.hasOwnProperty("s")&&!(e.s&&typeof e.s.length=="number"||l.isString(e.s)))return"s: buffer expected";if(e.t!=null&&e.hasOwnProperty("t")){var u=c.onnx.TensorProto.verify(e.t);if(u)return"t."+u}if(e.g!=null&&e.hasOwnProperty("g")){var u=c.onnx.GraphProto.verify(e.g);if(u)return"g."+u}if(e.sparseTensor!=null&&e.hasOwnProperty("sparseTensor")){var u=c.onnx.SparseTensorProto.verify(e.sparseTensor);if(u)return"sparseTensor."+u}if(e.tp!=null&&e.hasOwnProperty("tp")){var u=c.onnx.TypeProto.verify(e.tp);if(u)return"tp."+u}if(e.floats!=null&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var i=0;i<e.floats.length;++i)if(typeof e.floats[i]!="number")return"floats: number[] expected"}if(e.ints!=null&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(var i=0;i<e.ints.length;++i)if(!l.isInteger(e.ints[i])&&!(e.ints[i]&&l.isInteger(e.ints[i].low)&&l.isInteger(e.ints[i].high)))return"ints: integer|Long[] expected"}if(e.strings!=null&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(var i=0;i<e.strings.length;++i)if(!(e.strings[i]&&typeof e.strings[i].length=="number"||l.isString(e.strings[i])))return"strings: buffer[] expected"}if(e.tensors!=null&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(var i=0;i<e.tensors.length;++i){var u=c.onnx.TensorProto.verify(e.tensors[i]);if(u)return"tensors."+u}}if(e.graphs!=null&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(var i=0;i<e.graphs.length;++i){var u=c.onnx.GraphProto.verify(e.graphs[i]);if(u)return"graphs."+u}}if(e.sparseTensors!=null&&e.hasOwnProperty("sparseTensors")){if(!Array.isArray(e.sparseTensors))return"sparseTensors: array expected";for(var i=0;i<e.sparseTensors.length;++i){var u=c.onnx.SparseTensorProto.verify(e.sparseTensors[i]);if(u)return"sparseTensors."+u}}if(e.typeProtos!=null&&e.hasOwnProperty("typeProtos")){if(!Array.isArray(e.typeProtos))return"typeProtos: array expected";for(var i=0;i<e.typeProtos.length;++i){var u=c.onnx.TypeProto.verify(e.typeProtos[i]);if(u)return"typeProtos."+u}}return null},a.fromObject=function(e){if(e instanceof c.onnx.AttributeProto)return e;var u=new c.onnx.AttributeProto;switch(e.name!=null&&(u.name=String(e.name)),e.refAttrName!=null&&(u.refAttrName=String(e.refAttrName)),e.docString!=null&&(u.docString=String(e.docString)),e.type){default:if(typeof e.type=="number"){u.type=e.type;break}break;case"UNDEFINED":case 0:u.type=0;break;case"FLOAT":case 1:u.type=1;break;case"INT":case 2:u.type=2;break;case"STRING":case 3:u.type=3;break;case"TENSOR":case 4:u.type=4;break;case"GRAPH":case 5:u.type=5;break;case"SPARSE_TENSOR":case 11:u.type=11;break;case"TYPE_PROTO":case 13:u.type=13;break;case"FLOATS":case 6:u.type=6;break;case"INTS":case 7:u.type=7;break;case"STRINGS":case 8:u.type=8;break;case"TENSORS":case 9:u.type=9;break;case"GRAPHS":case 10:u.type=10;break;case"SPARSE_TENSORS":case 12:u.type=12;break;case"TYPE_PROTOS":case 14:u.type=14;break}if(e.f!=null&&(u.f=Number(e.f)),e.i!=null&&(l.Long?(u.i=l.Long.fromValue(e.i)).unsigned=!1:typeof e.i=="string"?u.i=parseInt(e.i,10):typeof e.i=="number"?u.i=e.i:typeof e.i=="object"&&(u.i=new l.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),e.s!=null&&(typeof e.s=="string"?l.base64.decode(e.s,u.s=l.newBuffer(l.base64.length(e.s)),0):e.s.length>=0&&(u.s=e.s)),e.t!=null){if(typeof e.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");u.t=c.onnx.TensorProto.fromObject(e.t)}if(e.g!=null){if(typeof e.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");u.g=c.onnx.GraphProto.fromObject(e.g)}if(e.sparseTensor!=null){if(typeof e.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");u.sparseTensor=c.onnx.SparseTensorProto.fromObject(e.sparseTensor)}if(e.tp!=null){if(typeof e.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");u.tp=c.onnx.TypeProto.fromObject(e.tp)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");u.floats=[];for(var i=0;i<e.floats.length;++i)u.floats[i]=Number(e.floats[i])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");u.ints=[];for(var i=0;i<e.ints.length;++i)l.Long?(u.ints[i]=l.Long.fromValue(e.ints[i])).unsigned=!1:typeof e.ints[i]=="string"?u.ints[i]=parseInt(e.ints[i],10):typeof e.ints[i]=="number"?u.ints[i]=e.ints[i]:typeof e.ints[i]=="object"&&(u.ints[i]=new l.LongBits(e.ints[i].low>>>0,e.ints[i].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");u.strings=[];for(var i=0;i<e.strings.length;++i)typeof e.strings[i]=="string"?l.base64.decode(e.strings[i],u.strings[i]=l.newBuffer(l.base64.length(e.strings[i])),0):e.strings[i].length>=0&&(u.strings[i]=e.strings[i])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");u.tensors=[];for(var i=0;i<e.tensors.length;++i){if(typeof e.tensors[i]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");u.tensors[i]=c.onnx.TensorProto.fromObject(e.tensors[i])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");u.graphs=[];for(var i=0;i<e.graphs.length;++i){if(typeof e.graphs[i]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");u.graphs[i]=c.onnx.GraphProto.fromObject(e.graphs[i])}}if(e.sparseTensors){if(!Array.isArray(e.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");u.sparseTensors=[];for(var i=0;i<e.sparseTensors.length;++i){if(typeof e.sparseTensors[i]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");u.sparseTensors[i]=c.onnx.SparseTensorProto.fromObject(e.sparseTensors[i])}}if(e.typeProtos){if(!Array.isArray(e.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");u.typeProtos=[];for(var i=0;i<e.typeProtos.length;++i){if(typeof e.typeProtos[i]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");u.typeProtos[i]=c.onnx.TypeProto.fromObject(e.typeProtos[i])}}return u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.floats=[],i.ints=[],i.strings=[],i.tensors=[],i.graphs=[],i.typeProtos=[],i.sparseTensors=[]),u.defaults){if(i.name="",i.f=0,l.Long){var d=new l.Long(0,0,!1);i.i=u.longs===String?d.toString():u.longs===Number?d.toNumber():d}else i.i=u.longs===String?"0":0;u.bytes===String?i.s="":(i.s=[],u.bytes!==Array&&(i.s=l.newBuffer(i.s))),i.t=null,i.g=null,i.docString="",i.tp=null,i.type=u.enums===String?"UNDEFINED":0,i.refAttrName="",i.sparseTensor=null}if(e.name!=null&&e.hasOwnProperty("name")&&(i.name=e.name),e.f!=null&&e.hasOwnProperty("f")&&(i.f=u.json&&!isFinite(e.f)?String(e.f):e.f),e.i!=null&&e.hasOwnProperty("i")&&(typeof e.i=="number"?i.i=u.longs===String?String(e.i):e.i:i.i=u.longs===String?l.Long.prototype.toString.call(e.i):u.longs===Number?new l.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),e.s!=null&&e.hasOwnProperty("s")&&(i.s=u.bytes===String?l.base64.encode(e.s,0,e.s.length):u.bytes===Array?Array.prototype.slice.call(e.s):e.s),e.t!=null&&e.hasOwnProperty("t")&&(i.t=c.onnx.TensorProto.toObject(e.t,u)),e.g!=null&&e.hasOwnProperty("g")&&(i.g=c.onnx.GraphProto.toObject(e.g,u)),e.floats&&e.floats.length){i.floats=[];for(var h=0;h<e.floats.length;++h)i.floats[h]=u.json&&!isFinite(e.floats[h])?String(e.floats[h]):e.floats[h]}if(e.ints&&e.ints.length){i.ints=[];for(var h=0;h<e.ints.length;++h)typeof e.ints[h]=="number"?i.ints[h]=u.longs===String?String(e.ints[h]):e.ints[h]:i.ints[h]=u.longs===String?l.Long.prototype.toString.call(e.ints[h]):u.longs===Number?new l.LongBits(e.ints[h].low>>>0,e.ints[h].high>>>0).toNumber():e.ints[h]}if(e.strings&&e.strings.length){i.strings=[];for(var h=0;h<e.strings.length;++h)i.strings[h]=u.bytes===String?l.base64.encode(e.strings[h],0,e.strings[h].length):u.bytes===Array?Array.prototype.slice.call(e.strings[h]):e.strings[h]}if(e.tensors&&e.tensors.length){i.tensors=[];for(var h=0;h<e.tensors.length;++h)i.tensors[h]=c.onnx.TensorProto.toObject(e.tensors[h],u)}if(e.graphs&&e.graphs.length){i.graphs=[];for(var h=0;h<e.graphs.length;++h)i.graphs[h]=c.onnx.GraphProto.toObject(e.graphs[h],u)}if(e.docString!=null&&e.hasOwnProperty("docString")&&(i.docString=e.docString),e.tp!=null&&e.hasOwnProperty("tp")&&(i.tp=c.onnx.TypeProto.toObject(e.tp,u)),e.typeProtos&&e.typeProtos.length){i.typeProtos=[];for(var h=0;h<e.typeProtos.length;++h)i.typeProtos[h]=c.onnx.TypeProto.toObject(e.typeProtos[h],u)}if(e.type!=null&&e.hasOwnProperty("type")&&(i.type=u.enums===String?c.onnx.AttributeProto.AttributeType[e.type]===void 0?e.type:c.onnx.AttributeProto.AttributeType[e.type]:e.type),e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&(i.refAttrName=e.refAttrName),e.sparseTensor!=null&&e.hasOwnProperty("sparseTensor")&&(i.sparseTensor=c.onnx.SparseTensorProto.toObject(e.sparseTensor,u)),e.sparseTensors&&e.sparseTensors.length){i.sparseTensors=[];for(var h=0;h<e.sparseTensors.length;++h)i.sparseTensors[h]=c.onnx.SparseTensorProto.toObject(e.sparseTensors[h],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.AttributeProto"},a.AttributeType=function(){var e={},u=Object.create(e);return u[e[0]="UNDEFINED"]=0,u[e[1]="FLOAT"]=1,u[e[2]="INT"]=2,u[e[3]="STRING"]=3,u[e[4]="TENSOR"]=4,u[e[5]="GRAPH"]=5,u[e[11]="SPARSE_TENSOR"]=11,u[e[13]="TYPE_PROTO"]=13,u[e[6]="FLOATS"]=6,u[e[7]="INTS"]=7,u[e[8]="STRINGS"]=8,u[e[9]="TENSORS"]=9,u[e[10]="GRAPHS"]=10,u[e[12]="SPARSE_TENSORS"]=12,u[e[14]="TYPE_PROTOS"]=14,u}(),a}(),n.ValueInfoProto=function(){function a(e){if(e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.name="",a.prototype.type=null,a.prototype.docString="",a.create=function(e){return new a(e)},a.encode=function(e,u){return u||(u=p.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&u.uint32(10).string(e.name),e.type!=null&&Object.hasOwnProperty.call(e,"type")&&c.onnx.TypeProto.encode(e.type,u.uint32(18).fork()).ldelim(),e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&u.uint32(26).string(e.docString),u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.ValueInfoProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.name=e.string();break}case 2:{d.type=c.onnx.TypeProto.decode(e,e.uint32());break}case 3:{d.docString=e.string();break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(e.type!=null&&e.hasOwnProperty("type")){var u=c.onnx.TypeProto.verify(e.type);if(u)return"type."+u}return e.docString!=null&&e.hasOwnProperty("docString")&&!l.isString(e.docString)?"docString: string expected":null},a.fromObject=function(e){if(e instanceof c.onnx.ValueInfoProto)return e;var u=new c.onnx.ValueInfoProto;if(e.name!=null&&(u.name=String(e.name)),e.type!=null){if(typeof e.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");u.type=c.onnx.TypeProto.fromObject(e.type)}return e.docString!=null&&(u.docString=String(e.docString)),u},a.toObject=function(e,u){u||(u={});var i={};return u.defaults&&(i.name="",i.type=null,i.docString=""),e.name!=null&&e.hasOwnProperty("name")&&(i.name=e.name),e.type!=null&&e.hasOwnProperty("type")&&(i.type=c.onnx.TypeProto.toObject(e.type,u)),e.docString!=null&&e.hasOwnProperty("docString")&&(i.docString=e.docString),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.ValueInfoProto"},a}(),n.NodeProto=function(){function a(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.input=l.emptyArray,a.prototype.output=l.emptyArray,a.prototype.name="",a.prototype.opType="",a.prototype.domain="",a.prototype.attribute=l.emptyArray,a.prototype.docString="",a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.input!=null&&e.input.length)for(var i=0;i<e.input.length;++i)u.uint32(10).string(e.input[i]);if(e.output!=null&&e.output.length)for(var i=0;i<e.output.length;++i)u.uint32(18).string(e.output[i]);if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&u.uint32(26).string(e.name),e.opType!=null&&Object.hasOwnProperty.call(e,"opType")&&u.uint32(34).string(e.opType),e.attribute!=null&&e.attribute.length)for(var i=0;i<e.attribute.length;++i)c.onnx.AttributeProto.encode(e.attribute[i],u.uint32(42).fork()).ldelim();return e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&u.uint32(50).string(e.docString),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&u.uint32(58).string(e.domain),u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.NodeProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.input&&d.input.length||(d.input=[]),d.input.push(e.string());break}case 2:{d.output&&d.output.length||(d.output=[]),d.output.push(e.string());break}case 3:{d.name=e.string();break}case 4:{d.opType=e.string();break}case 7:{d.domain=e.string();break}case 5:{d.attribute&&d.attribute.length||(d.attribute=[]),d.attribute.push(c.onnx.AttributeProto.decode(e,e.uint32()));break}case 6:{d.docString=e.string();break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var u=0;u<e.input.length;++u)if(!l.isString(e.input[u]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(var u=0;u<e.output.length;++u)if(!l.isString(e.output[u]))return"output: string[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(e.opType!=null&&e.hasOwnProperty("opType")&&!l.isString(e.opType))return"opType: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!l.isString(e.domain))return"domain: string expected";if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(var u=0;u<e.attribute.length;++u){var i=c.onnx.AttributeProto.verify(e.attribute[u]);if(i)return"attribute."+i}}return e.docString!=null&&e.hasOwnProperty("docString")&&!l.isString(e.docString)?"docString: string expected":null},a.fromObject=function(e){if(e instanceof c.onnx.NodeProto)return e;var u=new c.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");u.input=[];for(var i=0;i<e.input.length;++i)u.input[i]=String(e.input[i])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");u.output=[];for(var i=0;i<e.output.length;++i)u.output[i]=String(e.output[i])}if(e.name!=null&&(u.name=String(e.name)),e.opType!=null&&(u.opType=String(e.opType)),e.domain!=null&&(u.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");u.attribute=[];for(var i=0;i<e.attribute.length;++i){if(typeof e.attribute[i]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");u.attribute[i]=c.onnx.AttributeProto.fromObject(e.attribute[i])}}return e.docString!=null&&(u.docString=String(e.docString)),u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.input=[],i.output=[],i.attribute=[]),u.defaults&&(i.name="",i.opType="",i.docString="",i.domain=""),e.input&&e.input.length){i.input=[];for(var d=0;d<e.input.length;++d)i.input[d]=e.input[d]}if(e.output&&e.output.length){i.output=[];for(var d=0;d<e.output.length;++d)i.output[d]=e.output[d]}if(e.name!=null&&e.hasOwnProperty("name")&&(i.name=e.name),e.opType!=null&&e.hasOwnProperty("opType")&&(i.opType=e.opType),e.attribute&&e.attribute.length){i.attribute=[];for(var d=0;d<e.attribute.length;++d)i.attribute[d]=c.onnx.AttributeProto.toObject(e.attribute[d],u)}return e.docString!=null&&e.hasOwnProperty("docString")&&(i.docString=e.docString),e.domain!=null&&e.hasOwnProperty("domain")&&(i.domain=e.domain),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.NodeProto"},a}(),n.TrainingInfoProto=function(){function a(e){if(this.initializationBinding=[],this.updateBinding=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.initialization=null,a.prototype.algorithm=null,a.prototype.initializationBinding=l.emptyArray,a.prototype.updateBinding=l.emptyArray,a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.initialization!=null&&Object.hasOwnProperty.call(e,"initialization")&&c.onnx.GraphProto.encode(e.initialization,u.uint32(10).fork()).ldelim(),e.algorithm!=null&&Object.hasOwnProperty.call(e,"algorithm")&&c.onnx.GraphProto.encode(e.algorithm,u.uint32(18).fork()).ldelim(),e.initializationBinding!=null&&e.initializationBinding.length)for(var i=0;i<e.initializationBinding.length;++i)c.onnx.StringStringEntryProto.encode(e.initializationBinding[i],u.uint32(26).fork()).ldelim();if(e.updateBinding!=null&&e.updateBinding.length)for(var i=0;i<e.updateBinding.length;++i)c.onnx.StringStringEntryProto.encode(e.updateBinding[i],u.uint32(34).fork()).ldelim();return u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.TrainingInfoProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.initialization=c.onnx.GraphProto.decode(e,e.uint32());break}case 2:{d.algorithm=c.onnx.GraphProto.decode(e,e.uint32());break}case 3:{d.initializationBinding&&d.initializationBinding.length||(d.initializationBinding=[]),d.initializationBinding.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 4:{d.updateBinding&&d.updateBinding.length||(d.updateBinding=[]),d.updateBinding.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.initialization!=null&&e.hasOwnProperty("initialization")){var u=c.onnx.GraphProto.verify(e.initialization);if(u)return"initialization."+u}if(e.algorithm!=null&&e.hasOwnProperty("algorithm")){var u=c.onnx.GraphProto.verify(e.algorithm);if(u)return"algorithm."+u}if(e.initializationBinding!=null&&e.hasOwnProperty("initializationBinding")){if(!Array.isArray(e.initializationBinding))return"initializationBinding: array expected";for(var i=0;i<e.initializationBinding.length;++i){var u=c.onnx.StringStringEntryProto.verify(e.initializationBinding[i]);if(u)return"initializationBinding."+u}}if(e.updateBinding!=null&&e.hasOwnProperty("updateBinding")){if(!Array.isArray(e.updateBinding))return"updateBinding: array expected";for(var i=0;i<e.updateBinding.length;++i){var u=c.onnx.StringStringEntryProto.verify(e.updateBinding[i]);if(u)return"updateBinding."+u}}return null},a.fromObject=function(e){if(e instanceof c.onnx.TrainingInfoProto)return e;var u=new c.onnx.TrainingInfoProto;if(e.initialization!=null){if(typeof e.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");u.initialization=c.onnx.GraphProto.fromObject(e.initialization)}if(e.algorithm!=null){if(typeof e.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");u.algorithm=c.onnx.GraphProto.fromObject(e.algorithm)}if(e.initializationBinding){if(!Array.isArray(e.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");u.initializationBinding=[];for(var i=0;i<e.initializationBinding.length;++i){if(typeof e.initializationBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");u.initializationBinding[i]=c.onnx.StringStringEntryProto.fromObject(e.initializationBinding[i])}}if(e.updateBinding){if(!Array.isArray(e.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");u.updateBinding=[];for(var i=0;i<e.updateBinding.length;++i){if(typeof e.updateBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");u.updateBinding[i]=c.onnx.StringStringEntryProto.fromObject(e.updateBinding[i])}}return u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.initializationBinding=[],i.updateBinding=[]),u.defaults&&(i.initialization=null,i.algorithm=null),e.initialization!=null&&e.hasOwnProperty("initialization")&&(i.initialization=c.onnx.GraphProto.toObject(e.initialization,u)),e.algorithm!=null&&e.hasOwnProperty("algorithm")&&(i.algorithm=c.onnx.GraphProto.toObject(e.algorithm,u)),e.initializationBinding&&e.initializationBinding.length){i.initializationBinding=[];for(var d=0;d<e.initializationBinding.length;++d)i.initializationBinding[d]=c.onnx.StringStringEntryProto.toObject(e.initializationBinding[d],u)}if(e.updateBinding&&e.updateBinding.length){i.updateBinding=[];for(var d=0;d<e.updateBinding.length;++d)i.updateBinding[d]=c.onnx.StringStringEntryProto.toObject(e.updateBinding[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TrainingInfoProto"},a}(),n.ModelProto=function(){function a(e){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.irVersion=l.Long?l.Long.fromBits(0,0,!1):0,a.prototype.opsetImport=l.emptyArray,a.prototype.producerName="",a.prototype.producerVersion="",a.prototype.domain="",a.prototype.modelVersion=l.Long?l.Long.fromBits(0,0,!1):0,a.prototype.docString="",a.prototype.graph=null,a.prototype.metadataProps=l.emptyArray,a.prototype.trainingInfo=l.emptyArray,a.prototype.functions=l.emptyArray,a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.irVersion!=null&&Object.hasOwnProperty.call(e,"irVersion")&&u.uint32(8).int64(e.irVersion),e.producerName!=null&&Object.hasOwnProperty.call(e,"producerName")&&u.uint32(18).string(e.producerName),e.producerVersion!=null&&Object.hasOwnProperty.call(e,"producerVersion")&&u.uint32(26).string(e.producerVersion),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&u.uint32(34).string(e.domain),e.modelVersion!=null&&Object.hasOwnProperty.call(e,"modelVersion")&&u.uint32(40).int64(e.modelVersion),e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&u.uint32(50).string(e.docString),e.graph!=null&&Object.hasOwnProperty.call(e,"graph")&&c.onnx.GraphProto.encode(e.graph,u.uint32(58).fork()).ldelim(),e.opsetImport!=null&&e.opsetImport.length)for(var i=0;i<e.opsetImport.length;++i)c.onnx.OperatorSetIdProto.encode(e.opsetImport[i],u.uint32(66).fork()).ldelim();if(e.metadataProps!=null&&e.metadataProps.length)for(var i=0;i<e.metadataProps.length;++i)c.onnx.StringStringEntryProto.encode(e.metadataProps[i],u.uint32(114).fork()).ldelim();if(e.trainingInfo!=null&&e.trainingInfo.length)for(var i=0;i<e.trainingInfo.length;++i)c.onnx.TrainingInfoProto.encode(e.trainingInfo[i],u.uint32(162).fork()).ldelim();if(e.functions!=null&&e.functions.length)for(var i=0;i<e.functions.length;++i)c.onnx.FunctionProto.encode(e.functions[i],u.uint32(202).fork()).ldelim();return u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.ModelProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.irVersion=e.int64();break}case 8:{d.opsetImport&&d.opsetImport.length||(d.opsetImport=[]),d.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e,e.uint32()));break}case 2:{d.producerName=e.string();break}case 3:{d.producerVersion=e.string();break}case 4:{d.domain=e.string();break}case 5:{d.modelVersion=e.int64();break}case 6:{d.docString=e.string();break}case 7:{d.graph=c.onnx.GraphProto.decode(e,e.uint32());break}case 14:{d.metadataProps&&d.metadataProps.length||(d.metadataProps=[]),d.metadataProps.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 20:{d.trainingInfo&&d.trainingInfo.length||(d.trainingInfo=[]),d.trainingInfo.push(c.onnx.TrainingInfoProto.decode(e,e.uint32()));break}case 25:{d.functions&&d.functions.length||(d.functions=[]),d.functions.push(c.onnx.FunctionProto.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&!l.isInteger(e.irVersion)&&!(e.irVersion&&l.isInteger(e.irVersion.low)&&l.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var u=0;u<e.opsetImport.length;++u){var i=c.onnx.OperatorSetIdProto.verify(e.opsetImport[u]);if(i)return"opsetImport."+i}}if(e.producerName!=null&&e.hasOwnProperty("producerName")&&!l.isString(e.producerName))return"producerName: string expected";if(e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&!l.isString(e.producerVersion))return"producerVersion: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!l.isString(e.domain))return"domain: string expected";if(e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&!l.isInteger(e.modelVersion)&&!(e.modelVersion&&l.isInteger(e.modelVersion.low)&&l.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(e.graph!=null&&e.hasOwnProperty("graph")){var i=c.onnx.GraphProto.verify(e.graph);if(i)return"graph."+i}if(e.metadataProps!=null&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(var u=0;u<e.metadataProps.length;++u){var i=c.onnx.StringStringEntryProto.verify(e.metadataProps[u]);if(i)return"metadataProps."+i}}if(e.trainingInfo!=null&&e.hasOwnProperty("trainingInfo")){if(!Array.isArray(e.trainingInfo))return"trainingInfo: array expected";for(var u=0;u<e.trainingInfo.length;++u){var i=c.onnx.TrainingInfoProto.verify(e.trainingInfo[u]);if(i)return"trainingInfo."+i}}if(e.functions!=null&&e.hasOwnProperty("functions")){if(!Array.isArray(e.functions))return"functions: array expected";for(var u=0;u<e.functions.length;++u){var i=c.onnx.FunctionProto.verify(e.functions[u]);if(i)return"functions."+i}}return null},a.fromObject=function(e){if(e instanceof c.onnx.ModelProto)return e;var u=new c.onnx.ModelProto;if(e.irVersion!=null&&(l.Long?(u.irVersion=l.Long.fromValue(e.irVersion)).unsigned=!1:typeof e.irVersion=="string"?u.irVersion=parseInt(e.irVersion,10):typeof e.irVersion=="number"?u.irVersion=e.irVersion:typeof e.irVersion=="object"&&(u.irVersion=new l.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");u.opsetImport=[];for(var i=0;i<e.opsetImport.length;++i){if(typeof e.opsetImport[i]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");u.opsetImport[i]=c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[i])}}if(e.producerName!=null&&(u.producerName=String(e.producerName)),e.producerVersion!=null&&(u.producerVersion=String(e.producerVersion)),e.domain!=null&&(u.domain=String(e.domain)),e.modelVersion!=null&&(l.Long?(u.modelVersion=l.Long.fromValue(e.modelVersion)).unsigned=!1:typeof e.modelVersion=="string"?u.modelVersion=parseInt(e.modelVersion,10):typeof e.modelVersion=="number"?u.modelVersion=e.modelVersion:typeof e.modelVersion=="object"&&(u.modelVersion=new l.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),e.docString!=null&&(u.docString=String(e.docString)),e.graph!=null){if(typeof e.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");u.graph=c.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");u.metadataProps=[];for(var i=0;i<e.metadataProps.length;++i){if(typeof e.metadataProps[i]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");u.metadataProps[i]=c.onnx.StringStringEntryProto.fromObject(e.metadataProps[i])}}if(e.trainingInfo){if(!Array.isArray(e.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");u.trainingInfo=[];for(var i=0;i<e.trainingInfo.length;++i){if(typeof e.trainingInfo[i]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");u.trainingInfo[i]=c.onnx.TrainingInfoProto.fromObject(e.trainingInfo[i])}}if(e.functions){if(!Array.isArray(e.functions))throw TypeError(".onnx.ModelProto.functions: array expected");u.functions=[];for(var i=0;i<e.functions.length;++i){if(typeof e.functions[i]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");u.functions[i]=c.onnx.FunctionProto.fromObject(e.functions[i])}}return u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.opsetImport=[],i.metadataProps=[],i.trainingInfo=[],i.functions=[]),u.defaults){if(l.Long){var d=new l.Long(0,0,!1);i.irVersion=u.longs===String?d.toString():u.longs===Number?d.toNumber():d}else i.irVersion=u.longs===String?"0":0;if(i.producerName="",i.producerVersion="",i.domain="",l.Long){var d=new l.Long(0,0,!1);i.modelVersion=u.longs===String?d.toString():u.longs===Number?d.toNumber():d}else i.modelVersion=u.longs===String?"0":0;i.docString="",i.graph=null}if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&(typeof e.irVersion=="number"?i.irVersion=u.longs===String?String(e.irVersion):e.irVersion:i.irVersion=u.longs===String?l.Long.prototype.toString.call(e.irVersion):u.longs===Number?new l.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),e.producerName!=null&&e.hasOwnProperty("producerName")&&(i.producerName=e.producerName),e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&(i.producerVersion=e.producerVersion),e.domain!=null&&e.hasOwnProperty("domain")&&(i.domain=e.domain),e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&(typeof e.modelVersion=="number"?i.modelVersion=u.longs===String?String(e.modelVersion):e.modelVersion:i.modelVersion=u.longs===String?l.Long.prototype.toString.call(e.modelVersion):u.longs===Number?new l.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),e.docString!=null&&e.hasOwnProperty("docString")&&(i.docString=e.docString),e.graph!=null&&e.hasOwnProperty("graph")&&(i.graph=c.onnx.GraphProto.toObject(e.graph,u)),e.opsetImport&&e.opsetImport.length){i.opsetImport=[];for(var h=0;h<e.opsetImport.length;++h)i.opsetImport[h]=c.onnx.OperatorSetIdProto.toObject(e.opsetImport[h],u)}if(e.metadataProps&&e.metadataProps.length){i.metadataProps=[];for(var h=0;h<e.metadataProps.length;++h)i.metadataProps[h]=c.onnx.StringStringEntryProto.toObject(e.metadataProps[h],u)}if(e.trainingInfo&&e.trainingInfo.length){i.trainingInfo=[];for(var h=0;h<e.trainingInfo.length;++h)i.trainingInfo[h]=c.onnx.TrainingInfoProto.toObject(e.trainingInfo[h],u)}if(e.functions&&e.functions.length){i.functions=[];for(var h=0;h<e.functions.length;++h)i.functions[h]=c.onnx.FunctionProto.toObject(e.functions[h],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.ModelProto"},a}(),n.StringStringEntryProto=function(){function a(e){if(e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.key="",a.prototype.value="",a.create=function(e){return new a(e)},a.encode=function(e,u){return u||(u=p.create()),e.key!=null&&Object.hasOwnProperty.call(e,"key")&&u.uint32(10).string(e.key),e.value!=null&&Object.hasOwnProperty.call(e,"value")&&u.uint32(18).string(e.value),u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.StringStringEntryProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.key=e.string();break}case 2:{d.value=e.string();break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){return typeof e!="object"||e===null?"object expected":e.key!=null&&e.hasOwnProperty("key")&&!l.isString(e.key)?"key: string expected":e.value!=null&&e.hasOwnProperty("value")&&!l.isString(e.value)?"value: string expected":null},a.fromObject=function(e){if(e instanceof c.onnx.StringStringEntryProto)return e;var u=new c.onnx.StringStringEntryProto;return e.key!=null&&(u.key=String(e.key)),e.value!=null&&(u.value=String(e.value)),u},a.toObject=function(e,u){u||(u={});var i={};return u.defaults&&(i.key="",i.value=""),e.key!=null&&e.hasOwnProperty("key")&&(i.key=e.key),e.value!=null&&e.hasOwnProperty("value")&&(i.value=e.value),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.StringStringEntryProto"},a}(),n.TensorAnnotation=function(){function a(e){if(this.quantParameterTensorNames=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.tensorName="",a.prototype.quantParameterTensorNames=l.emptyArray,a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.tensorName!=null&&Object.hasOwnProperty.call(e,"tensorName")&&u.uint32(10).string(e.tensorName),e.quantParameterTensorNames!=null&&e.quantParameterTensorNames.length)for(var i=0;i<e.quantParameterTensorNames.length;++i)c.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[i],u.uint32(18).fork()).ldelim();return u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.TensorAnnotation;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.tensorName=e.string();break}case 2:{d.quantParameterTensorNames&&d.quantParameterTensorNames.length||(d.quantParameterTensorNames=[]),d.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.tensorName!=null&&e.hasOwnProperty("tensorName")&&!l.isString(e.tensorName))return"tensorName: string expected";if(e.quantParameterTensorNames!=null&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var u=0;u<e.quantParameterTensorNames.length;++u){var i=c.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[u]);if(i)return"quantParameterTensorNames."+i}}return null},a.fromObject=function(e){if(e instanceof c.onnx.TensorAnnotation)return e;var u=new c.onnx.TensorAnnotation;if(e.tensorName!=null&&(u.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");u.quantParameterTensorNames=[];for(var i=0;i<e.quantParameterTensorNames.length;++i){if(typeof e.quantParameterTensorNames[i]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");u.quantParameterTensorNames[i]=c.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[i])}}return u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.quantParameterTensorNames=[]),u.defaults&&(i.tensorName=""),e.tensorName!=null&&e.hasOwnProperty("tensorName")&&(i.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){i.quantParameterTensorNames=[];for(var d=0;d<e.quantParameterTensorNames.length;++d)i.quantParameterTensorNames[d]=c.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorAnnotation"},a}(),n.GraphProto=function(){function a(e){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.node=l.emptyArray,a.prototype.name="",a.prototype.initializer=l.emptyArray,a.prototype.sparseInitializer=l.emptyArray,a.prototype.docString="",a.prototype.input=l.emptyArray,a.prototype.output=l.emptyArray,a.prototype.valueInfo=l.emptyArray,a.prototype.quantizationAnnotation=l.emptyArray,a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.node!=null&&e.node.length)for(var i=0;i<e.node.length;++i)c.onnx.NodeProto.encode(e.node[i],u.uint32(10).fork()).ldelim();if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&u.uint32(18).string(e.name),e.initializer!=null&&e.initializer.length)for(var i=0;i<e.initializer.length;++i)c.onnx.TensorProto.encode(e.initializer[i],u.uint32(42).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&u.uint32(82).string(e.docString),e.input!=null&&e.input.length)for(var i=0;i<e.input.length;++i)c.onnx.ValueInfoProto.encode(e.input[i],u.uint32(90).fork()).ldelim();if(e.output!=null&&e.output.length)for(var i=0;i<e.output.length;++i)c.onnx.ValueInfoProto.encode(e.output[i],u.uint32(98).fork()).ldelim();if(e.valueInfo!=null&&e.valueInfo.length)for(var i=0;i<e.valueInfo.length;++i)c.onnx.ValueInfoProto.encode(e.valueInfo[i],u.uint32(106).fork()).ldelim();if(e.quantizationAnnotation!=null&&e.quantizationAnnotation.length)for(var i=0;i<e.quantizationAnnotation.length;++i)c.onnx.TensorAnnotation.encode(e.quantizationAnnotation[i],u.uint32(114).fork()).ldelim();if(e.sparseInitializer!=null&&e.sparseInitializer.length)for(var i=0;i<e.sparseInitializer.length;++i)c.onnx.SparseTensorProto.encode(e.sparseInitializer[i],u.uint32(122).fork()).ldelim();return u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.GraphProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.node&&d.node.length||(d.node=[]),d.node.push(c.onnx.NodeProto.decode(e,e.uint32()));break}case 2:{d.name=e.string();break}case 5:{d.initializer&&d.initializer.length||(d.initializer=[]),d.initializer.push(c.onnx.TensorProto.decode(e,e.uint32()));break}case 15:{d.sparseInitializer&&d.sparseInitializer.length||(d.sparseInitializer=[]),d.sparseInitializer.push(c.onnx.SparseTensorProto.decode(e,e.uint32()));break}case 10:{d.docString=e.string();break}case 11:{d.input&&d.input.length||(d.input=[]),d.input.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 12:{d.output&&d.output.length||(d.output=[]),d.output.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 13:{d.valueInfo&&d.valueInfo.length||(d.valueInfo=[]),d.valueInfo.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break}case 14:{d.quantizationAnnotation&&d.quantizationAnnotation.length||(d.quantizationAnnotation=[]),d.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var u=0;u<e.node.length;++u){var i=c.onnx.NodeProto.verify(e.node[u]);if(i)return"node."+i}}if(e.name!=null&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(e.initializer!=null&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(var u=0;u<e.initializer.length;++u){var i=c.onnx.TensorProto.verify(e.initializer[u]);if(i)return"initializer."+i}}if(e.sparseInitializer!=null&&e.hasOwnProperty("sparseInitializer")){if(!Array.isArray(e.sparseInitializer))return"sparseInitializer: array expected";for(var u=0;u<e.sparseInitializer.length;++u){var i=c.onnx.SparseTensorProto.verify(e.sparseInitializer[u]);if(i)return"sparseInitializer."+i}}if(e.docString!=null&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var u=0;u<e.input.length;++u){var i=c.onnx.ValueInfoProto.verify(e.input[u]);if(i)return"input."+i}}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(var u=0;u<e.output.length;++u){var i=c.onnx.ValueInfoProto.verify(e.output[u]);if(i)return"output."+i}}if(e.valueInfo!=null&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(var u=0;u<e.valueInfo.length;++u){var i=c.onnx.ValueInfoProto.verify(e.valueInfo[u]);if(i)return"valueInfo."+i}}if(e.quantizationAnnotation!=null&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var u=0;u<e.quantizationAnnotation.length;++u){var i=c.onnx.TensorAnnotation.verify(e.quantizationAnnotation[u]);if(i)return"quantizationAnnotation."+i}}return null},a.fromObject=function(e){if(e instanceof c.onnx.GraphProto)return e;var u=new c.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");u.node=[];for(var i=0;i<e.node.length;++i){if(typeof e.node[i]!="object")throw TypeError(".onnx.GraphProto.node: object expected");u.node[i]=c.onnx.NodeProto.fromObject(e.node[i])}}if(e.name!=null&&(u.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");u.initializer=[];for(var i=0;i<e.initializer.length;++i){if(typeof e.initializer[i]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");u.initializer[i]=c.onnx.TensorProto.fromObject(e.initializer[i])}}if(e.sparseInitializer){if(!Array.isArray(e.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");u.sparseInitializer=[];for(var i=0;i<e.sparseInitializer.length;++i){if(typeof e.sparseInitializer[i]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");u.sparseInitializer[i]=c.onnx.SparseTensorProto.fromObject(e.sparseInitializer[i])}}if(e.docString!=null&&(u.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");u.input=[];for(var i=0;i<e.input.length;++i){if(typeof e.input[i]!="object")throw TypeError(".onnx.GraphProto.input: object expected");u.input[i]=c.onnx.ValueInfoProto.fromObject(e.input[i])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");u.output=[];for(var i=0;i<e.output.length;++i){if(typeof e.output[i]!="object")throw TypeError(".onnx.GraphProto.output: object expected");u.output[i]=c.onnx.ValueInfoProto.fromObject(e.output[i])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");u.valueInfo=[];for(var i=0;i<e.valueInfo.length;++i){if(typeof e.valueInfo[i]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");u.valueInfo[i]=c.onnx.ValueInfoProto.fromObject(e.valueInfo[i])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");u.quantizationAnnotation=[];for(var i=0;i<e.quantizationAnnotation.length;++i){if(typeof e.quantizationAnnotation[i]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");u.quantizationAnnotation[i]=c.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[i])}}return u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.node=[],i.initializer=[],i.input=[],i.output=[],i.valueInfo=[],i.quantizationAnnotation=[],i.sparseInitializer=[]),u.defaults&&(i.name="",i.docString=""),e.node&&e.node.length){i.node=[];for(var d=0;d<e.node.length;++d)i.node[d]=c.onnx.NodeProto.toObject(e.node[d],u)}if(e.name!=null&&e.hasOwnProperty("name")&&(i.name=e.name),e.initializer&&e.initializer.length){i.initializer=[];for(var d=0;d<e.initializer.length;++d)i.initializer[d]=c.onnx.TensorProto.toObject(e.initializer[d],u)}if(e.docString!=null&&e.hasOwnProperty("docString")&&(i.docString=e.docString),e.input&&e.input.length){i.input=[];for(var d=0;d<e.input.length;++d)i.input[d]=c.onnx.ValueInfoProto.toObject(e.input[d],u)}if(e.output&&e.output.length){i.output=[];for(var d=0;d<e.output.length;++d)i.output[d]=c.onnx.ValueInfoProto.toObject(e.output[d],u)}if(e.valueInfo&&e.valueInfo.length){i.valueInfo=[];for(var d=0;d<e.valueInfo.length;++d)i.valueInfo[d]=c.onnx.ValueInfoProto.toObject(e.valueInfo[d],u)}if(e.quantizationAnnotation&&e.quantizationAnnotation.length){i.quantizationAnnotation=[];for(var d=0;d<e.quantizationAnnotation.length;++d)i.quantizationAnnotation[d]=c.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[d],u)}if(e.sparseInitializer&&e.sparseInitializer.length){i.sparseInitializer=[];for(var d=0;d<e.sparseInitializer.length;++d)i.sparseInitializer[d]=c.onnx.SparseTensorProto.toObject(e.sparseInitializer[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.GraphProto"},a}(),n.TensorProto=function(){function a(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.dims=l.emptyArray,a.prototype.dataType=0,a.prototype.segment=null,a.prototype.floatData=l.emptyArray,a.prototype.int32Data=l.emptyArray,a.prototype.stringData=l.emptyArray,a.prototype.int64Data=l.emptyArray,a.prototype.name="",a.prototype.docString="",a.prototype.rawData=l.newBuffer([]),a.prototype.externalData=l.emptyArray,a.prototype.dataLocation=0,a.prototype.doubleData=l.emptyArray,a.prototype.uint64Data=l.emptyArray,a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.dims!=null&&e.dims.length){u.uint32(10).fork();for(var i=0;i<e.dims.length;++i)u.int64(e.dims[i]);u.ldelim()}if(e.dataType!=null&&Object.hasOwnProperty.call(e,"dataType")&&u.uint32(16).int32(e.dataType),e.segment!=null&&Object.hasOwnProperty.call(e,"segment")&&c.onnx.TensorProto.Segment.encode(e.segment,u.uint32(26).fork()).ldelim(),e.floatData!=null&&e.floatData.length){u.uint32(34).fork();for(var i=0;i<e.floatData.length;++i)u.float(e.floatData[i]);u.ldelim()}if(e.int32Data!=null&&e.int32Data.length){u.uint32(42).fork();for(var i=0;i<e.int32Data.length;++i)u.int32(e.int32Data[i]);u.ldelim()}if(e.stringData!=null&&e.stringData.length)for(var i=0;i<e.stringData.length;++i)u.uint32(50).bytes(e.stringData[i]);if(e.int64Data!=null&&e.int64Data.length){u.uint32(58).fork();for(var i=0;i<e.int64Data.length;++i)u.int64(e.int64Data[i]);u.ldelim()}if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&u.uint32(66).string(e.name),e.rawData!=null&&Object.hasOwnProperty.call(e,"rawData")&&u.uint32(74).bytes(e.rawData),e.doubleData!=null&&e.doubleData.length){u.uint32(82).fork();for(var i=0;i<e.doubleData.length;++i)u.double(e.doubleData[i]);u.ldelim()}if(e.uint64Data!=null&&e.uint64Data.length){u.uint32(90).fork();for(var i=0;i<e.uint64Data.length;++i)u.uint64(e.uint64Data[i]);u.ldelim()}if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&u.uint32(98).string(e.docString),e.externalData!=null&&e.externalData.length)for(var i=0;i<e.externalData.length;++i)c.onnx.StringStringEntryProto.encode(e.externalData[i],u.uint32(106).fork()).ldelim();return e.dataLocation!=null&&Object.hasOwnProperty.call(e,"dataLocation")&&u.uint32(112).int32(e.dataLocation),u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.TensorProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{if(d.dims&&d.dims.length||(d.dims=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.dims.push(e.int64());else d.dims.push(e.int64());break}case 2:{d.dataType=e.int32();break}case 3:{d.segment=c.onnx.TensorProto.Segment.decode(e,e.uint32());break}case 4:{if(d.floatData&&d.floatData.length||(d.floatData=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.floatData.push(e.float());else d.floatData.push(e.float());break}case 5:{if(d.int32Data&&d.int32Data.length||(d.int32Data=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.int32Data.push(e.int32());else d.int32Data.push(e.int32());break}case 6:{d.stringData&&d.stringData.length||(d.stringData=[]),d.stringData.push(e.bytes());break}case 7:{if(d.int64Data&&d.int64Data.length||(d.int64Data=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.int64Data.push(e.int64());else d.int64Data.push(e.int64());break}case 8:{d.name=e.string();break}case 12:{d.docString=e.string();break}case 9:{d.rawData=e.bytes();break}case 13:{d.externalData&&d.externalData.length||(d.externalData=[]),d.externalData.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break}case 14:{d.dataLocation=e.int32();break}case 10:{if(d.doubleData&&d.doubleData.length||(d.doubleData=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.doubleData.push(e.double());else d.doubleData.push(e.double());break}case 11:{if(d.uint64Data&&d.uint64Data.length||(d.uint64Data=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.uint64Data.push(e.uint64());else d.uint64Data.push(e.uint64());break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var u=0;u<e.dims.length;++u)if(!l.isInteger(e.dims[u])&&!(e.dims[u]&&l.isInteger(e.dims[u].low)&&l.isInteger(e.dims[u].high)))return"dims: integer|Long[] expected"}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&!l.isInteger(e.dataType))return"dataType: integer expected";if(e.segment!=null&&e.hasOwnProperty("segment")){var i=c.onnx.TensorProto.Segment.verify(e.segment);if(i)return"segment."+i}if(e.floatData!=null&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(var u=0;u<e.floatData.length;++u)if(typeof e.floatData[u]!="number")return"floatData: number[] expected"}if(e.int32Data!=null&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(var u=0;u<e.int32Data.length;++u)if(!l.isInteger(e.int32Data[u]))return"int32Data: integer[] expected"}if(e.stringData!=null&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(var u=0;u<e.stringData.length;++u)if(!(e.stringData[u]&&typeof e.stringData[u].length=="number"||l.isString(e.stringData[u])))return"stringData: buffer[] expected"}if(e.int64Data!=null&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(var u=0;u<e.int64Data.length;++u)if(!l.isInteger(e.int64Data[u])&&!(e.int64Data[u]&&l.isInteger(e.int64Data[u].low)&&l.isInteger(e.int64Data[u].high)))return"int64Data: integer|Long[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(e.rawData!=null&&e.hasOwnProperty("rawData")&&!(e.rawData&&typeof e.rawData.length=="number"||l.isString(e.rawData)))return"rawData: buffer expected";if(e.externalData!=null&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(var u=0;u<e.externalData.length;++u){var i=c.onnx.StringStringEntryProto.verify(e.externalData[u]);if(i)return"externalData."+i}}if(e.dataLocation!=null&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(e.doubleData!=null&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(var u=0;u<e.doubleData.length;++u)if(typeof e.doubleData[u]!="number")return"doubleData: number[] expected"}if(e.uint64Data!=null&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(var u=0;u<e.uint64Data.length;++u)if(!l.isInteger(e.uint64Data[u])&&!(e.uint64Data[u]&&l.isInteger(e.uint64Data[u].low)&&l.isInteger(e.uint64Data[u].high)))return"uint64Data: integer|Long[] expected"}return null},a.fromObject=function(e){if(e instanceof c.onnx.TensorProto)return e;var u=new c.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");u.dims=[];for(var i=0;i<e.dims.length;++i)l.Long?(u.dims[i]=l.Long.fromValue(e.dims[i])).unsigned=!1:typeof e.dims[i]=="string"?u.dims[i]=parseInt(e.dims[i],10):typeof e.dims[i]=="number"?u.dims[i]=e.dims[i]:typeof e.dims[i]=="object"&&(u.dims[i]=new l.LongBits(e.dims[i].low>>>0,e.dims[i].high>>>0).toNumber())}if(e.dataType!=null&&(u.dataType=e.dataType|0),e.segment!=null){if(typeof e.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");u.segment=c.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");u.floatData=[];for(var i=0;i<e.floatData.length;++i)u.floatData[i]=Number(e.floatData[i])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");u.int32Data=[];for(var i=0;i<e.int32Data.length;++i)u.int32Data[i]=e.int32Data[i]|0}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");u.stringData=[];for(var i=0;i<e.stringData.length;++i)typeof e.stringData[i]=="string"?l.base64.decode(e.stringData[i],u.stringData[i]=l.newBuffer(l.base64.length(e.stringData[i])),0):e.stringData[i].length>=0&&(u.stringData[i]=e.stringData[i])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");u.int64Data=[];for(var i=0;i<e.int64Data.length;++i)l.Long?(u.int64Data[i]=l.Long.fromValue(e.int64Data[i])).unsigned=!1:typeof e.int64Data[i]=="string"?u.int64Data[i]=parseInt(e.int64Data[i],10):typeof e.int64Data[i]=="number"?u.int64Data[i]=e.int64Data[i]:typeof e.int64Data[i]=="object"&&(u.int64Data[i]=new l.LongBits(e.int64Data[i].low>>>0,e.int64Data[i].high>>>0).toNumber())}if(e.name!=null&&(u.name=String(e.name)),e.docString!=null&&(u.docString=String(e.docString)),e.rawData!=null&&(typeof e.rawData=="string"?l.base64.decode(e.rawData,u.rawData=l.newBuffer(l.base64.length(e.rawData)),0):e.rawData.length>=0&&(u.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");u.externalData=[];for(var i=0;i<e.externalData.length;++i){if(typeof e.externalData[i]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");u.externalData[i]=c.onnx.StringStringEntryProto.fromObject(e.externalData[i])}}switch(e.dataLocation){default:if(typeof e.dataLocation=="number"){u.dataLocation=e.dataLocation;break}break;case"DEFAULT":case 0:u.dataLocation=0;break;case"EXTERNAL":case 1:u.dataLocation=1;break}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");u.doubleData=[];for(var i=0;i<e.doubleData.length;++i)u.doubleData[i]=Number(e.doubleData[i])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");u.uint64Data=[];for(var i=0;i<e.uint64Data.length;++i)l.Long?(u.uint64Data[i]=l.Long.fromValue(e.uint64Data[i])).unsigned=!0:typeof e.uint64Data[i]=="string"?u.uint64Data[i]=parseInt(e.uint64Data[i],10):typeof e.uint64Data[i]=="number"?u.uint64Data[i]=e.uint64Data[i]:typeof e.uint64Data[i]=="object"&&(u.uint64Data[i]=new l.LongBits(e.uint64Data[i].low>>>0,e.uint64Data[i].high>>>0).toNumber(!0))}return u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.dims=[],i.floatData=[],i.int32Data=[],i.stringData=[],i.int64Data=[],i.doubleData=[],i.uint64Data=[],i.externalData=[]),u.defaults&&(i.dataType=0,i.segment=null,i.name="",u.bytes===String?i.rawData="":(i.rawData=[],u.bytes!==Array&&(i.rawData=l.newBuffer(i.rawData))),i.docString="",i.dataLocation=u.enums===String?"DEFAULT":0),e.dims&&e.dims.length){i.dims=[];for(var d=0;d<e.dims.length;++d)typeof e.dims[d]=="number"?i.dims[d]=u.longs===String?String(e.dims[d]):e.dims[d]:i.dims[d]=u.longs===String?l.Long.prototype.toString.call(e.dims[d]):u.longs===Number?new l.LongBits(e.dims[d].low>>>0,e.dims[d].high>>>0).toNumber():e.dims[d]}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&(i.dataType=e.dataType),e.segment!=null&&e.hasOwnProperty("segment")&&(i.segment=c.onnx.TensorProto.Segment.toObject(e.segment,u)),e.floatData&&e.floatData.length){i.floatData=[];for(var d=0;d<e.floatData.length;++d)i.floatData[d]=u.json&&!isFinite(e.floatData[d])?String(e.floatData[d]):e.floatData[d]}if(e.int32Data&&e.int32Data.length){i.int32Data=[];for(var d=0;d<e.int32Data.length;++d)i.int32Data[d]=e.int32Data[d]}if(e.stringData&&e.stringData.length){i.stringData=[];for(var d=0;d<e.stringData.length;++d)i.stringData[d]=u.bytes===String?l.base64.encode(e.stringData[d],0,e.stringData[d].length):u.bytes===Array?Array.prototype.slice.call(e.stringData[d]):e.stringData[d]}if(e.int64Data&&e.int64Data.length){i.int64Data=[];for(var d=0;d<e.int64Data.length;++d)typeof e.int64Data[d]=="number"?i.int64Data[d]=u.longs===String?String(e.int64Data[d]):e.int64Data[d]:i.int64Data[d]=u.longs===String?l.Long.prototype.toString.call(e.int64Data[d]):u.longs===Number?new l.LongBits(e.int64Data[d].low>>>0,e.int64Data[d].high>>>0).toNumber():e.int64Data[d]}if(e.name!=null&&e.hasOwnProperty("name")&&(i.name=e.name),e.rawData!=null&&e.hasOwnProperty("rawData")&&(i.rawData=u.bytes===String?l.base64.encode(e.rawData,0,e.rawData.length):u.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length){i.doubleData=[];for(var d=0;d<e.doubleData.length;++d)i.doubleData[d]=u.json&&!isFinite(e.doubleData[d])?String(e.doubleData[d]):e.doubleData[d]}if(e.uint64Data&&e.uint64Data.length){i.uint64Data=[];for(var d=0;d<e.uint64Data.length;++d)typeof e.uint64Data[d]=="number"?i.uint64Data[d]=u.longs===String?String(e.uint64Data[d]):e.uint64Data[d]:i.uint64Data[d]=u.longs===String?l.Long.prototype.toString.call(e.uint64Data[d]):u.longs===Number?new l.LongBits(e.uint64Data[d].low>>>0,e.uint64Data[d].high>>>0).toNumber(!0):e.uint64Data[d]}if(e.docString!=null&&e.hasOwnProperty("docString")&&(i.docString=e.docString),e.externalData&&e.externalData.length){i.externalData=[];for(var d=0;d<e.externalData.length;++d)i.externalData[d]=c.onnx.StringStringEntryProto.toObject(e.externalData[d],u)}return e.dataLocation!=null&&e.hasOwnProperty("dataLocation")&&(i.dataLocation=u.enums===String?c.onnx.TensorProto.DataLocation[e.dataLocation]===void 0?e.dataLocation:c.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorProto"},a.DataType=function(){var e={},u=Object.create(e);return u[e[0]="UNDEFINED"]=0,u[e[1]="FLOAT"]=1,u[e[2]="UINT8"]=2,u[e[3]="INT8"]=3,u[e[4]="UINT16"]=4,u[e[5]="INT16"]=5,u[e[6]="INT32"]=6,u[e[7]="INT64"]=7,u[e[8]="STRING"]=8,u[e[9]="BOOL"]=9,u[e[10]="FLOAT16"]=10,u[e[11]="DOUBLE"]=11,u[e[12]="UINT32"]=12,u[e[13]="UINT64"]=13,u[e[14]="COMPLEX64"]=14,u[e[15]="COMPLEX128"]=15,u[e[16]="BFLOAT16"]=16,u[e[17]="FLOAT8E4M3FN"]=17,u[e[18]="FLOAT8E4M3FNUZ"]=18,u[e[19]="FLOAT8E5M2"]=19,u[e[20]="FLOAT8E5M2FNUZ"]=20,u}(),a.Segment=function(){function e(u){if(u)for(var i=Object.keys(u),d=0;d<i.length;++d)u[i[d]]!=null&&(this[i[d]]=u[i[d]])}return e.prototype.begin=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.end=l.Long?l.Long.fromBits(0,0,!1):0,e.create=function(u){return new e(u)},e.encode=function(u,i){return i||(i=p.create()),u.begin!=null&&Object.hasOwnProperty.call(u,"begin")&&i.uint32(8).int64(u.begin),u.end!=null&&Object.hasOwnProperty.call(u,"end")&&i.uint32(16).int64(u.end),i},e.encodeDelimited=function(u,i){return this.encode(u,i).ldelim()},e.decode=function(u,i){u instanceof s||(u=s.create(u));for(var d=i===void 0?u.len:u.pos+i,h=new c.onnx.TensorProto.Segment;u.pos<d;){var m=u.uint32();switch(m>>>3){case 1:{h.begin=u.int64();break}case 2:{h.end=u.int64();break}default:u.skipType(m&7);break}}return h},e.decodeDelimited=function(u){return u instanceof s||(u=new s(u)),this.decode(u,u.uint32())},e.verify=function(u){return typeof u!="object"||u===null?"object expected":u.begin!=null&&u.hasOwnProperty("begin")&&!l.isInteger(u.begin)&&!(u.begin&&l.isInteger(u.begin.low)&&l.isInteger(u.begin.high))?"begin: integer|Long expected":u.end!=null&&u.hasOwnProperty("end")&&!l.isInteger(u.end)&&!(u.end&&l.isInteger(u.end.low)&&l.isInteger(u.end.high))?"end: integer|Long expected":null},e.fromObject=function(u){if(u instanceof c.onnx.TensorProto.Segment)return u;var i=new c.onnx.TensorProto.Segment;return u.begin!=null&&(l.Long?(i.begin=l.Long.fromValue(u.begin)).unsigned=!1:typeof u.begin=="string"?i.begin=parseInt(u.begin,10):typeof u.begin=="number"?i.begin=u.begin:typeof u.begin=="object"&&(i.begin=new l.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber())),u.end!=null&&(l.Long?(i.end=l.Long.fromValue(u.end)).unsigned=!1:typeof u.end=="string"?i.end=parseInt(u.end,10):typeof u.end=="number"?i.end=u.end:typeof u.end=="object"&&(i.end=new l.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber())),i},e.toObject=function(u,i){i||(i={});var d={};if(i.defaults){if(l.Long){var h=new l.Long(0,0,!1);d.begin=i.longs===String?h.toString():i.longs===Number?h.toNumber():h}else d.begin=i.longs===String?"0":0;if(l.Long){var h=new l.Long(0,0,!1);d.end=i.longs===String?h.toString():i.longs===Number?h.toNumber():h}else d.end=i.longs===String?"0":0}return u.begin!=null&&u.hasOwnProperty("begin")&&(typeof u.begin=="number"?d.begin=i.longs===String?String(u.begin):u.begin:d.begin=i.longs===String?l.Long.prototype.toString.call(u.begin):i.longs===Number?new l.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber():u.begin),u.end!=null&&u.hasOwnProperty("end")&&(typeof u.end=="number"?d.end=i.longs===String?String(u.end):u.end:d.end=i.longs===String?l.Long.prototype.toString.call(u.end):i.longs===Number?new l.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber():u.end),d},e.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},e.getTypeUrl=function(u){return u===void 0&&(u="type.googleapis.com"),u+"/onnx.TensorProto.Segment"},e}(),a.DataLocation=function(){var e={},u=Object.create(e);return u[e[0]="DEFAULT"]=0,u[e[1]="EXTERNAL"]=1,u}(),a}(),n.SparseTensorProto=function(){function a(e){if(this.dims=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.values=null,a.prototype.indices=null,a.prototype.dims=l.emptyArray,a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.values!=null&&Object.hasOwnProperty.call(e,"values")&&c.onnx.TensorProto.encode(e.values,u.uint32(10).fork()).ldelim(),e.indices!=null&&Object.hasOwnProperty.call(e,"indices")&&c.onnx.TensorProto.encode(e.indices,u.uint32(18).fork()).ldelim(),e.dims!=null&&e.dims.length){u.uint32(26).fork();for(var i=0;i<e.dims.length;++i)u.int64(e.dims[i]);u.ldelim()}return u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.SparseTensorProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.values=c.onnx.TensorProto.decode(e,e.uint32());break}case 2:{d.indices=c.onnx.TensorProto.decode(e,e.uint32());break}case 3:{if(d.dims&&d.dims.length||(d.dims=[]),(h&7)===2)for(var m=e.uint32()+e.pos;e.pos<m;)d.dims.push(e.int64());else d.dims.push(e.int64());break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.values!=null&&e.hasOwnProperty("values")){var u=c.onnx.TensorProto.verify(e.values);if(u)return"values."+u}if(e.indices!=null&&e.hasOwnProperty("indices")){var u=c.onnx.TensorProto.verify(e.indices);if(u)return"indices."+u}if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var i=0;i<e.dims.length;++i)if(!l.isInteger(e.dims[i])&&!(e.dims[i]&&l.isInteger(e.dims[i].low)&&l.isInteger(e.dims[i].high)))return"dims: integer|Long[] expected"}return null},a.fromObject=function(e){if(e instanceof c.onnx.SparseTensorProto)return e;var u=new c.onnx.SparseTensorProto;if(e.values!=null){if(typeof e.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");u.values=c.onnx.TensorProto.fromObject(e.values)}if(e.indices!=null){if(typeof e.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");u.indices=c.onnx.TensorProto.fromObject(e.indices)}if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");u.dims=[];for(var i=0;i<e.dims.length;++i)l.Long?(u.dims[i]=l.Long.fromValue(e.dims[i])).unsigned=!1:typeof e.dims[i]=="string"?u.dims[i]=parseInt(e.dims[i],10):typeof e.dims[i]=="number"?u.dims[i]=e.dims[i]:typeof e.dims[i]=="object"&&(u.dims[i]=new l.LongBits(e.dims[i].low>>>0,e.dims[i].high>>>0).toNumber())}return u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.dims=[]),u.defaults&&(i.values=null,i.indices=null),e.values!=null&&e.hasOwnProperty("values")&&(i.values=c.onnx.TensorProto.toObject(e.values,u)),e.indices!=null&&e.hasOwnProperty("indices")&&(i.indices=c.onnx.TensorProto.toObject(e.indices,u)),e.dims&&e.dims.length){i.dims=[];for(var d=0;d<e.dims.length;++d)typeof e.dims[d]=="number"?i.dims[d]=u.longs===String?String(e.dims[d]):e.dims[d]:i.dims[d]=u.longs===String?l.Long.prototype.toString.call(e.dims[d]):u.longs===Number?new l.LongBits(e.dims[d].low>>>0,e.dims[d].high>>>0).toNumber():e.dims[d]}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.SparseTensorProto"},a}(),n.TensorShapeProto=function(){function a(e){if(this.dim=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.dim=l.emptyArray,a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.dim!=null&&e.dim.length)for(var i=0;i<e.dim.length;++i)c.onnx.TensorShapeProto.Dimension.encode(e.dim[i],u.uint32(10).fork()).ldelim();return u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.TensorShapeProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.dim&&d.dim.length||(d.dim=[]),d.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()));break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dim!=null&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var u=0;u<e.dim.length;++u){var i=c.onnx.TensorShapeProto.Dimension.verify(e.dim[u]);if(i)return"dim."+i}}return null},a.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto)return e;var u=new c.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");u.dim=[];for(var i=0;i<e.dim.length;++i){if(typeof e.dim[i]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");u.dim[i]=c.onnx.TensorShapeProto.Dimension.fromObject(e.dim[i])}}return u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.dim=[]),e.dim&&e.dim.length){i.dim=[];for(var d=0;d<e.dim.length;++d)i.dim[d]=c.onnx.TensorShapeProto.Dimension.toObject(e.dim[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorShapeProto"},a.Dimension=function(){function e(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}e.prototype.dimValue=null,e.prototype.dimParam=null,e.prototype.denotation="";var u;return Object.defineProperty(e.prototype,"value",{get:l.oneOfGetter(u=["dimValue","dimParam"]),set:l.oneOfSetter(u)}),e.create=function(i){return new e(i)},e.encode=function(i,d){return d||(d=p.create()),i.dimValue!=null&&Object.hasOwnProperty.call(i,"dimValue")&&d.uint32(8).int64(i.dimValue),i.dimParam!=null&&Object.hasOwnProperty.call(i,"dimParam")&&d.uint32(18).string(i.dimParam),i.denotation!=null&&Object.hasOwnProperty.call(i,"denotation")&&d.uint32(26).string(i.denotation),d},e.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},e.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TensorShapeProto.Dimension;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.dimValue=i.int64();break}case 2:{m.dimParam=i.string();break}case 3:{m.denotation=i.string();break}default:i.skipType(b&7);break}}return m},e.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},e.verify=function(i){if(typeof i!="object"||i===null)return"object expected";var d={};if(i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(d.value=1,!l.isInteger(i.dimValue)&&!(i.dimValue&&l.isInteger(i.dimValue.low)&&l.isInteger(i.dimValue.high))))return"dimValue: integer|Long expected";if(i.dimParam!=null&&i.hasOwnProperty("dimParam")){if(d.value===1)return"value: multiple values";if(d.value=1,!l.isString(i.dimParam))return"dimParam: string expected"}return i.denotation!=null&&i.hasOwnProperty("denotation")&&!l.isString(i.denotation)?"denotation: string expected":null},e.fromObject=function(i){if(i instanceof c.onnx.TensorShapeProto.Dimension)return i;var d=new c.onnx.TensorShapeProto.Dimension;return i.dimValue!=null&&(l.Long?(d.dimValue=l.Long.fromValue(i.dimValue)).unsigned=!1:typeof i.dimValue=="string"?d.dimValue=parseInt(i.dimValue,10):typeof i.dimValue=="number"?d.dimValue=i.dimValue:typeof i.dimValue=="object"&&(d.dimValue=new l.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber())),i.dimParam!=null&&(d.dimParam=String(i.dimParam)),i.denotation!=null&&(d.denotation=String(i.denotation)),d},e.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.denotation=""),i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(typeof i.dimValue=="number"?h.dimValue=d.longs===String?String(i.dimValue):i.dimValue:h.dimValue=d.longs===String?l.Long.prototype.toString.call(i.dimValue):d.longs===Number?new l.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber():i.dimValue,d.oneofs&&(h.value="dimValue")),i.dimParam!=null&&i.hasOwnProperty("dimParam")&&(h.dimParam=i.dimParam,d.oneofs&&(h.value="dimParam")),i.denotation!=null&&i.hasOwnProperty("denotation")&&(h.denotation=i.denotation),h},e.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},e.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TensorShapeProto.Dimension"},e}(),a}(),n.TypeProto=function(){function a(u){if(u)for(var i=Object.keys(u),d=0;d<i.length;++d)u[i[d]]!=null&&(this[i[d]]=u[i[d]])}a.prototype.tensorType=null,a.prototype.sequenceType=null,a.prototype.mapType=null,a.prototype.optionalType=null,a.prototype.sparseTensorType=null,a.prototype.denotation="";var e;return Object.defineProperty(a.prototype,"value",{get:l.oneOfGetter(e=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:l.oneOfSetter(e)}),a.create=function(u){return new a(u)},a.encode=function(u,i){return i||(i=p.create()),u.tensorType!=null&&Object.hasOwnProperty.call(u,"tensorType")&&c.onnx.TypeProto.Tensor.encode(u.tensorType,i.uint32(10).fork()).ldelim(),u.sequenceType!=null&&Object.hasOwnProperty.call(u,"sequenceType")&&c.onnx.TypeProto.Sequence.encode(u.sequenceType,i.uint32(34).fork()).ldelim(),u.mapType!=null&&Object.hasOwnProperty.call(u,"mapType")&&c.onnx.TypeProto.Map.encode(u.mapType,i.uint32(42).fork()).ldelim(),u.denotation!=null&&Object.hasOwnProperty.call(u,"denotation")&&i.uint32(50).string(u.denotation),u.sparseTensorType!=null&&Object.hasOwnProperty.call(u,"sparseTensorType")&&c.onnx.TypeProto.SparseTensor.encode(u.sparseTensorType,i.uint32(66).fork()).ldelim(),u.optionalType!=null&&Object.hasOwnProperty.call(u,"optionalType")&&c.onnx.TypeProto.Optional.encode(u.optionalType,i.uint32(74).fork()).ldelim(),i},a.encodeDelimited=function(u,i){return this.encode(u,i).ldelim()},a.decode=function(u,i){u instanceof s||(u=s.create(u));for(var d=i===void 0?u.len:u.pos+i,h=new c.onnx.TypeProto;u.pos<d;){var m=u.uint32();switch(m>>>3){case 1:{h.tensorType=c.onnx.TypeProto.Tensor.decode(u,u.uint32());break}case 4:{h.sequenceType=c.onnx.TypeProto.Sequence.decode(u,u.uint32());break}case 5:{h.mapType=c.onnx.TypeProto.Map.decode(u,u.uint32());break}case 9:{h.optionalType=c.onnx.TypeProto.Optional.decode(u,u.uint32());break}case 8:{h.sparseTensorType=c.onnx.TypeProto.SparseTensor.decode(u,u.uint32());break}case 6:{h.denotation=u.string();break}default:u.skipType(m&7);break}}return h},a.decodeDelimited=function(u){return u instanceof s||(u=new s(u)),this.decode(u,u.uint32())},a.verify=function(u){if(typeof u!="object"||u===null)return"object expected";var i={};if(u.tensorType!=null&&u.hasOwnProperty("tensorType")){i.value=1;{var d=c.onnx.TypeProto.Tensor.verify(u.tensorType);if(d)return"tensorType."+d}}if(u.sequenceType!=null&&u.hasOwnProperty("sequenceType")){if(i.value===1)return"value: multiple values";i.value=1;{var d=c.onnx.TypeProto.Sequence.verify(u.sequenceType);if(d)return"sequenceType."+d}}if(u.mapType!=null&&u.hasOwnProperty("mapType")){if(i.value===1)return"value: multiple values";i.value=1;{var d=c.onnx.TypeProto.Map.verify(u.mapType);if(d)return"mapType."+d}}if(u.optionalType!=null&&u.hasOwnProperty("optionalType")){if(i.value===1)return"value: multiple values";i.value=1;{var d=c.onnx.TypeProto.Optional.verify(u.optionalType);if(d)return"optionalType."+d}}if(u.sparseTensorType!=null&&u.hasOwnProperty("sparseTensorType")){if(i.value===1)return"value: multiple values";i.value=1;{var d=c.onnx.TypeProto.SparseTensor.verify(u.sparseTensorType);if(d)return"sparseTensorType."+d}}return u.denotation!=null&&u.hasOwnProperty("denotation")&&!l.isString(u.denotation)?"denotation: string expected":null},a.fromObject=function(u){if(u instanceof c.onnx.TypeProto)return u;var i=new c.onnx.TypeProto;if(u.tensorType!=null){if(typeof u.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");i.tensorType=c.onnx.TypeProto.Tensor.fromObject(u.tensorType)}if(u.sequenceType!=null){if(typeof u.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");i.sequenceType=c.onnx.TypeProto.Sequence.fromObject(u.sequenceType)}if(u.mapType!=null){if(typeof u.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");i.mapType=c.onnx.TypeProto.Map.fromObject(u.mapType)}if(u.optionalType!=null){if(typeof u.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");i.optionalType=c.onnx.TypeProto.Optional.fromObject(u.optionalType)}if(u.sparseTensorType!=null){if(typeof u.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");i.sparseTensorType=c.onnx.TypeProto.SparseTensor.fromObject(u.sparseTensorType)}return u.denotation!=null&&(i.denotation=String(u.denotation)),i},a.toObject=function(u,i){i||(i={});var d={};return i.defaults&&(d.denotation=""),u.tensorType!=null&&u.hasOwnProperty("tensorType")&&(d.tensorType=c.onnx.TypeProto.Tensor.toObject(u.tensorType,i),i.oneofs&&(d.value="tensorType")),u.sequenceType!=null&&u.hasOwnProperty("sequenceType")&&(d.sequenceType=c.onnx.TypeProto.Sequence.toObject(u.sequenceType,i),i.oneofs&&(d.value="sequenceType")),u.mapType!=null&&u.hasOwnProperty("mapType")&&(d.mapType=c.onnx.TypeProto.Map.toObject(u.mapType,i),i.oneofs&&(d.value="mapType")),u.denotation!=null&&u.hasOwnProperty("denotation")&&(d.denotation=u.denotation),u.sparseTensorType!=null&&u.hasOwnProperty("sparseTensorType")&&(d.sparseTensorType=c.onnx.TypeProto.SparseTensor.toObject(u.sparseTensorType,i),i.oneofs&&(d.value="sparseTensorType")),u.optionalType!=null&&u.hasOwnProperty("optionalType")&&(d.optionalType=c.onnx.TypeProto.Optional.toObject(u.optionalType,i),i.oneofs&&(d.value="optionalType")),d},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(u){return u===void 0&&(u="type.googleapis.com"),u+"/onnx.TypeProto"},a.Tensor=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&d.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&c.onnx.TensorShapeProto.encode(i.shape,d.uint32(18).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.Tensor;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.elemType=i.int32();break}case 2:{m.shape=c.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!l.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var d=c.onnx.TensorShapeProto.verify(i.shape);if(d)return"shape."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.Tensor)return i;var d=new c.onnx.TypeProto.Tensor;if(i.elemType!=null&&(d.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");d.shape=c.onnx.TensorShapeProto.fromObject(i.shape)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.elemType=0,h.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(h.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(h.shape=c.onnx.TensorShapeProto.toObject(i.shape,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Tensor"},u}(),a.Sequence=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.elemType=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&c.onnx.TypeProto.encode(i.elemType,d.uint32(10).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.Sequence;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.elemType=c.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var d=c.onnx.TypeProto.verify(i.elemType);if(d)return"elemType."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.Sequence)return i;var d=new c.onnx.TypeProto.Sequence;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");d.elemType=c.onnx.TypeProto.fromObject(i.elemType)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(h.elemType=c.onnx.TypeProto.toObject(i.elemType,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Sequence"},u}(),a.Map=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.keyType=0,u.prototype.valueType=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.keyType!=null&&Object.hasOwnProperty.call(i,"keyType")&&d.uint32(8).int32(i.keyType),i.valueType!=null&&Object.hasOwnProperty.call(i,"valueType")&&c.onnx.TypeProto.encode(i.valueType,d.uint32(18).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.Map;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.keyType=i.int32();break}case 2:{m.valueType=c.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.keyType!=null&&i.hasOwnProperty("keyType")&&!l.isInteger(i.keyType))return"keyType: integer expected";if(i.valueType!=null&&i.hasOwnProperty("valueType")){var d=c.onnx.TypeProto.verify(i.valueType);if(d)return"valueType."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.Map)return i;var d=new c.onnx.TypeProto.Map;if(i.keyType!=null&&(d.keyType=i.keyType|0),i.valueType!=null){if(typeof i.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");d.valueType=c.onnx.TypeProto.fromObject(i.valueType)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.keyType=0,h.valueType=null),i.keyType!=null&&i.hasOwnProperty("keyType")&&(h.keyType=i.keyType),i.valueType!=null&&i.hasOwnProperty("valueType")&&(h.valueType=c.onnx.TypeProto.toObject(i.valueType,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Map"},u}(),a.Optional=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.elemType=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&c.onnx.TypeProto.encode(i.elemType,d.uint32(10).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.Optional;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.elemType=c.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var d=c.onnx.TypeProto.verify(i.elemType);if(d)return"elemType."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.Optional)return i;var d=new c.onnx.TypeProto.Optional;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");d.elemType=c.onnx.TypeProto.fromObject(i.elemType)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(h.elemType=c.onnx.TypeProto.toObject(i.elemType,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Optional"},u}(),a.SparseTensor=function(){function u(i){if(i)for(var d=Object.keys(i),h=0;h<d.length;++h)i[d[h]]!=null&&(this[d[h]]=i[d[h]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(i){return new u(i)},u.encode=function(i,d){return d||(d=p.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&d.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&c.onnx.TensorShapeProto.encode(i.shape,d.uint32(18).fork()).ldelim(),d},u.encodeDelimited=function(i,d){return this.encode(i,d).ldelim()},u.decode=function(i,d){i instanceof s||(i=s.create(i));for(var h=d===void 0?i.len:i.pos+d,m=new c.onnx.TypeProto.SparseTensor;i.pos<h;){var b=i.uint32();switch(b>>>3){case 1:{m.elemType=i.int32();break}case 2:{m.shape=c.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(b&7);break}}return m},u.decodeDelimited=function(i){return i instanceof s||(i=new s(i)),this.decode(i,i.uint32())},u.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!l.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var d=c.onnx.TensorShapeProto.verify(i.shape);if(d)return"shape."+d}return null},u.fromObject=function(i){if(i instanceof c.onnx.TypeProto.SparseTensor)return i;var d=new c.onnx.TypeProto.SparseTensor;if(i.elemType!=null&&(d.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");d.shape=c.onnx.TensorShapeProto.fromObject(i.shape)}return d},u.toObject=function(i,d){d||(d={});var h={};return d.defaults&&(h.elemType=0,h.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(h.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(h.shape=c.onnx.TensorShapeProto.toObject(i.shape,d)),h},u.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},u.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.SparseTensor"},u}(),a}(),n.OperatorSetIdProto=function(){function a(e){if(e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.domain="",a.prototype.version=l.Long?l.Long.fromBits(0,0,!1):0,a.create=function(e){return new a(e)},a.encode=function(e,u){return u||(u=p.create()),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&u.uint32(10).string(e.domain),e.version!=null&&Object.hasOwnProperty.call(e,"version")&&u.uint32(16).int64(e.version),u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.OperatorSetIdProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.domain=e.string();break}case 2:{d.version=e.int64();break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){return typeof e!="object"||e===null?"object expected":e.domain!=null&&e.hasOwnProperty("domain")&&!l.isString(e.domain)?"domain: string expected":e.version!=null&&e.hasOwnProperty("version")&&!l.isInteger(e.version)&&!(e.version&&l.isInteger(e.version.low)&&l.isInteger(e.version.high))?"version: integer|Long expected":null},a.fromObject=function(e){if(e instanceof c.onnx.OperatorSetIdProto)return e;var u=new c.onnx.OperatorSetIdProto;return e.domain!=null&&(u.domain=String(e.domain)),e.version!=null&&(l.Long?(u.version=l.Long.fromValue(e.version)).unsigned=!1:typeof e.version=="string"?u.version=parseInt(e.version,10):typeof e.version=="number"?u.version=e.version:typeof e.version=="object"&&(u.version=new l.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),u},a.toObject=function(e,u){u||(u={});var i={};if(u.defaults)if(i.domain="",l.Long){var d=new l.Long(0,0,!1);i.version=u.longs===String?d.toString():u.longs===Number?d.toNumber():d}else i.version=u.longs===String?"0":0;return e.domain!=null&&e.hasOwnProperty("domain")&&(i.domain=e.domain),e.version!=null&&e.hasOwnProperty("version")&&(typeof e.version=="number"?i.version=u.longs===String?String(e.version):e.version:i.version=u.longs===String?l.Long.prototype.toString.call(e.version):u.longs===Number?new l.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.OperatorSetIdProto"},a}(),n.OperatorStatus=function(){var a={},e=Object.create(a);return e[a[0]="EXPERIMENTAL"]=0,e[a[1]="STABLE"]=1,e}(),n.FunctionProto=function(){function a(e){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],e)for(var u=Object.keys(e),i=0;i<u.length;++i)e[u[i]]!=null&&(this[u[i]]=e[u[i]])}return a.prototype.name="",a.prototype.input=l.emptyArray,a.prototype.output=l.emptyArray,a.prototype.attribute=l.emptyArray,a.prototype.attributeProto=l.emptyArray,a.prototype.node=l.emptyArray,a.prototype.docString="",a.prototype.opsetImport=l.emptyArray,a.prototype.domain="",a.create=function(e){return new a(e)},a.encode=function(e,u){if(u||(u=p.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&u.uint32(10).string(e.name),e.input!=null&&e.input.length)for(var i=0;i<e.input.length;++i)u.uint32(34).string(e.input[i]);if(e.output!=null&&e.output.length)for(var i=0;i<e.output.length;++i)u.uint32(42).string(e.output[i]);if(e.attribute!=null&&e.attribute.length)for(var i=0;i<e.attribute.length;++i)u.uint32(50).string(e.attribute[i]);if(e.node!=null&&e.node.length)for(var i=0;i<e.node.length;++i)c.onnx.NodeProto.encode(e.node[i],u.uint32(58).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&u.uint32(66).string(e.docString),e.opsetImport!=null&&e.opsetImport.length)for(var i=0;i<e.opsetImport.length;++i)c.onnx.OperatorSetIdProto.encode(e.opsetImport[i],u.uint32(74).fork()).ldelim();if(e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&u.uint32(82).string(e.domain),e.attributeProto!=null&&e.attributeProto.length)for(var i=0;i<e.attributeProto.length;++i)c.onnx.AttributeProto.encode(e.attributeProto[i],u.uint32(90).fork()).ldelim();return u},a.encodeDelimited=function(e,u){return this.encode(e,u).ldelim()},a.decode=function(e,u){e instanceof s||(e=s.create(e));for(var i=u===void 0?e.len:e.pos+u,d=new c.onnx.FunctionProto;e.pos<i;){var h=e.uint32();switch(h>>>3){case 1:{d.name=e.string();break}case 4:{d.input&&d.input.length||(d.input=[]),d.input.push(e.string());break}case 5:{d.output&&d.output.length||(d.output=[]),d.output.push(e.string());break}case 6:{d.attribute&&d.attribute.length||(d.attribute=[]),d.attribute.push(e.string());break}case 11:{d.attributeProto&&d.attributeProto.length||(d.attributeProto=[]),d.attributeProto.push(c.onnx.AttributeProto.decode(e,e.uint32()));break}case 7:{d.node&&d.node.length||(d.node=[]),d.node.push(c.onnx.NodeProto.decode(e,e.uint32()));break}case 8:{d.docString=e.string();break}case 9:{d.opsetImport&&d.opsetImport.length||(d.opsetImport=[]),d.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e,e.uint32()));break}case 10:{d.domain=e.string();break}default:e.skipType(h&7);break}}return d},a.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},a.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var u=0;u<e.input.length;++u)if(!l.isString(e.input[u]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(var u=0;u<e.output.length;++u)if(!l.isString(e.output[u]))return"output: string[] expected"}if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(var u=0;u<e.attribute.length;++u)if(!l.isString(e.attribute[u]))return"attribute: string[] expected"}if(e.attributeProto!=null&&e.hasOwnProperty("attributeProto")){if(!Array.isArray(e.attributeProto))return"attributeProto: array expected";for(var u=0;u<e.attributeProto.length;++u){var i=c.onnx.AttributeProto.verify(e.attributeProto[u]);if(i)return"attributeProto."+i}}if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var u=0;u<e.node.length;++u){var i=c.onnx.NodeProto.verify(e.node[u]);if(i)return"node."+i}}if(e.docString!=null&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var u=0;u<e.opsetImport.length;++u){var i=c.onnx.OperatorSetIdProto.verify(e.opsetImport[u]);if(i)return"opsetImport."+i}}return e.domain!=null&&e.hasOwnProperty("domain")&&!l.isString(e.domain)?"domain: string expected":null},a.fromObject=function(e){if(e instanceof c.onnx.FunctionProto)return e;var u=new c.onnx.FunctionProto;if(e.name!=null&&(u.name=String(e.name)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.FunctionProto.input: array expected");u.input=[];for(var i=0;i<e.input.length;++i)u.input[i]=String(e.input[i])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.FunctionProto.output: array expected");u.output=[];for(var i=0;i<e.output.length;++i)u.output[i]=String(e.output[i])}if(e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");u.attribute=[];for(var i=0;i<e.attribute.length;++i)u.attribute[i]=String(e.attribute[i])}if(e.attributeProto){if(!Array.isArray(e.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");u.attributeProto=[];for(var i=0;i<e.attributeProto.length;++i){if(typeof e.attributeProto[i]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");u.attributeProto[i]=c.onnx.AttributeProto.fromObject(e.attributeProto[i])}}if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.FunctionProto.node: array expected");u.node=[];for(var i=0;i<e.node.length;++i){if(typeof e.node[i]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");u.node[i]=c.onnx.NodeProto.fromObject(e.node[i])}}if(e.docString!=null&&(u.docString=String(e.docString)),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");u.opsetImport=[];for(var i=0;i<e.opsetImport.length;++i){if(typeof e.opsetImport[i]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");u.opsetImport[i]=c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[i])}}return e.domain!=null&&(u.domain=String(e.domain)),u},a.toObject=function(e,u){u||(u={});var i={};if((u.arrays||u.defaults)&&(i.input=[],i.output=[],i.attribute=[],i.node=[],i.opsetImport=[],i.attributeProto=[]),u.defaults&&(i.name="",i.docString="",i.domain=""),e.name!=null&&e.hasOwnProperty("name")&&(i.name=e.name),e.input&&e.input.length){i.input=[];for(var d=0;d<e.input.length;++d)i.input[d]=e.input[d]}if(e.output&&e.output.length){i.output=[];for(var d=0;d<e.output.length;++d)i.output[d]=e.output[d]}if(e.attribute&&e.attribute.length){i.attribute=[];for(var d=0;d<e.attribute.length;++d)i.attribute[d]=e.attribute[d]}if(e.node&&e.node.length){i.node=[];for(var d=0;d<e.node.length;++d)i.node[d]=c.onnx.NodeProto.toObject(e.node[d],u)}if(e.docString!=null&&e.hasOwnProperty("docString")&&(i.docString=e.docString),e.opsetImport&&e.opsetImport.length){i.opsetImport=[];for(var d=0;d<e.opsetImport.length;++d)i.opsetImport[d]=c.onnx.OperatorSetIdProto.toObject(e.opsetImport[d],u)}if(e.domain!=null&&e.hasOwnProperty("domain")&&(i.domain=e.domain),e.attributeProto&&e.attributeProto.length){i.attributeProto=[];for(var d=0;d<e.attributeProto.length;++d)i.attributeProto[d]=c.onnx.AttributeProto.toObject(e.attributeProto[d],u)}return i},a.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},a.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.FunctionProto"},a}(),n}(),r.exports=c});function Gr(t,r){if(!t)throw new Error(typeof r=="string"?r:r())}function mo(t){return new TextDecoder().decode(t)}var q,Qe,_a,Mt,xl,Et,Vt,C,bo,Hr,dr,hr,U=I(()=>{"use strict";Ko(),yl(),q=Ie(mr()),De(),Qe=class{static arraysEqual(t,r){if(t.length!==r.length)return!1;for(let o=0;o<t.length;o++)if(t[o]!==r[o])return!1;return!0}},_a=class{static preprocessInputShapes(t,r){let o=t.length===1?[1,t[0]]:t,s=r.length===1?[r[0],1]:r;return[o,s]}static postprocessOutputShape(t,r,o){r===1&&t.splice(t.length-2,1),o===1&&t.pop()}static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},Mt=class tr{static calcShape(r,o,s=!1){let p=r.length,l=o.length;if(p===0)return o;if(l===0)return r;let c=Math.max(r.length,o.length),n=new Array(c);if(s){if(p<2||l<2)return;let a=_a.calcMatMulShape([r[p-2],r[p-1]],[o[l-2],o[l-1]]);if(a===void 0)return;[n[c-2],n[c-1]]=a}for(let a=s?3:1;a<=c;a++){let e=p-a<0?1:r[p-a],u=l-a<0?1:o[l-a];if(e!==u&&e>1&&u>1)return;n[c-a]=Math.max(e,u)}return n}static index(r,o){let s=new Array(o.length);return tr.fillIndex(r,o,s),s}static fillIndex(r,o,s){let p=r.length-o.length;for(let l=0;l<o.length;l++)s[l]=r[p+l]%o[l]}static calc(r,o,s,p,l){let c=tr.calcShape(r.dims,o.dims);if(c){if(p&&!C.areEqual(c,r.dims))return;let n=C.size(c),a=p?r:new Pt(c,l||r.type);if(c.length===0)a.set([],s(r.get([]),o.get([])));else{let e=new Array(c.length),u=new Array(r.dims.length),i=new Array(o.dims.length),d=0,h=0,m=!1,b=!1;r.dims.length===0&&(d=r.get([]),m=!0),o.dims.length===0&&(h=o.get([]),b=!0);let x;for(let E=0;E<n;E++){x=E;for(let w=c.length-1;w>=0;w--)e[w]=x%c[w],x=Math.floor(x/c[w]);m||(tr.fillIndex(e,r.dims,u),d=r.get(u)),b||(tr.fillIndex(e,o.dims,i),h=o.get(i)),a.set(e,s(d,h))}}return a}}static isValidBroadcast(r,o){let s=r.length,p=o.length;if(s>p)return!1;for(let l=1;l<=s;l++)if(r[s-l]!==1&&r[s-l]!==o[p-l])return!1;return!0}static getBroadcastDims(r,o){let s=r.length,p=[];for(let l=0;l<s;l++){let c=s-1-l,n=r[c]||1;(o[o.length-1-l]||1)>1&&n===1&&p.unshift(c)}return p}},xl=class{static getShapeOfGemmResult(t,r,o,s,p){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let l,c,n;r?(l=t[1],c=t[0]):(l=t[0],c=t[1]);let a=-1;if(s?(n=o[0],a=1):(n=o[1],a=0),o[a]!==c)throw new Error("dimension mismatch");if(l<=0||n<=0||c<=0)throw new Error("invalid shape specified");if(p&&!Mt.isValidBroadcast(p,[l,n]))throw new Error("gemm: invalid bias shape for broadcast");return[l,n,c]}},Et=class yo{static tensorDataTypeFromProto(r){switch(r){case q.onnx.TensorProto.DataType.INT8:return"int8";case q.onnx.TensorProto.DataType.UINT8:return"uint8";case q.onnx.TensorProto.DataType.BOOL:return"bool";case q.onnx.TensorProto.DataType.INT16:return"int16";case q.onnx.TensorProto.DataType.UINT16:return"uint16";case q.onnx.TensorProto.DataType.INT32:return"int32";case q.onnx.TensorProto.DataType.UINT32:return"uint32";case q.onnx.TensorProto.DataType.FLOAT:return"float32";case q.onnx.TensorProto.DataType.DOUBLE:return"float64";case q.onnx.TensorProto.DataType.STRING:return"string";case q.onnx.TensorProto.DataType.INT64:return"int32";case q.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${q.onnx.TensorProto.DataType[r]}`)}}static tensorDataTypeStringToEnum(r){switch(r){case"int8":return q.onnx.TensorProto.DataType.INT8;case"uint8":return q.onnx.TensorProto.DataType.UINT8;case"bool":return q.onnx.TensorProto.DataType.BOOL;case"int16":return q.onnx.TensorProto.DataType.INT16;case"uint16":return q.onnx.TensorProto.DataType.UINT16;case"int32":return q.onnx.TensorProto.DataType.INT32;case"uint32":return q.onnx.TensorProto.DataType.UINT32;case"float32":return q.onnx.TensorProto.DataType.FLOAT;case"float64":return q.onnx.TensorProto.DataType.DOUBLE;case"string":return q.onnx.TensorProto.DataType.STRING;case"int64":return q.onnx.TensorProto.DataType.INT64;case"uint64":return q.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${r}`)}}static tensorDimsFromProto(r){return r.map(o=>ee.isLong(o)?o.toNumber():o)}static tensorValueTypeFromProto(r){return{tensorType:yo.tensorDataTypeFromProto(r.elemType),shape:{dims:yo.tensorDimsFromProto(r.shape.dim.map(o=>o.dimValue))}}}static tensorDimsFromORTFormat(r){let o=[];for(let s=0;s<r.dimsLength();s++)o.push(Vt.longToNumber(r.dims(s)));return o}static tensorAttributesFromORTFormat(r){let o=[];for(let s=0;s<r.attributesLength();s++)o.push(r.attributes(s));return o}},Vt=class{static longToNumber(t,r){return ee.isLong(t)?t.toNumber():t instanceof T.Long?ee.fromValue({low:t.low,high:t.high,unsigned:r??!1}).toNumber():t}static isLong(t){return ee.isLong(t)||t instanceof T.Long}},C=class Qt{static size(r){return Qt.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,o){if(o<0||o>r.length)throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return Qt.getSizeFromDimensionRange(r,o,r.length)}static sizeToDimension(r,o){if(o<0||o>r.length)throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${r.length} dimensions.`);return Qt.getSizeFromDimensionRange(r,0,o)}static getSizeFromDimensionRange(r,o,s){let p=1;for(let l=o;l<s;l++){if(r[l]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");p*=r[l]}return p}static computeStrides(r){let o=r.length;if(o===0)return[];if(o===1)return[1];let s=new Array(o);s[o-1]=1,s[o-2]=r[o-1];for(let p=o-3;p>=0;--p)s[p]=s[p+1]*r[p+1];return s}static transpose(r){return r.slice().reverse()}static indicesToOffset(r,o,s){s===void 0&&(s=r.length);let p=0;for(let l=0;l<s;++l)p+=o[l]*r[l];return p}static offsetToIndices(r,o){let s=o.length;if(s===0)return[];if(s===1)return[r*o[0]];let p=new Array(o.length);for(let l=0;l<p.length-1;++l)p[l]=Math.floor(r/o[l]),r-=p[l]*o[l];return p[p.length-1]=r,p}static normalizeAxis(r,o){if(r<-o&&r>=o)throw new Error("unsupported axis for this operation.");return r<0?r+o:r}static normalizeAxes(r,o){return r.map(s=>this.normalizeAxis(s,o))}static incrementIndex(r,o,s){if(o.length===0||r.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(s===void 0)s=o.length;else if(s<=0||s>o.length)throw new Error("Incorrect axis to increment on");for(let p=s-1;p>=0&&(r[p]++,!(r[p]<o[p]));--p)r[p]=0}static calculateReshapedDims(r,o){if(o.length===0){if(r.length===0||Qt.size(r)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let s=o.length,p=new Array(s),l=-1,c=1;for(let a=0;a<s;a++){if(o[a]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(o[a]===-1){if(l!==-1)throw new Error("at most one dimension in shape hints can be -1");l=a}else{if(o[a]===0){if(a>=r.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");p[a]=r[a]}else p[a]=o[a];c*=p[a]}}let n=Qt.size(r);if(l!==-1){if(n%c!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${r}] Output shape: [${o}]`);p[l]=n/c}else if(c!==n)throw new Error("reshapedDims and originalDims don't have matching sizes");return p}static sortBasedOnPerm(r,o){return o?o.map(s=>r[s]):r.slice().reverse()}static padShape(r,o){let s=r.length;return r.map((p,l)=>p+o[l]+o[l+s])}static areEqual(r,o){return r.length!==o.length?!1:r.every((s,p)=>s===o[p])}static validateDimsAndCalcSize(r){if(r.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let o=1;for(let s of r){if(!Number.isInteger(s))throw new TypeError(`Invalid shape: ${s} is not an integer`);if(s<0||s>2147483647)throw new TypeError(`Invalid shape: length ${s} is not allowed`);o*=s}return o}static flattenShape(r,o){o<0&&(o+=r.length);let s=r.reduce((l,c)=>l*c,1),p=r.slice(o).reduce((l,c)=>l*c,1);return[s/p,p]}static squeezeShape(r,o){let s=new Array;o=Qt.normalizeAxes(o,r.length);for(let p=0;p<r.length;p++){let l=o.indexOf(p)>=0;if(l&&r[p]!==1)throw new Error("squeeze an axis of size different than 1");(o.length===0&&r[p]>1||o.length>0&&!l)&&s.push(r[p])}return s}static unsqueezeShape(r,o){let s=new Array(r.length+o.length);s.fill(0);for(let l=0;l<o.length;l++){let c=Qt.normalizeAxis(o[l],s.length);if(c>=s.length)throw new Error("'axes' has an out of range axis");if(s[c]!==0)throw new Error("'axes' has a duplicate axis");s[c]=1}let p=0;for(let l=0;l<s.length;l++)s[l]===0&&(s[l]=r[p++]);if(p!==r.length)throw new Error("the unsqueezed dimension could not be established");return s}},bo=class Tl{static splitShape(r,o,s,p){if(s.length===0){if(!p)throw new Error("need to know number of outputs when the 'split' attribute is not specified");Tl.determineSplit(r[o],p,s)}let l=[],c=[0];for(let n=0;n<s.length;++n){n!==0&&c.push(c[n-1]+s[n-1]);let a=r.slice();a[o]=s[n],l.push(a)}return[l,c]}static determineSplit(r,o,s){if(r%o!==0)throw new Error("cannot split tensor to equal sized parts");for(let p=0;p<o;++p)s.push(r/o)}},Hr=class er{static adjustPoolAttributes(r,o,s,p,l,c){if(!r&&s.length!==o.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let n=0;n<o.length-2;n++)n>=s.length?s.push(o[n+2]):s[n]=o[n+2];for(let n=0;n<s.length;n++)if(n<p.length){if(p[n]<0)throw new Error("strides should be greater than or equal to 1")}else p.push(1);for(let n=0;n<s.length;n++)if(n<l.length){if(l[n]<0)throw new Error("dilations should be greater than or equal to 1")}else l.push(1);for(let n=0;n<s.length*2;n++)if(n<c.length){if(c[n]<0)throw new Error("pad should be greater than or equal to 1")}else c.push(0);for(let n=0;n<s.length;n++){if(s[n]<=0)throw new Error("kernel shapes need to be greater than 0");if(c[n]>=s[n]||c[n+s.length]>=s[n])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,o,s,p,l,c){if(c){if(l.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(o.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(p.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let n=0;n<r.length-2;n++)er.adjustPadAndReturnShape(r[n+2],o[n],s[n],p[n],l,n,n+r.length-2,c)}}static computePoolOutputShape(r,o,s,p,l,c,n){if(o.length<=0)throw new Error("input shape must be of size greater than 0");let a=[o[0],o[1]];return er.computeShapeHelper(r,o,a,s,p,l,c,n),a}static computeConvOutputShape(r,o,s,p,l,c,n){if(r.length<=0||o.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[r[0],o[0]];return er.computeShapeHelper(!1,r,a,s,p,l,c,n),a}static computeShapeHelper(r,o,s,p,l,c,n,a){if(r)for(let e=0;e<o.length-2;e++)s.push(1);else for(let e=0;e<o.length-2;e++)s.push(er.adjustPadAndReturnShape(o[e+2],p[e],l[e],c[e],n,e,e+o.length-2,a))}static adjustPadAndReturnShape(r,o,s,p,l,c,n,a){let e=s*(p-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return l[c]=0,l[n]=0,Math.floor((r-e)/o+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let u=((r+o-1)/o-1)*o+p-r;return l[c]=Math.floor(a==="SAME_LOWER"?(u+1)/2:u/2),l[n]=u-l[c],Math.floor((r+u-p)/o+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+l[c]+l[n]-e)/o+1)}},dr=-34028234663852886e22,hr=34028234663852886e22});function tf(t){switch(t){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${t}`)}}function Sa(t){switch(t){case L.onnx.TensorProto.DataType.UINT8:case L.onnx.TensorProto.DataType.INT8:case L.onnx.TensorProto.DataType.BOOL:return 1;case L.onnx.TensorProto.DataType.UINT16:case L.onnx.TensorProto.DataType.INT16:return 2;case L.onnx.TensorProto.DataType.FLOAT:case L.onnx.TensorProto.DataType.INT32:case L.onnx.TensorProto.DataType.UINT32:return 4;case L.onnx.TensorProto.DataType.INT64:case L.onnx.TensorProto.DataType.DOUBLE:case L.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${L.onnx.TensorProto.DataType[t]}`)}}function ef(t,r){return new(_l(r))(t)}function _l(t){switch(t){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function wo(t,r){if(r===L.onnx.TensorProto.DataType.INT64||r===Vr.TensorDataType.INT64){if(t.greaterThanOrEqual(2147483648)||t.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(r===L.onnx.TensorProto.DataType.UINT32||r===Vr.TensorDataType.UINT32||r===L.onnx.TensorProto.DataType.UINT64||r===Vr.TensorDataType.UINT64){if(t.greaterThanOrEqual(4294967296)||t.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${L.onnx.TensorProto.DataType[r]}`);return t.toNumber()}function Oa(t,r,o){switch(r){case L.onnx.TensorProto.DataType.BOOL:case L.onnx.TensorProto.DataType.UINT8:return t.getUint8(o);case L.onnx.TensorProto.DataType.INT8:return t.getInt8(o);case L.onnx.TensorProto.DataType.UINT16:return t.getUint16(o,!0);case L.onnx.TensorProto.DataType.INT16:return t.getInt16(o,!0);case L.onnx.TensorProto.DataType.FLOAT:return t.getFloat32(o,!0);case L.onnx.TensorProto.DataType.INT32:return t.getInt32(o,!0);case L.onnx.TensorProto.DataType.UINT32:return t.getUint32(o,!0);case L.onnx.TensorProto.DataType.INT64:return wo(ee.fromBits(t.getUint32(o,!0),t.getUint32(o+4,!0),!1),r);case L.onnx.TensorProto.DataType.DOUBLE:return t.getFloat64(o,!0);case L.onnx.TensorProto.DataType.UINT64:return wo(ee.fromBits(t.getUint32(o,!0),t.getUint32(o+4,!0),!0),r);default:throw new Error(`cannot read from DataView for type ${L.onnx.TensorProto.DataType[r]}`)}}var Ea,L,Vr,Pt,De=I(()=>{"use strict";Ea=Ie(Bh()),yl(),Yr(),L=Ie(mr()),U(),Vr=H.experimental.fbs,Pt=class Mr{constructor(r,o,s,p,l,c=Ea.Guid.create()){this.dims=r,this.type=o,this.dataProvider=s,this.asyncDataProvider=p,this.cache=l,this.dataId=c,this.size=C.validateDimsAndCalcSize(r);let n=this.size,a=s===void 0&&p===void 0&&l===void 0;if(l!==void 0&&l.length!==n)throw new RangeError("Input dims doesn't match data length.");if(o==="string"){if(l!==void 0&&(!Array.isArray(l)||!l.every(e=>typeof e=="string")))throw new TypeError("cache should be a string array");a&&(this.cache=new Array(n))}else{if(l!==void 0){let e=_l(o);if(!(l instanceof e))throw new TypeError(`cache should be type ${e.name}`)}if(a){let e=new ArrayBuffer(n*tf(o));this.cache=ef(e,o)}}}get data(){if(this.cache===void 0){let r=this.dataProvider(this.dataId);if(r.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=r}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(r){return this.data[C.indicesToOffset(r,this.strides)]}set(r,o){this.data[C.indicesToOffset(r,this.strides)]=o}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=C.computeStrides(this.dims)),this._strides}static fromProto(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let o=Et.tensorDataTypeFromProto(r.dataType),s=Et.tensorDimsFromProto(r.dims),p=new Mr(s,o);if(o==="string")r.stringData.forEach((l,c)=>{p.data[c]=mo(l)});else if(r.rawData&&typeof r.rawData.byteLength=="number"&&r.rawData.byteLength>0){let l=p.data,c=new DataView(r.rawData.buffer,r.rawData.byteOffset,r.rawData.byteLength),n=Sa(r.dataType),a=r.rawData.byteLength/n;if(r.rawData.byteLength%n!==0)throw new Error("invalid buffer length");if(l.length!==a)throw new Error("buffer length mismatch");for(let e=0;e<a;e++){let u=Oa(c,r.dataType,e*n);l[e]=u}}else{let l;switch(r.dataType){case L.onnx.TensorProto.DataType.FLOAT:l=r.floatData;break;case L.onnx.TensorProto.DataType.INT32:case L.onnx.TensorProto.DataType.INT16:case L.onnx.TensorProto.DataType.UINT16:case L.onnx.TensorProto.DataType.INT8:case L.onnx.TensorProto.DataType.UINT8:case L.onnx.TensorProto.DataType.BOOL:l=r.int32Data;break;case L.onnx.TensorProto.DataType.INT64:l=r.int64Data;break;case L.onnx.TensorProto.DataType.DOUBLE:l=r.doubleData;break;case L.onnx.TensorProto.DataType.UINT32:case L.onnx.TensorProto.DataType.UINT64:l=r.uint64Data;break;default:throw new Error("unspecific error")}if(l==null)throw new Error("failed to populate data from a tensorproto value");let c=p.data;if(c.length!==l.length)throw new Error("array length mismatch");for(let n=0;n<l.length;n++){let a=l[n];ee.isLong(a)?c[n]=wo(a,r.dataType):c[n]=a}}return p}static fromData(r,o,s){return new Mr(o,s,void 0,void 0,r)}static fromOrtTensor(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let o=Et.tensorDimsFromORTFormat(r),s=Et.tensorDataTypeFromProto(r.dataType()),p=new Mr(o,s);if(s==="string")for(let l=0;l<r.stringDataLength();l++)p.data[l]=r.stringData(l);else if(r.rawDataArray()&&typeof r.rawDataLength()=="number"&&r.rawDataLength()>0){let l=p.data,c=new DataView(r.rawDataArray().buffer,r.rawDataArray().byteOffset,r.rawDataLength()),n=Sa(r.dataType()),a=r.rawDataLength()/n;if(r.rawDataLength()%n!==0)throw new Error("invalid buffer length");if(l.length!==a)throw new Error("buffer length mismatch");for(let e=0;e<a;e++){let u=Oa(c,r.dataType(),e*n);l[e]=u}}return p}}});function j(t){return t===1?Sl:Ol}function rf(t){let r=j(t);return`${r.version}
      precision highp float;
      ${r.attribute} vec3 position;
      ${r.attribute} vec2 textureCoord;

      ${r.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function nf(t){let r=j(t);return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFrag} vec2 TexCoords;
    ${r.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function of(t,r){let o=j(t);return`
  void main() {
    int indices[${r}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o.output} = result;
  }
  `}var Sl,Ol,Y=I(()=>{"use strict";Sl={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},Ol={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),V=I(()=>{"use strict"});async function Ia(t,r=s=>0,o){return new Promise((s,p)=>{let l=0,c=()=>{if(t()){s();return}l++;let n=r(l);if(o!=null&&l>=o){p();return}setTimeout(c,n)};c()})}function In(t){return Gr(typeof t<"u"&&t.length!==0,()=>"empty string found for sampler name"),"get"+t.charAt(0).toUpperCase()+t.slice(1)}function af(t){return Gr(typeof t<"u"&&t.length!==0,()=>"empty string found for sampler name"),"get"+t.charAt(0).toUpperCase()+t.slice(1)+"AtOutCoords"}function Ue(t,r){let o=JSON.parse(JSON.stringify(t));return o=r,o}function Ge(t,r){return r.map(o=>t[o]).join(", ")}function re(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function $e(t=6){return["x","y","z","w","u","v"].slice(0,t)}var qt=I(()=>{"use strict";U()});function sf(t,r){return $e(r).map(o=>`${t}.${o}`)}function Zo(t,r){return r===1?[t]:sf(t,r)}function br(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var Ne=I(()=>{"use strict";qt()});function uf(t,r,o){if(t===0)return"false";if(t===1)return`rc > ${r[0]}`;let s="";for(let p=t-2;p<t;p++)s+=`${o[p]} >= ${r[p-t+2]}`,p<t-1&&(s+="||");return s}function lf(t,r){let o=t.length;if(o===0)return"getA(), 0, 0, 0";if(o===1)return`getA(rc),
            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),
            0, 0`;let s="r, c",p="r, cp1",l="rp1, c",c="rp1, cp1",n="";if(o>2)for(let a=0;a<o-2;++a)n=n+`${r[a]},`;return`getA(${n}${s}),
          rEdge ? 0. : getA(${n}${l}),
          cEdge ? 0. : getA(${n}${p}),
          rEdge || cEdge ? 0. : getA(${n}${c})`}function pf(t,r,o,s){return t===0||t===1?"":`
    int r = ${r[t-2]};
    int c = ${r[t-1]};
    int rp1 = ${r[t-2]} + 1;
    int cp1 = ${r[t-1]} + 1;
    bool rEdge = rp1 >= ${s};
    bool cEdge = cp1 >= ${o};
    `}var Pn,Pa,El,cf=I(()=>{"use strict";Y(),V(),qt(),Ne(),Pn={name:"pack",inputNames:["A"],inputTypes:[1]},Pa=(t,r)=>{let o=j(t.session.backend.glContext.version),s=r.dims,p=s.length,l=r.dims.length,c=re(l),n=Zo("rc",l),a=pf(l,n,s[s.length-2],s[s.length-1]),e;p===0?e=[1,1]:p===1?e=[s[0],1]:e=[s[l-1],s[l-2]];let u=uf(l,e,n),i=lf(s,n),d=`
        void main() {
          ${c} rc = getOutputCoords();

          if(${u}) {
            ${o.output} = vec4(0);
          } else {
            ${a}

            ${o.output} = vec4(${i});
          }
        }
      `;return{...Pn,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:2},shaderSource:d}},El=(t,r)=>({...Pn,get:()=>Pa(t,r)})});function Aa(t){if(t.length===0)return[1,1,1];let r=1;for(let o=0;o<t.length-2;++o)r*=t[o];return[r,t.length>1?t[t.length-2]:1,t[t.length-1]]}function df(t,r){let o=!1;return t.length===0||r.length===0?o=!0:t.length<2||r.length<2?o=t[t.length-1]===r[r.length-1]:o=t[t.length-1]===r[r.length-1]&&t[t.length-2]===r[r.length-2],o}function hf(t){let r=C.computeStrides(t),o=["b","r","c"],s="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r.map((p,l)=>{let c=`int ${o[l]} = ${s} / ${p}`,n=l===r.length-1?`int ${o[l+1]} = ${s} - ${o[l]} * ${p}`:`index -= ${o[l]} * ${p}`;return`${c}; ${n};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function ff(t){let r=C.computeStrides(t);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${r[0]} + coords.z * ${r[1]} + coords.y;
  }
`}var $a,Da,Il,gf=I(()=>{"use strict";U(),Y(),V(),Ne(),$a=t=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${t}`}),Da=(t,r,o,s)=>{let p=r.dims,l=s,c="";for(let e=0;e<4;e++){let u="";switch(e){case 0:u="outputCoords = rc;";break;case 1:u="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:u="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:u="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}c+=`
        ${u}
        ${e>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${e>0?"}":""}
      `}let n=j(t.session.backend.glContext.version),a=`
      ${hf(p)}
      ${ff(l)}
      ${br()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${l[2]};
        int cols = ${l[1]};

        ${c}
        ${n.output} = result;
      }
    `;return{...o,output:{dims:l,type:r.type,textureType:2},shaderSource:a,hasMain:!0}},Il=(t,r,o)=>{let s=$a(o);return{...s,get:()=>Da(t,r,s,o)}}}),vo,mf=I(()=>{"use strict";Y(),V(),vo=(t,r)=>{let o=r.shape,s=j(t.session.backend.glContext.version),p=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${s.texture2D}(X,TexCoords).r;
      ${s.output} = encodeAsUint8(value);
    }`,l={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:o,type:r.tensor.type,textureType:3},shaderSource:p,hasMain:!0};return t.executeProgram(l,[r.tensor])}});function bf(t,r){if(t===1)return"rc";let o="";for(let s=0;s<t;s++)o+=r[s],s<t-1&&(o+=",");return o}var An,Na,Pl,yf=I(()=>{"use strict";Y(),V(),qt(),Ne(),An={name:"unpack",inputNames:["A"],inputTypes:[2]},Na=(t,r)=>{let o=r.dims.length,s=Zo("rc",o),p=s.slice(-2),l=re(o),c=br(),n=r.dims.length===0?"":bf(o,s),a=o<=1?"rc":`vec2(${p.join(",")})`,e=j(t.session.backend.glContext.version),u=`
    ${c}
    void main() {
      ${l} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${n});

       ${e.output} = vec4(getChannel(packedInput, ${a}), 0, 0, 0);
     }
   `;return{...An,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:u}},Pl=(t,r)=>({...An,get:()=>Na(t,r)})}),Al,xo,$l,qr=I(()=>{"use strict";Rt(),Al=class{constructor(t,r=1){if(r===1)this.internalFormat=t.R32F,this.format=t.RED,this.textureType=t.FLOAT,this.channelSize=r;else if(r===4)this.internalFormat=t.RGBA32F,this.format=t.RGBA,this.textureType=t.FLOAT,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(t,r){let o,s;return t.constructor!==Float32Array&&(tt.warning("Encoder","data was not of type Float32; creating new Float32Array"),s=new Float32Array(t)),r*this.channelSize>t.length?(tt.warning("Encoder","Source data too small. Allocating larger array"),s=t,o=this.allocate(r*this.channelSize),s.forEach((p,l)=>o[l]=p)):(s=t,o=s),o}allocate(t){return new Float32Array(t*4)}decode(t,r){return this.channelSize===1?t.filter((o,s)=>s%4===0).subarray(0,r):t.subarray(0,r)}},xo=class{constructor(t,r=1,o){if(r!==1&&r!==4)throw new Error(`Invalid number of channels: ${r}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.channelSize=r,this.textureType=o||t.FLOAT}encode(t,r){let o=t;return this.channelSize===1&&(tt.verbose("Encoder","Exploding into a larger array"),o=this.allocate(r),t.forEach((s,p)=>o[p*4]=s)),o}allocate(t){return new Float32Array(t*4)}decode(t,r){return this.channelSize===1?t.filter((o,s)=>s%4===0).subarray(0,r):t.subarray(0,r)}},$l=class{constructor(t,r=1){if(this.channelSize=4,r===1)this.internalFormat=t.ALPHA,this.format=t.ALPHA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=r;else if(r===4)this.internalFormat=t.RGBA,this.format=t.RGBA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(t,r){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}allocate(t){return new Uint8Array(t*this.channelSize)}decode(t,r){if(t instanceof Uint8Array)return t.subarray(0,r);throw new Error(`Invalid array type: ${t.constructor}`)}}}),ur,Dl,To,wf=I(()=>{"use strict";U(),V(),ur=(t,r,o)=>{let s=o===0||o===1?1:4,p=o===2,l=o===1||o===2,c=o===4?r.length-1:void 0,n=o===4?r.map((a,e)=>e===r.length-1?a*4:a):void 0;return To(t,r,s,n,{isPacked:p,reverseWH:l,breakAxis:c})},Dl=(t,r,o)=>{let s=ur(t,r,o);return[s.width,s.height]},To=(t,r,o=1,s,p)=>{let l=!!(p&&p.isPacked),[c,n]=t.computeTextureWH(l&&s||r,p),a=r.length,e=r.slice(0);if(a===0&&(e=[1]),o===1)s=r;else if(l){if(o!==4)throw new Error("a packed texture must be 4-channel");s=r,a>0&&(e[a-1]=Math.ceil(e[a-1]/2)),a>1&&(e[a-2]=Math.ceil(e[a-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:c,height:n,channels:o,isPacked:l,shape:e,strides:C.computeStrides(e),unpackedShape:s,reversedWH:p&&p.reverseWH}}}),ka,Nl,vf=I(()=>{"use strict";Rt(),De(),U(),cf(),gf(),mf(),yf(),qr(),wf(),V(),ka=(t,r)=>{let o=r.map(p=>`${p.unpackedShape.join(",")};${p.width}x${p.height}`).join("_"),s=t.name;return t.cacheHint&&(s+="["+t.cacheHint+"]"),s+=":"+o,s},Nl=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,r){return Dl(this.session.layoutStrategy,t,r)}executeProgram(t,r){if(r.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error("input names size does not match input types");let o=[];for(let a=0;a<t.inputNames.length;++a)o[a]=this.getOrCreateTextureData(r[a],t.inputTypes[a]);let s=ka(t,o),p=this.session.programManager.getArtifact(s),l=p?p.programInfo:typeof t.get=="function"?t.get():t,c=ur(this.session.layoutStrategy,l.output.dims,l.output.textureType),n=this.createTextureData(c,l.output.type);return p||(p=this.session.programManager.build(l,o,n),this.session.programManager.setArtifact(s,p)),this.runProgram(p,o,n),n}run(t,r){return this.executeProgram(t,r).tensor}runProgram(t,r,o){for(let s=0;s<r.length;++s)if(!!r[s].isPacked!=(t.programInfo.inputTypes[s]===2))throw new Error(`input[${s}] property packed inconsistent`);if(!!o.isPacked!=(t.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(t,r,o)}getOrCreateTextureData(t,r){let o=this.getTextureData(t.dataId,r===2);if(!o&&(o=this.getTextureData(t.dataId,r!==2),o))return r===2?this.pack(o):this.unpack(o);if(!o){let s=ur(this.session.layoutStrategy,t.dims,r);if(r===4){let p=t.dims;if(p.length===4){let l=[p[0],Math.ceil(p[1]*p[2]*p[3]/4)],c=ur(this.session.layoutStrategy,l,r),n=t.numberData;if(p[1]*p[2]*p[3]%4!==0){let a=p[0],e=p[1]*p[2]*p[3],u=Math.ceil(e*1/4)*4,i=a*u;n=new Float32Array(i);for(let d=0;d<a;++d){let h=d*e,m=d*u+d%1*e;n.set(t.numberData.subarray(h,h+e),m)}}return this.createTextureData(c,t.type,n,t,1)}}if(r===2){let p=To(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),l=this.createTextureData(p,t.type,t.numberData,t,1);o=this.pack(l)}else o=this.createTextureData(s,t.type,t.numberData,t,1)}return o}createTextureDataFromLayoutBindTensor(t,r,o,s){return this.createTextureData(t,r,o,s,1)}createTextureData(t,r,o,s,p){tt.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(t)}]`);let l=this.session.textureManager.createTextureFromLayout(r,t,o,p);return this.createTextureDataFromTexture(t,r,l,s)}reshapeUnpacked(t,r){let o=this.getOrCreateTextureData(t,0),s={channels:o.channels,height:o.height,width:o.width,shape:r.length!==0?r:[1],strides:C.computeStrides(r),unpackedShape:r};return this.createTextureDataFromTexture(s,t.type,o.texture).tensor}reshapePacked(t,r){let o=this.getOrCreateTextureData(t,2);if(df(t.dims,r)){let n={channels:o.channels,height:o.height,width:o.width,shape:r.length!==0?r:[1],strides:C.computeStrides(r),unpackedShape:r,isPacked:!0};return this.createTextureDataFromTexture(n,t.type,o.texture).tensor}let s=Aa(t.dims),p=Aa(r),l=this.reshapePacked(t,s),c=this.run(Il(this,l,p),[l]);return this.reshapePacked(c,r)}cast(t,r){let o=this.getOrCreateTextureData(t,0);return this.createTextureDataFromTexture(o,r,o.texture).tensor}createTextureDataFromTexture(t,r,o,s,p){let l={...t,tensor:s||new Pt(t.unpackedShape,r,c=>this.readTexture(l),async c=>this.readTextureAsync(l),void 0,p),texture:o};return this.setTextureData(l.tensor.dataId,l,t.isPacked),l}getTextureData(t,r=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,r):r?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,r,o=!1){this.session.isInitializer(t)?this.session.setTextureData(t,r,o):(o?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,r)}isTextureLayoutCached(t,r=!1){return!!this.getTextureData(t.dataId,r)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat(vo(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat(vo(this,t))}pack(t){return this.executeProgram(El(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram(Pl(this,t.tensor),[t.tensor])}}}),Fa,X,lt=I(()=>{"use strict";Fa=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},X=t=>new Fa(t)}),$n,kl,Fl,Ca,La,xf=I(()=>{"use strict";lt(),Y(),V(),$n={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},kl=(t,r,o)=>(La(r),[t.run({...$n,cacheHint:o.cacheKey,get:()=>Ca(t,r,o)},r)]),Fl=t=>{let r=t.attributes.getFloat("epsilon",1e-5),o=t.attributes.getFloat("momentum",.9),s=t.attributes.getInt("spatial",1);return X({epsilon:r,momentum:o,spatial:s})},Ca=(t,r,o)=>{let s=j(t.session.backend.glContext.version),p=r[0].dims.length,[l,c]=t.calculateTextureWidthAndHeight(r[1].dims,0),n=`
  float process(int[${p}] indices) {
    vec2 position = offsetToCoords(indices[1], ${l}, ${c});
    float scale = getColorAsFloat(${s.texture2D}(Scale, position));
    float mean = getColorAsFloat(${s.texture2D}(Mean, position));
    float variance = getColorAsFloat(${s.texture2D}(Variance, position));
    float b = getColorAsFloat(${s.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${o.epsilon})) ) + b;
  }`;return{...$n,output:{dims:r[0].dims,type:r[0].type,textureType:0},shaderSource:n}},La=t=>{if(!t||t.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let r=t[0],o=t[1],s=t[2],p=t[3],l=t[4];if(r.dims.length<3||o.dims.length!==1||s.dims.length!==1||p.dims.length!==1||l.dims.length!==1)throw new Error("invalid input shape.");if(o.dims[0]!==r.dims[1]||s.dims[0]!==r.dims[1]||p.dims[0]!==r.dims[1]||l.dims[0]!==r.dims[1])throw new Error("invalid input shape.");if(r.type!=="float32"&&r.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||p.type!=="float32"&&p.type!=="float64"||l.type!=="float32"&&l.type!=="float64")throw new Error("invalid input tensor types.")}}),Cl,ke,D,_o,Ll,ne=I(()=>{"use strict";Cl=class{constructor(t,r,o,s){this.glContext=t,this.programInfo=r,this.inputTextureLayouts=o,this.outputTextureLayout=s}},ke=class{constructor(t){this.context=t}},D=class{constructor(t,r){this.routineBody=t,this.dependencies=r}},_o=class{constructor(t,r,o){this.name=t,o?this.dependencies=o:this.dependencies=[],r&&(this.routineBody=r)}addDependency(t){t&&this.dependencies.push(t)}},Ll=class{static returnOrderedNodes(t){if(!t||t.length===0)return[];if(t.length===1)return t;let r=new Set,o=new Set,s=new Array;return this.createOrderedNodes(t,r,o,s),s}static createOrderedNodes(t,r,o,s){for(let p=0;p<t.length;++p)this.dfsTraverse(t[p],r,o,s)}static dfsTraverse(t,r,o,s){if(!t||o.has(t.name))return;if(r.has(t.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");r.add(t.name);let p=t.dependencies;if(p&&p.length>0)for(let l=0;l<p.length;++l)this.dfsTraverse(p[l],r,o,s);s.push(t),o.add(t.name),r.delete(t.name)}}});function Tf(){let t="add_";return{body:`
  float ${t}(float a, float b) {
    return a + b;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:t,type:0}}function _f(){let t="div_";return{body:`
  float ${t}(float a, float b) {
    return a / b;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:t,type:0}}function Sf(){let t="mul_";return{body:`
  float ${t}(float a, float b) {
    return a * b;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:t,type:0}}function Of(){let t="sub_";return{body:`
  float ${t}(float a, float b) {
    return a - b;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:t,type:0}}function Ef(){let t="equal_";return{body:`
  float ${t}(float a, float b) {
    return float(a == b);
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:t,type:0}}function If(){let t="greater_";return{body:`
  float ${t}(float a, float b) {
    return float(a > b);
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:t,type:0}}function Pf(){let t="less_";return{body:`
  float ${t}(float a, float b) {
    return float(a < b);
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:t,type:0}}function Af(){let t="and_";return{body:`
  float ${t}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:t,type:0}}function $f(){let t="or_";return{body:`
  float ${t}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:t,type:0}}function Df(){let t="xor_";return{body:`
  float ${t}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:t,type:0}}function Nf(){return Ff("pow")}function kf(){let t="prelu_";return{body:`
  float ${t}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${t}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:t,type:0}}function Ff(t){let r=`${t}_`;return{body:`
  float ${r}(float a, float b) {
    return ${t}(a, b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return ${t}(v1, v2);
  }
  `,name:r,type:0}}var St,Ra,Rl,Bl,jl,Vl,Ml,zl,Ul,Gl,Hl,ql,Wl,Xl,Cf=I(()=>{"use strict";U(),ne(),Y(),V(),St=(t,r,o,s=r[0].type,p)=>{let l=t.session.pack?2:0;return{name:o.name,inputNames:["A","B"],inputTypes:[l,l],cacheHint:p,get:()=>Ra(t,r,o,s)}},Ra=(t,r,o,s=r[0].type)=>{let p=t.session.pack?2:0,l=!C.areEqual(r[0].dims,r[1].dims),c=r[0].dims,n=t.session.pack;if(l){let u=Mt.calcShape(r[0].dims,r[1].dims,!1);if(!u)throw new Error("Can't perform binary op on the given tensors");c=u;let i=c.length,d=r[0].dims.length!==0?r[0].dims.length:1,h=r[1].dims.length!==0?r[1].dims.length:1,m=r[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",b=r[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",x=j(t.session.backend.glContext.version),E=n?`
      ${o.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${o.name}(a, b);
        ${x.output} = result;
      }`:`
      ${o.body}
      float process(int indices[${i}]) {
        int aindices[${d}];
        int bindices[${h}];
        ${m}
        ${b}
        return ${o.name}(_A(aindices), _B(bindices));
      }`;return{name:o.name,inputNames:["A","B"],inputTypes:[p,p],output:{dims:c,type:s,textureType:p},shaderSource:E,hasMain:n}}let a=j(t.session.backend.glContext.version),e=`
    ${o.body}
    void main() {
      vec4 v1 = ${a.texture2D}(A, TexCoords);
      vec4 v2 = ${a.texture2D}(B, TexCoords);
      vec4 result = ${o.name}(v1, v2);
      ${a.output} = result;
    }
    `;return{name:o.name,inputNames:["A","B"],inputTypes:[p,p],output:{dims:r[0].dims,type:s,textureType:p},shaderSource:e,hasMain:!0}},Rl=(t,r)=>[t.run(St(t,r,Tf()),r)],Bl=(t,r)=>[t.run(St(t,r,Af(),"bool"),r)],jl=(t,r)=>[t.run(St(t,r,_f()),r)],Vl=(t,r)=>[t.run(St(t,r,Ef(),"bool"),r)],Ml=(t,r)=>[t.run(St(t,r,If(),"bool"),r)],zl=(t,r)=>[t.run(St(t,r,Pf(),"bool"),r)],Ul=(t,r)=>[t.run(St(t,r,Sf()),r)],Gl=(t,r)=>[t.run(St(t,r,$f(),"bool"),r)],Hl=(t,r)=>[t.run(St(t,r,Nf()),r)],ql=(t,r)=>[t.run(St(t,r,kf()),r)],Wl=(t,r)=>[t.run(St(t,r,Of()),r)],Xl=(t,r)=>[t.run(St(t,r,Df(),"bool"),r)]}),Kl,Zl,Ba,Lf=I(()=>{"use strict";U(),Kl=(t,r,o)=>(Ba(r),[t.cast(r[0],o)]),Zl=t=>Et.tensorDataTypeFromProto(t.attributes.getInt("to")),Ba=t=>{if(!t||t.length!==1)throw new Error("Cast requires 1 input.");if(t[0].type==="string")throw new Error("Invalid input type.")}}),ja,Va,Jl,He,Rf=I(()=>{"use strict";Y(),V(),qt(),Ne(),ja=(t,r)=>({name:"Concat (packed)",inputNames:Array.from({length:t},(o,s)=>`X${s}`),inputTypes:Array(t).fill(2),cacheHint:r}),Va=(t,r,o,s)=>{let p=o[0].dims.slice();if(s>=p.length||s<-1*p.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=p.length+s);let l=p.slice(0);for(let F=1;F<o.length;F++){let bt=o[F].dims.slice();for(let pt=0;pt<p.length;pt++)if(pt===s)l[s]+=bt[pt];else if(p[pt]!==bt[pt])throw new Error("non concat dimensions must match")}let c=l.length,n=Zo("coords",c),a=re(c),e=br(),u=o.map(F=>F.dims),i=$e(c),d=new Array(u.length-1);d[0]=u[0][s];for(let F=1;F<d.length;F++)d[F]=d[F-1]+u[F][s];let h=i[s],m=i.slice(-2),b=i.join(),x=`if (${h} < ${d[0]}) {
        return getChannel(
            getX0(${b}), vec2(${m.join()}));
        }`;for(let F=1;F<d.length;F++){let bt=d[F-1];x+=`
            if (${h} < ${d[F]}  && ${h} >= ${d[F-1]}) {
              return getChannel(
                getX${F}(${He(i,h,bt)}),
                vec2(${He(m,h,bt)}));
            }`}let E=d.length,w=d[d.length-1];x+=`
            return getChannel(
              getX${E}(${He(i,h,w)}),
              vec2(${He(m,h,w)}));`;let S=j(t.session.backend.glContext.version),$=`
          ${e}
          float getValue(${i.map(F=>"int "+F)}) {
            ${x}
          }

          void main() {
            ${a} coords = getOutputCoords();
            int lastDim = coords.${i[c-1]};
            coords.${i[c-1]} = coords.${i[c-2]};
            coords.${i[c-2]} = lastDim;

            vec4 result = vec4(getValue(${n}), 0., 0., 0.);

            ${n[c-1]} = ${n[c-1]} + 1;
            if (${n[c-1]} < ${l[c-1]}) {
              result.g = getValue(${n});
            }

            ${n[c-2]} = ${n[c-2]} + 1;
            if (${n[c-2]} < ${l[c-2]}) {
              result.a = getValue(${n});
            }

            ${n[c-1]} = ${n[c-1]} - 1;
            if (${n[c-2]} < ${l[c-2]} &&
                ${n[c-1]} < ${l[c-1]}) {
              result.b = getValue(${n});
            }
            ${S.output} = result;
          }
        `;return{...r,output:{dims:l,type:o[0].type,textureType:2},shaderSource:$,hasMain:!0}},Jl=(t,r,o)=>{let s=ja(r.length,o.cacheKey);return{...s,get:()=>Va(t,s,r,o.axis)}},He=(t,r,o)=>{let s=t.indexOf(r);return t.map((p,l)=>l===s?`${p} - ${o}`:p).join()}}),Yl,Ma,za,Ua,Dn,Ga,Ha,qa,Ql,Wa,Bf=I(()=>{"use strict";lt(),V(),Rf(),Yl=(t,r,o)=>(Wa(r),t.session.pack&&r[0].dims.length>1?[t.run(Jl(t,r,o),r)]:[t.run(Ua(t,r,o),r)]),Ma=(t,r)=>({name:"Concat",inputNames:Array.from({length:t},(o,s)=>`X${s}`),inputTypes:Array(t).fill(0),cacheHint:r}),za=(t,r,o,s)=>{let p=o[0].dims.slice();if(s>=p.length||s<-1*p.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=p.length+s);let l=p.slice(0);for(let h=1;h<o.length;h++){let m=o[h].dims.slice();for(let b=0;b<p.length;b++)if(b===s)l[s]+=m[b];else if(p[b]!==m[b])throw new Error("non concat dimensions must match")}let c=l.length,n=new Array(o.length),a=0;for(let h=0;h<n.length;++h)a+=o[h].dims[s],n[h]=a;let e="";o.length<5?e=Dn(n):e=Ga(n);let u=Ha(o.length,c),i=qa(n),d=`
        ${u}
        ${i}
        ${e}
        float process(int indices[${c}]) {
          int textureIndex = getTextureWhereDataResides (indices[${s}]);

          if(textureIndex != 0) {
            indices[${s}] = indices[${s}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...r,output:{dims:l,type:o[0].type,textureType:0},shaderSource:d}},Ua=(t,r,o)=>{let s=Ma(r.length,o.cacheKey);return{...s,get:()=>za(t,s,r,o.axis)}},Dn=t=>`int getTextureWhereDataResides(int index) {
      ${t.map((r,o)=>`if(index<${r}) {return ${o};}
`).join("")}
    }`,Ga=t=>Dn(t),Ha=(t,r)=>{let o=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${r}]) {`];for(let s=0;s<t;++s)s===0?o.push(`	if (textureIndex == ${s}) { return _X${s}(indices); }`):s===t-1?o.push(`	else { return _X${s}(indices); }`):o.push(`	else if (textureIndex == ${s}) { return _X${s}(indices); }`);return o.push("	}"),o.join(`
`)},qa=t=>{let r=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let o=0;o<t.length;++o)o===0?r.push(`	if (index == ${o}) { return ${t[o]}; }`):o===t.length-1?r.push(`	else { return ${t[o]}; }`):r.push(`	else if (index == ${o}) { return ${t[o]}; }`);return r.push("	}"),r.join(`
`)},Ql=t=>X({axis:t.attributes.getInt("axis")}),Wa=t=>{if(!t||t.length<1)throw new Error("too few inputs");let r=t[0].type,o=t[0].dims.length;if(r==="string")throw new Error("string tensor is not supported yet");for(let s of t){if(s.type!==r)throw new Error("input tensors should be one type");if(s.dims.length!==o)throw new Error("input tensors should have the same shape")}}});function jf(){return Ft("abs")}function Vf(){return Ft("acos")}function Mf(){return Ft("asin")}function zf(){return Ft("atan")}function Uf(){return Ft("ceil")}function Gf(){return Ft("cos")}function Hf(t){let r="elu";return{body:`
  const float alpha = float(${t});

  float ${r}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function qf(){return Ft("exp")}function Wf(){return Ft("floor")}function tp(t,r){let o="clip";return{body:`
  const float min = float(${t});
  const float max = float(${r});

  float ${o}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${o}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:o,type:0}}function Xf(){let t="indentity";return{body:`
  float ${t}_(float a) {
    return a;
  }
  vec4 ${t}_(vec4 v) {
    return v;
  }
  `,name:t,type:0}}function Kf(t){let r="leakyRelu";return{body:`
  const float alpha = float(${t});

  float ${r}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function Zf(){return Ft("log")}function Jf(){let t="neg";return{body:`
  float ${t}_(float a) {
    return -a;
  }
  vec4 ${t}_(vec4 v) {
    return -v;
  }
  `,name:t,type:0}}function Yf(){let t="not";return{body:`
  float ${t}_(float a) {
    return float( ! bool(a) );
  }
  bool ${t}_(bool a) {
    return !a;
  }
  vec4 ${t}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${t}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:t,type:0}}function Qf(){return Ft("sin")}function ep(){let t="relu";return{body:`
  float ${t}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${t}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:t,type:0}}function rp(){let t="sigmoid";return{body:`
  float ${t}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${t}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:t,type:0}}function tg(){return Ft("sqrt")}function eg(){return Ft("tan")}function rg(){let t="tanh";return{body:`
  float ${t}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${t}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:t,type:0}}function Ft(t){return{body:`
  float ${t}_(float a) {
    return ${t}(a);
  }
  vec4 ${t}_(vec4 v) {
    return ${t}(v);
  }
  `,name:t,type:0}}var Xa,Q,np,op,ip,ap,So,sp,up,Ka,lp,pp,cp,dp,hp,fp,Oo,gp,mp,bp,yp,wp,vp,xp,Tp,_p,Sp,Op,Ep=I(()=>{"use strict";lt(),U(),ne(),Y(),V(),Xa=(t,r,o,s)=>{let p=t.session.pack?2:0,l=j(t.session.backend.glContext.version);return{...r,output:{dims:o.dims,type:o.type,textureType:p},shaderSource:`
     ${s.body}
     void main() {
       vec4 v = ${l.texture2D}(A, TexCoords);
       v = ${s.name}_(v);
       ${l.output} = v;
     }
     `,hasMain:!0}},Q=(t,r,o,s)=>{let p=t.session.pack?2:0,l={name:o.name,inputTypes:[p],inputNames:["A"],cacheHint:s};return{...l,get:()=>Xa(t,l,r,o)}},np=(t,r)=>[t.run(Q(t,r[0],jf()),r)],op=(t,r)=>[t.run(Q(t,r[0],Vf()),r)],ip=(t,r)=>[t.run(Q(t,r[0],Mf()),r)],ap=(t,r)=>[t.run(Q(t,r[0],zf()),r)],So=(t,r,o)=>[t.run(Q(t,r[0],tp(o.min,o.max),o.cacheKey),r)],sp=t=>X({min:t.attributes.getFloat("min",dr),max:t.attributes.getFloat("max",hr)}),up=(t,r)=>{let o=Ka(t,r);return So(t,[r[0]],o)},Ka=(t,r)=>{if(r.length>=3&&(!t.session.isInitializer(r[1].dataId)||!t.session.isInitializer(r[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let o=r.length>=3?r[1].numberData[0]:dr,s=r.length>=3?r[2].numberData[0]:hr;return X({min:o,max:s})},lp=(t,r)=>[t.run(Q(t,r[0],Uf()),r)],pp=(t,r)=>[t.run(Q(t,r[0],Gf()),r)],cp=(t,r,o)=>[t.run(Q(t,r[0],Hf(o.alpha),o.cacheKey),r)],dp=t=>X({alpha:t.attributes.getFloat("alpha",1)}),hp=(t,r)=>[t.run(Q(t,r[0],qf()),r)],fp=(t,r)=>[t.run(Q(t,r[0],Wf()),r)],Oo=(t,r)=>[t.run(Q(t,r[0],Xf()),r)],gp=(t,r,o)=>[t.run(Q(t,r[0],Kf(o.alpha),o.cacheKey),r)],mp=t=>X({alpha:t.attributes.getFloat("alpha",.01)}),bp=(t,r)=>[t.run(Q(t,r[0],Zf()),r)],yp=(t,r)=>[t.run(Q(t,r[0],Jf()),r)],wp=(t,r)=>[t.run(Q(t,r[0],Yf()),r)],vp=(t,r)=>[t.run(Q(t,r[0],ep()),r)],xp=(t,r)=>[t.run(Q(t,r[0],rp()),r)],Tp=(t,r)=>[t.run(Q(t,r[0],Qf()),r)],_p=(t,r)=>[t.run(Q(t,r[0],tg()),r)],Sp=(t,r)=>[t.run(Q(t,r[0],eg()),r)],Op=(t,r)=>[t.run(Q(t,r[0],rg()),r)]});function yr(t){let r;switch(t.activation){case"Relu":r=ep();break;case"Sigmoid":r=rp();break;case"Clip":r=tp(t.clipMin,t.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let o=r.name,s=r.body,p=`value = ${o}_(value);`;return{activationFunction:s,applyActivation:p}}var Qr,Fe=I(()=>{"use strict";U(),Ep(),Qr=t=>{let r=t.getString("activation","");if(r==="Clip"){let[o,s]=t.getFloats("activation_params",[dr,hr]);return{activation:r,clipMax:s,clipMin:o,activationCacheKey:`${r}:${o},${s}`}}return{activation:r,activationCacheKey:r}}}),Za,Ja,Ip,ng=I(()=>{"use strict";Rt(),Y(),V(),Qo(),Fe(),Za=(t,r)=>({name:"GroupedConv",inputNames:t?["X","W","Bias"]:["X","W"],inputTypes:t?[0,0,0]:[0,0],cacheHint:r}),Ja=(t,r,o,s)=>{let p=r.length>2?"value += getBias(output_channel);":"",l=r[0].dims.slice(),c=r[1].dims.slice(),n=c[0]/s.group;tt.verbose("GroupedConv",`autpPad:${s.autoPad}, dilations:${s.dilations}, group:${s.group}, kernelShape:${s.kernelShape}, pads:${s.pads}, strides:${s.strides}`);let a=lr(l,c,s.dilations,s.pads,s.strides),e=j(t.session.backend.glContext.version),{activationFunction:u,applyActivation:i}=yr(s),d=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${u}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${n};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${c[1]}; wInChannel++) {
      int input_channel = group_id * ${c[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${c[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${s.dilations[0]};

        if (xHeight < 0 || xHeight >= ${l[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${c[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${s.dilations[1]};
          if (xWidth < 0 || xWidth >= ${l[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${p}
    ${i}
    ${e.output} = vec4(value, .0, .0, .0);
  }
`;return{...o,output:{dims:a,type:r[0].type,textureType:0},shaderSource:d,hasMain:!0}},Ip=(t,r,o)=>{let s=Za(r.length>2,o.cacheKey);return{...s,get:()=>Ja(t,r,s,o)}}}),Ya,Qa,Pp,og=I(()=>{"use strict";Y(),V(),Ne(),Ya=t=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:t}),Qa=(t,r,o,s,p,l)=>{let c=o.dims,n=s.dims,a=2,e=3,u=p.length,i=[n[1]*n[2]*n[3],p[2]*p[3]],d=n[2]*n[3],h=br(),m=j(t.session.backend.glContext.version),b="";for(let E=0;E<=1;E++)for(let w=0;w<=1;w++)b+=`
            blockIndex = rc.x + ${w};
            pos = rc.y + ${E};

            if(blockIndex < ${i[1]} && pos < ${i[0]}) {
              offsetY = int(blockIndex / (${p[u-1]})) * ${l.strides[0]} -
                ${l.pads[0]};
              d0 = offsetY + ${l.dilations[0]} * (imod(pos, ${d}) / ${n[2]});

              if(d0 < ${c[a]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${p[u-1]}) * ${l.strides[1]} -
                  ${l.pads[1]};
                d1 = offsetX + ${l.dilations[1]} * imod(imod(pos, ${d}), ${n[2]});

                if(d1 < ${c[e]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d}.);
                    innerDims = vec2(d0, d1);
                    result[${E*2+w}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let x=`
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b}
          ${m.output} = result;
      }
            `;return{...r,output:{dims:i,type:o.type,textureType:2},shaderSource:x,hasMain:!0}},Pp=(t,r,o,s,p)=>{let l=Ya(p.cacheKey);return{...l,get:()=>Qa(t,l,r,o,s,p)}}});function ig(t,r,o){let s=r[0].dims,p=r[1].dims,l=Mt.calcShape(s,p,!0);if(!l)throw new Error("Can't use matmul on the given tensors");let c=re(l.length),n=$e(),{activationFunction:a,applyActivation:e}=yr(o),u=r.length>2,i=u?"value += getBiasForMatmul();":"",d=u?`${$p(c,n,r[2].dims,l,!1)}`:"",h=l.length,m=s.length,b=p.length,x=s[s.length-1],E=`
    ${a}
    ${d}
    float process(int indices[${h}]) {
        int a[${m}];
        int b[${b}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${x}; ++k) {
            a[${m-1}] = k;
            b[${b-2}] = k;
            value += _A(a) * _B(b);
        }
        ${i}
        ${e}
        return value;
    }`;return{...t,output:{dims:l,type:r[0].type,textureType:0},shaderSource:E}}function Ap(t,r){let o=kp(t.length>2,r.activationCacheKey);return{...o,get:()=>ig(o,t,r)}}function $p(t,r,o,s,p){let l="",c=o.length,n=s.length,a=n-c;n<2&&c>0?l="coords":l=o.map((d,h)=>`coords.${r[h+a]}`).join(", ");let e=Mt.getBroadcastDims(o,s).map(d=>`coords.${r[d+a]} = 0;`).join(`
`),u=C.size(o)===1,i="vec4(outputValue.xx, outputValue.yy)";return u&&(i="vec4(outputValue.x)"),p?`
vec4 getBiasForMatmul() {
  ${t} coords = getOutputCoords();
  ${e}
  vec4 outputValue = getBias(${l});
  return ${i};
}`:`
float getBiasForMatmul() {
  ${t} coords = getOutputCoords();
  ${e}
  return getBias(coords.x);
}`}var Dp,Np,kp,ts,Jo=I(()=>{"use strict";U(),V(),qt(),Fe(),Fp(),Dp=(t,r,o)=>(ts(r),t.session.pack?[t.run(Yo(t,r,o),r)]:[t.run(Ap(r,o),r)]),Np=t=>Qr(t.attributes),kp=(t,r)=>({name:"MatMul",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[0,0,0]:[0,0],cacheHint:r}),ts=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.");if(t[0].type!=="float32"&&t[0].type!=="float64"||t[1].type!=="float32"&&t[1].type!=="float64")throw new Error("inputs should be float type");if(t[0].type!==t[1].type)throw new Error("inputs types should match")}});function ag(t,r,o,s){let p=[],l=[],c=o[0].dims,n=o[1].dims,a=c.length,e=n.length,u=s.length,i=u-a,d=u-e;p=c.map((w,S)=>`coords.${r[S+i]}`),p[a-1]="i*2",p.join(", "),l=n.map((w,S)=>`coords.${r[S+d]}`),l[e-2]="i*2",l.join(", ");let h=Mt.getBroadcastDims(c,s),m=Mt.getBroadcastDims(n,s),b=h.map(w=>`coords.${r[w+i]} = 0;`).join(`
`),x=m.map(w=>`coords.${r[w+d]} = 0;`).join(`
`),E=`int lastDim = coords.${r[u-1]};
  coords.${r[u-1]} = coords.${r[u-2]};
  coords.${r[u-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${t} coords = getOutputCoords();
  ${E}
  ${b}
  vec4 outputValue = getA(${p});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${t} coords = getOutputCoords();
  ${E}
  ${x}
  vec4 outputValue = getB(${l});
  return outputValue;
}`}function sg(t,r){let o="";for(let s=0;s<r-2;s++)o+=`rc.${t[s]}, `;return o+=`rc.${t[r-2]}, i*2`,o}function ug(t,r){let o="";for(let s=0;s<r-2;s++)o+=`rc.${t[s]}, `;return o+=`i*2, rc.${t[r-1]}`,o}var es,rs,Yo,Fp=I(()=>{"use strict";U(),Y(),V(),qt(),Fe(),Jo(),es=(t,r)=>({name:"MatMul (packed)",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[2,2,2]:[2,2],cacheHint:r}),rs=(t,r,o,s)=>{let p=o.length>2,l=p?"value += getBiasForMatmul();":"",c=o[0].dims,n=o[1].dims,a=Mt.calcShape(c,n,!0),e=!C.areEqual(o[0].dims,o[1].dims);if(!a)throw new Error("Can't use matmul on the given tensors");let u=c[c.length-1],i=Math.ceil(u/2),d=c.length,h=n.length,m=j(t.session.backend.glContext.version),b=re(a.length),x=a.length,E=$e(),{activationFunction:w,applyActivation:S}=yr(s),$=p?`${$p(b,E,o[2].dims,a,!0)}`:"",F=e?`${ag(b,E,o,a)}`:"",bt=e?"getAAtOutCoordsMatmul(i)":`getA(${sg(E,d)})`,pt=e?"getBAtOutCoordsMatmul(i)":`getB(${ug(E,h)})`,Z=e?"":`${b} rc =
          getOutputCoords(); int lastDim = rc.${E[x-1]}; rc.${E[x-1]} =
          rc.${E[x-2]}; rc.${E[x-2]} = lastDim;
      `,Le=`
            ${F}
            ${$}
            ${w}
            void main() {
              ${Z}

              vec4 value = vec4(0);
              for (int i = 0; i < ${i}; i++) {
                vec4 a = ${bt};
                vec4 b = ${pt};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${l}
              ${S}
              ${m.output} = value;
            }`;return{...r,output:{dims:a,type:o[0].type,textureType:2},shaderSource:Le,hasMain:!0}},Yo=(t,r,o)=>{let s=es(r.length>2,o.activationCacheKey);return{...s,get:()=>rs(t,s,r,o)}}}),Cp,lg=I(()=>{"use strict";Qo(),og(),Fp(),Cp=(t,r,o)=>{let s=r[0].dims,p=r[1].dims,l=lr(s,p,o.dilations,o.pads,o.strides),c=t.run(Pp(t,r[0],r[1],l,o),[r[0]]),n=t.reshapePacked(r[1],[p[0],p[1]*p[2]*p[3]]),a=r.length===3?[n,c,r[2]]:[n,c],e=t.run(Yo(t,a,o),a);return t.reshapePacked(e,l)}}),ns,os,Lp,Eo,Rp=I(()=>{"use strict";V(),ns=t=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:t}),os=(t,r,o,s,p,l)=>{let c=o.dims,n=s.dims,a=p.length,e=Eo(c,n,p,4),u=`
        const int XC = ${c[1]};
        const int XH = ${c[2]};
        const int XW = ${c[3]};
        const int KH = ${l.kernelShape[0]};
        const int KW = ${l.kernelShape[1]};
        const int dilationH = ${l.dilations[0]};
        const int dilationW = ${l.dilations[1]};
        const int strideH = ${l.strides[0]};
        const int strideW = ${l.strides[1]};
        const int padH = ${l.pads[0]};
        const int padW = ${l.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${a}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${c.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...r,output:{dims:e,type:o.type,textureType:4},shaderSource:u}},Lp=(t,r,o,s,p)=>{let l=ns(p.cacheKey);return{...l,get:()=>os(t,l,r,o,s,p)}},Eo=(t,r,o,s=4)=>[o[0],o[2],o[3],Math.ceil(t[1]*r[2]*r[3]/s)]}),is,as,Bp,pg=I(()=>{"use strict";U(),Y(),V(),Fe(),Rp(),is=(t,r)=>({name:"ConvDotProduct",inputNames:t?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:t?[0,4,0]:[0,4],cacheKey:r.activationCacheKey}),as=(t,r,o,s,p)=>{let l=o[0].dims,c=o[1].dims,n=[c[0],Math.ceil(l[1]*c[2]*c[3]/4)],a=Eo(l,c,s),[e,u]=t.calculateTextureWidthAndHeight(n,4),i=C.computeStrides(a),[d,h]=t.calculateTextureWidthAndHeight(a,4),m=s.length,b=o.length<3?"0.0":"_B(b)",x=Math.ceil(l[1]*c[2]*c[3]/4),{activationFunction:E,applyActivation:w}=yr(p),S=j(t.session.backend.glContext.version),$=`
${E}
float process(int indices[${m}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${i[0]} + im2col[1] * ${i[1]} + im2col[2] * ${i[2]};
  int kernelOffset = indices[1] * ${n[1]};
  float value = ${b};
  for (int i = 0; i < ${x}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d}, ${h});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${e}, ${u});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${w}
  return value;
}`;return{...r,output:{dims:s,type:o[0].type,textureType:0},shaderSource:$}},Bp=(t,r,o,s)=>{let p=is(r.length>2,s);return{...p,get:()=>as(t,p,r,o,s)}}}),lr,Io,ss,us,ls,ps,Po,cs,Qo=I(()=>{"use strict";lt(),U(),ng(),lg(),pg(),Fe(),Rp(),Jo(),lr=(t,r,o,s,p)=>{let l=t[0],c=t.slice(2),n=c.length,a=r[0],e=r.slice(2).map((i,d)=>i+(i-1)*(o[d]-1)),u=c.map((i,d)=>i+s[d]+s[d+n]).map((i,d)=>Math.floor((i-e[d]+p[d])/p[d]));return[l,a].concat(...u)},Io=(t,r,o)=>(cs(r,o),ss(t,r,o)),ss=(t,r,o)=>{let s=ps(o,r),p=t.session.pack,l=s.kernelShape[0]===1&&s.kernelShape[1]===1;return s.group>1?[t.run(Ip(t,r,s),r)]:l&&p?[us(t,r,s)]:p&&r[0].dims.length===4&&r[0].dims[0]===1&&!l?[Cp(t,r,s)]:[ls(t,r,s)]},us=(t,r,o)=>{let s=r[0].dims,p=r[1].dims,l=lr(s,p,o.dilations,o.pads,o.strides),c=t.reshapeUnpacked(r[0],[s[1],s[2]*s[3]]),n=t.reshapeUnpacked(r[1],[p[0],p[1]]),a=r.length>2?[n,c,r[2]]:[n,c],e=t.run(Ap(a,o),a);return t.reshapeUnpacked(e,l)},ls=(t,r,o)=>{let s=r[0].dims,p=r[1].dims,l=lr(s,p,o.dilations,o.pads,o.strides),c=t.run(Lp(t,r[0],r[1],l,o),[r[0]]),n=r.length===3?[c,r[1],r[2]]:[c,r[1]];return t.run(Bp(t,r,l,o),n)},ps=(t,r)=>{let o=t.kernelShape.slice();if(t.kernelShape.length===0)for(let l=2;l<r[1].dims.length;++l)o.push(r[1].dims[l]);let s=t.pads.slice();Hr.adjustPadsBasedOnAutoPad(r[0].dims,t.strides,t.dilations,o,s,t.autoPad);let p=Object.assign({},t);return Object.assign(p,{kernelShape:o,pads:s,cacheKey:t.cacheKey}),p},Po=t=>{let r=t.attributes,o=Qr(r),s=r.getString("auto_pad","NOTSET"),p=r.getInts("dilations",[1,1]),l=r.getInt("group",1),c=r.getInts("kernel_shape",[]),n=r.getInts("pads",[0,0,0,0]),a=r.getInts("strides",[1,1]);return X({autoPad:s,dilations:p,group:l,kernelShape:c,pads:n,strides:a,...o})},cs=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4||t[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let o=t[0].dims[1],s=t[1].dims[1]*r.group;if(o!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let p=t[0].dims.length-2;if(r.dilations.length!==p)throw new Error(`dilations should be ${p}D`);if(r.strides.length!==p)throw new Error(`strides should be ${p}D`);if(r.pads.length!==p*2)throw new Error(`pads should be ${p*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(t[0].type!=="float32"||t[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(t.length===3&&t[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),ds,hs,fs,jp,gs,ms,bs,ys,ws,vs,Vp,xs,cg=I(()=>{"use strict";lt(),Y(),V(),Fe(),ds=(t,r,o,s,p,l)=>(t-1)*r+o+(s-1)*p+1-l,hs=(t,r,o,s,p)=>{let l=Math.floor(t/2);r==="SAME_UPPER"?(o[s]=l,o[p]=t-l):r==="SAME_LOWER"&&(o[s]=t-l,o[p]=l)},fs=(t,r,o,s,p,l,c,n)=>{let a=t.length-2,e=n.length===0;for(let u=0;u<a;++u){let i=e?t[u+2]*l[u]:n[u],d=ds(t[u+2],l[u],p[u],r[u],o[u],i);hs(d,s,p,u,u+a),e&&n.push(l[u]*(t[u+2]-1)+c[u]+(r[u]-1)*o[u]+1-p[u]-p[u+a])}},jp=(t,r,o)=>(xs(r,o),gs(t,r,o)),gs=(t,r,o)=>{let s=vs(o,r);return[ws(t,r,s)]},ms=(t,r)=>({name:"ConvTranspose",inputNames:t?["X","W","B"]:["X","W"],inputTypes:t?[0,0,0]:[0,0],cacheHint:r}),bs=(t,r,o,s)=>{let p=r.length>2?"getB(output_channel)":"0.0",l=r[0].dims,c=r[1].dims,n=c[1],a=c[0]/s.group,e=[r[0].dims[0],r[1].dims[1]*s.group,...s.outputShape],u=j(t.session.backend.glContext.version),{activationFunction:i,applyActivation:d}=yr(s),h=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${i}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${n};
    int wOutChannel = output_channel - group_id * ${n};

    float value = ${p};
    for (int inChannelOffset = 0; inChannelOffset < ${a}; inChannelOffset++) {
      int input_channel = group_id * ${a} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${c[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${c[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${s.dilations[0]}, wHOff * ${s.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${l[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${l[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${d}
    ${u.output} = vec4(value, .0, .0, .0);
  }
`;return{...o,output:{dims:e,type:r[0].type,textureType:0},shaderSource:h,hasMain:!0}},ys=(t,r,o)=>{let s=ms(r.length>2,o.cacheKey);return{...s,get:()=>bs(t,r,s,o)}},ws=(t,r,o)=>t.run(ys(t,r,o),r),vs=(t,r)=>{let o=t.kernelShape.slice();if(t.kernelShape.length===0)for(let n=2;n<r[1].dims.length;++n)o.push(r[1].dims[n]);let s=t.pads.slice(),p=t.outputShape.slice(),l=r[0].dims;fs(l,o,t.dilations,t.autoPad,s,t.strides,t.outputPadding,p);let c=Object.assign({},t);return Object.assign(c,{kernelShape:o,pads:s,outputShape:p,cacheKey:t.cacheKey}),c},Vp=t=>{let r=t.attributes,o=Qr(r),s=r.getString("auto_pad","NOTSET"),p=r.getInts("dilations",[1,1]),l=r.getInt("group",1),c=r.getInts("kernel_shape",[]),n=r.getInts("output_padding",[0,0]),a=r.getInts("output_shape",[]),e=r.getInts("pads",[0,0,0,0]),u=r.getInts("strides",[1,1]);return X({autoPad:s,dilations:p,group:l,kernelShape:c,outputPadding:n,outputShape:a,pads:e,strides:u,...o})},xs=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4||t[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let o=t[0].dims[1],s=t[1].dims[0];if(o!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let p=t[1].dims[1]*r.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==p))throw new Error("invalid bias");let l=t[0].dims.length-2;if(r.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(r.strides.length!==l)throw new Error(`strides should be ${l}D`);if(r.pads.length!==l*2)throw new Error(`pads should be ${l*2}D`);if(r.outputPadding.length!==l)throw new Error(`output_padding should be ${l}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape");if(t[0].type!=="float32"||t[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(t.length===3&&t[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),Nn,fr,Mp,Ts,kn,_s,Ss,Os,ti=I(()=>{"use strict";lt(),U(),V(),Nn={name:"Transpose",inputNames:["A"],inputTypes:[0]},fr=(t,r,o)=>(Os(r),[t.run({...Nn,cacheHint:o.cacheKey,get:()=>Ts(t,r[0],o.perm)},r)]),Mp=t=>X({perm:t.attributes.getInts("perm",[])}),Ts=(t,r,o)=>{let s=r.dims;o=kn(s,o);let p=_s(s,o),l=s.length,c=`
      ${Ss("perm",o,l)}
      float process(int indices[${l}]) {
        int a[${l}];
        perm(a, indices);
        return _A(a);
      }`;return{...Nn,output:{dims:p,type:r.type,textureType:0},shaderSource:c}},kn=(t,r)=>(r&&r.length!==t.length&&(r=[...t.keys()].reverse()),r),_s=(t,r)=>(r=kn(t,r),C.sortBasedOnPerm(t,r)),Ss=(t,r,o)=>{let s=[];s.push(`void ${t}(out int a[${o}], int src[${o}]) {`);for(let p=0;p<o;++p)s.push(`	a[${r[p]}]=src[${p}];`);return s.push("	}"),s.join(`
`)},Os=t=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("input should be float tensor")}}),zp,Up,Es,dg=I(()=>{"use strict";ti(),zp=(t,r,o)=>{Es(r);let s=o.blocksize,p=s*s,l=o.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],c=o.mode==="DCR"?[r[0].dims[0],s,s,r[0].dims[1]/p,r[0].dims[2],r[0].dims[3]]:[r[0].dims[0],r[0].dims[1]/p,s,s,r[0].dims[2],r[0].dims[3]],n=t.reshapeUnpacked(r[0],c),a={perm:l,cacheKey:`${l}`},[e]=fr(t,[n],a),u=[r[0].dims[0],r[0].dims[1]/p,r[0].dims[2]*s,r[0].dims[3]*s];return[t.reshapeUnpacked(e,u)]},Up=t=>{let r=t.attributes.getInt("blocksize");if(r<1)throw new Error(`blocksize must be >= 1, but got : ${r} for DepthToSpace`);let o=t.attributes.getString("mode","DCR");if(o!=="DCR"&&o!=="CRD")throw new Error(`unrecognized mode: ${o} for DepthToSpace`);return{mode:o,blocksize:r}},Es=t=>{if(t.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);if(t[0].type==="string"||t[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),Gp,Hp,Is,hg=I(()=>{"use strict";U(),Gp=(t,r,o)=>{Is(r,o);let s=C.flattenShape(r[0].dims,o);return[t.reshapeUnpacked(r[0],s)]},Hp=t=>t.attributes.getInt("axis",1),Is=(t,r)=>{if(!t||t.length!==1)throw new Error("Flatten requires 1 input.");let o=t[0].dims.length;if(o===0)throw new Error("scalar tensor is not supported.");if(r<-o||r>o)throw new Error("Invalid axis");if(t[0].type==="string")throw new Error("string tensor is not supported.")}}),wr,tn=I(()=>{"use strict";wr=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),qp,Wp,Ps,As,$s,Ds,fg=I(()=>{"use strict";lt(),tn(),U(),V(),qp=(t,r,o)=>(Ds(r,o.axis),[t.run($s(t,r,o),r)]),Wp=t=>X({axis:t.attributes.getInt("axis",0)}),Ps={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},As=(t,r,o,s)=>{let p=o[0].dims.slice(),l=o[1].dims.slice(),c=new Array(p.length+l.length-1);s=C.normalizeAxis(s,p.length);let n=[];for(let d=0;d<c.length;d++)d<s?(c[d]=p[d],n.push(`inputIdx[${d}] = outputIdx[${d}];`)):d<s+l.length?(c[d]=l[d-s],n.push(`indexDataIdx[${d-s}] = outputIdx[${d}];`)):(c[d]=p[d-l.length+1],n.push(`inputIdx[${d-l.length+1}] = outputIdx[${d}];`));let a=c.length||1,e=p.length,u=l.length||1,i=`
      float process(int outputIdx[${a}]) {
        int inputIdx[${e}];
        int indexDataIdx[${u}];
        indexDataIdx[0] = 0;
        ${n.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${s}] = idx < 0 ? idx + ${p[s]} : idx;
        return _A(inputIdx);
      }`;return{...r,output:{dims:c,type:o[0].type,textureType:0},shaderSource:i}},$s=(t,r,o)=>{let s={...Ps,cacheHint:o.cacheKey};return{...s,get:()=>As(t,s,r,o.axis)}},Ds=(t,r)=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.");let o=t[0].dims.length;if(o<1)throw new Error("Invalid input shape.");if(r<-o||r>o-1)throw new Error("Invalid axis.");if(wr.indexOf(t[0].type)===-1)throw new Error("Invaid input type.");if(t[1].type!=="int32"&&t[1].type!=="int16")throw new Error("Invaid input type.")}}),Ao,Fn,Xp,Kp,Ns,ks,Fs,gg=I(()=>{"use strict";lt(),U(),V(),Ao=(t,r,o)=>(Fs(r,o),[t.run(Ns(r,o),r)]),Fn=(t,r)=>{let o=t.attributes.getInt("transA",0)!==0,s=t.attributes.getInt("transB",0)!==0,p=t.attributes.getFloat("alpha",1),l=t.attributes.getFloat("beta",1);return X({transA:o,transB:s,alpha:p,beta:l,isOptionalC:r})},Xp=t=>Fn(t,!1),Kp=t=>Fn(t,!0),Ns=(t,r)=>{let o={name:"Gemm",inputNames:t.length===3?["A","B","C"]:["A","B"],inputTypes:t.length===3?[0,0,0]:[0,0],key:r.cacheKey};return{...o,get:()=>ks(o,t,r)}},ks=(t,r,o)=>{let s=r[0].dims.slice(),p=r[1].dims.slice(),[l,c]=xl.getShapeOfGemmResult(s,o.transA,p,o.transB,r.length===3?r[2].dims:void 0),n=[l,c];if(!n)throw new Error("Can't use gemm on the given tensors");let a=s[s.length-1],e="";o.transA&&(a=s[0]),o.transA&&o.transB?e="value += _A_T(a) * _B_T(b);":o.transA&&!o.transB?e="value += _A_T(a) * _B(b);":!o.transA&&o.transB?e="value += _A(a) * _B_T(b);":!o.transA&&!o.transB&&(e="value += _A(a) * _B(b);");let u=n.length,i=r.length===3?`int c[${r[2].dims.length}];`:"",d=r.length===3?"bcastIndices_C(indices, c);":"",h=r.length===3?"value += beta * _C(c);":"",m=`
      float process(int indices[${u}]) {
          int a[${u}];
          int b[${u}];
          ${i}

          copyVec(indices, a);
          copyVec(indices, b);
          ${d}

          float value = 0.0;
          for (int k=0; k<${a}; ++k) {
              a[${u-1}] = k;
              b[${u-2}] = k;
              ${e}
          }

          value = value * alpha;
          ${h}
          return value;
      }`;return{...t,output:{dims:n,type:r[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:o.alpha},{name:"beta",type:"float",data:o.beta}],shaderSource:m}},Fs=(t,r)=>{if(!t)throw new Error("Input is missing");if(r.isOptionalC&&(t.length<2||t.length>3))throw new Error("Invaid input shape.");if(!r.isOptionalC&&t.length!==3)throw new Error("Gemm requires 3 inputs");if(t.length===3&&t[2].dims.length!==1&&t[2].dims.length!==2)throw new Error("Invalid input shape of C");if(t[0].type!=="float32"&&t[0].type!=="float64"||t[1].type!=="float32"&&t[1].type!=="float64"||t.length===3&&t[2].type!=="float32"&&t[2].type!=="float64")throw new Error("Invalid input type.");if(t[0].type!==t[1].type||t.length===3&&t[0].type!==t[2].type)throw new Error("Input types are mismatched")}}),Zp,Jp,Cs,Ls,Rs,Bs,js,mg=I(()=>{"use strict";lt(),V(),Zp=(t,r,o)=>(js(r),[t.run(Rs(t,r,o),r)]),Jp=t=>{let r=t.attributes.getFloat("scale"),o=t.attributes.getFloats("bias");return X({scale:r,bias:o})},Cs={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},Ls=(t,r,o,s)=>{let p=o[0].dims.slice(),l=p.length,c=`
      ${Bs(s.bias.length)}
      float process(int indices[${l}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...r,output:{dims:p,type:o[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:s.bias.length,data:s.bias},{name:"scale",type:"float",data:s.scale}],shaderSource:c}},Rs=(t,r,o)=>{let s={...Cs,cacheHint:o.cacheKey};return{...s,get:()=>Ls(t,s,r,o)}},Bs=t=>{let r=[`float getBias(float bias[${t}], int channel) {`];for(let o=0;o<t;++o)o===0?r.push(`	if (channel == ${o}) { return bias[${o}]; }`):o===t-1?r.push(`	else { return bias[${o}]; }`):r.push(`	else if (channel == ${o}) { return bias[${o}]; }`);return r.push("	}"),r.join(`
`)},js=t=>{if(!t||t.length!==1)throw new Error("ImageScaler requires 1 input.");if(t[0].dims.length!==4)throw new Error("Invalid input shape.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type.")}}),Yp,Qp,Cn,Vs,Ms,zs,Us,Gs,Hs,bg=I(()=>{"use strict";Y(),V(),Yp=(t,r,o)=>{Hs(r);let s=t.run(Ms(r[0]),r);return[t.run(Gs(t,r[0],o,s.dims),[r[0],s,r[1],r[2]])]},Qp=t=>t.attributes.getFloat("epsilon",1e-5),Cn={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},Vs=(t,r)=>{let o=r.dims.slice(),s=o[1],p=o[2]*o[3],l=[o[0],s],c=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${o[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${p});
        temp = 0.0;
        for(int a2=0; a2<${o[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${p});

        return v;
      }`;return{...t,output:{dims:l,type:r.type,textureType:4},shaderSource:c}},Ms=t=>({...Cn,get:()=>Vs(Cn,t)}),zs={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},Us=(t,r,o,s,p)=>{let l=j(t.session.backend.glContext.version),[c,n]=t.calculateTextureWidthAndHeight(p,4),[a,e]=[c/4,n],u=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${a}, ${e});
        return ${l.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...r,output:{dims:o.dims,type:o.type,textureType:0},variables:[{name:"epsilon",type:"float",data:s}],shaderSource:u}},Gs=(t,r,o,s)=>{let p={...zs,cacheHint:`${o}`};return{...p,get:()=>Us(t,p,r,o,s)}},Hs=t=>{if(!t||t.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let r=t[0],o=t[1],s=t[2];if(r.dims.length<3||o.dims.length!==1||s.dims.length!==1)throw new Error("Invalid input shape.");if(o.dims[0]!==r.dims[1]||s.dims[0]!==r.dims[1])throw new Error("Input shapes are mismatched.");if(r.type!=="float32"&&r.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||s.type!=="float32"&&s.type!=="float64")throw new Error("Invalid input type.");if(t[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function yg(t,r){let o=t[0].dims[1],s=t[0].dims.length,p=-Math.floor((r.size-1)/2),l=Math.ceil((r.size-1)/2),c=`float(${r.alpha}) / float(${r.size})`,n=`float(${r.bias})`,a=`float(${r.beta})`,e=`
    float process(int indices[${s}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${p}; i <= ${l}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${o}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${n} + ${c} * square_sum, ${a});
    }`;return{...ei,cacheHint:r.cacheKey,output:{dims:t[0].dims,type:t[0].type,textureType:0},shaderSource:e}}function wg(t,r){return{...ei,cacheHint:r.cacheKey,get:()=>yg(t,r)}}var tc,ec,ei,qs,vg=I(()=>{"use strict";lt(),V(),tc=(t,r,o)=>(qs(r),[t.run(wg(r,o),r)]),ec=t=>{let r=t.attributes.getFloat("alpha",1e-4),o=t.attributes.getFloat("beta",.75),s=t.attributes.getFloat("bias",1),p=t.attributes.getInt("size");return X({alpha:r,beta:o,bias:s,size:p})},ei={name:"LRN",inputNames:["X"],inputTypes:[0]},qs=t=>{if(!t||t.length!==1)throw new Error("LRN requires 1 input.");if(t[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(t[0].type!=="float32")throw new Error("input should be float type")}}),Ws,$o,rc,nc,oc,Xs,Ks,Zs,Js,Ys,Qs,tu,eu,xg=I(()=>{"use strict";lt(),U(),Y(),V(),Ws={name:"Pad",inputNames:["A"],inputTypes:[0]},$o=(t,r,o)=>(Zs(r),[t.run({...Ws,cacheHint:o.cacheKey,get:()=>Ks(t,r[0],o)},r)]),rc=t=>{let r=t.attributes.getString("mode","constant"),o=t.attributes.getFloat("value",0),s=t.attributes.getInts("pads");return X({mode:r,value:o,pads:s})},nc=(t,r,o)=>{Js(r);let s=Xs(t,r,o);return $o(t,[r[0]],s)},oc=t=>t.attributes.getString("mode","constant"),Xs=(t,r,o)=>{if(!t.session.isInitializer(r[1].dataId)||r.length>=3&&!t.session.isInitializer(r[2].dataId))throw new Error("dynamic pad attributes are not allowed");let s=Array.from(r[1].integerData),p=r.length>=3?r[2].floatData[0]:0;return X({mode:o,pads:s,value:p})},Ks=(t,r,o)=>{let s=C.padShape(r.dims.slice(),o.pads),p=s.length,l=`
      ${Ys(t,r,o)}
      float process(int[${p}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:s,type:r.type,textureType:0},shaderSource:l}},Zs=t=>{if(!t||t.length!==1)throw new Error("Pad requires 1 input");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type.")},Js=t=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(t[1].type!=="int32")throw new Error("Invalid input type.");if(t.length>=3&&t[2].type==="string")throw new Error("Invalid input type.")},Ys=(t,r,o)=>{let s=j(t.session.backend.glContext.version),[p,l]=t.calculateTextureWidthAndHeight(r.dims,0),c=C.computeStrides(r.dims);switch(o.mode){case"constant":return Qs(s,r.dims,c,p,l,o.pads,o.value);case"reflect":return tu(s,r.dims,c,p,l,o.pads);case"edge":return eu(s,r.dims,c,p,l,o.pads);default:throw new Error("Invalid mode")}},Qs=(t,r,o,s,p,l,c)=>{let n=r.length,a="";for(let e=n-1;e>=0;--e)a+=`
        k = m[${e}] - ${l[e]};
        if (k < 0)  return constant;
        if (k >= ${r[e]}) return constant;
        offset += k * ${o[e]};
        `;return`
      float padA(int m[${n}]) {
        const float constant = float(${c});
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${s}, ${p});
        float value = getColorAsFloat(${t.texture2D}(A, coords));
        return value;
      }
      `},tu=(t,r,o,s,p,l)=>{let c=r.length,n="";for(let a=c-1;a>=0;--a)n+=`
        k = m[${a}] - ${l[a]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(r[a]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${r[a]}) { k = _2n_1 - k; }
        }
        offset += k * ${o[a]};
        `;return`
      float padA(int m[${c}]) {
        int offset = 0;
        int k = 0;
        ${n}
        vec2 coords = offsetToCoords(offset, ${s}, ${p});
        float value = getColorAsFloat(${t.texture2D}(A, coords));
        return value;
      }
      `},eu=(t,r,o,s,p,l)=>{let c=r.length,n="";for(let a=c-1;a>=0;--a)n+=`
        k = m[${a}] - ${l[a]};
        if (k < 0)  k = 0;
        if (k >= ${r[a]}) k = ${r[a]-1};
        offset += k * ${o[a]};
      `;return`
      float padA(int m[${c}]) {
        int offset = 0;
        int k = 0;
        ${n}
        vec2 coords = offsetToCoords(offset, ${s}, ${p});
        float value = getColorAsFloat(${t.texture2D}(A, coords));
        return value;
      }
      `}}),ic,ac,Ln,sc,uc,lc,pc,Rn,Bn,ru,jn,cc,qe,Vn,We,nu,Tg=I(()=>{"use strict";lt(),U(),V(),ic=(t,r,o)=>{qe(r);let s={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:o.cacheKey};return[t.run({...s,get:()=>Ln(r,s,!1,o)},r)]},ac=t=>{let r=t.attributes.getString("auto_pad","NOTSET"),o=t.attributes.getInt("ceil_mode",0),s=t.attributes.getInt("count_include_pad",0)!==0,p=t.attributes.getInts("kernel_shape"),l=t.attributes.getInts("strides",[]),c=t.attributes.getInts("pads",[]);if(o!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return X({autoPad:r,ceilMode:o,countIncludePad:s,kernelShape:p,strides:l,pads:c})},Ln=(t,r,o,s)=>{let[p,l]=Bn(t,s,o),c=C.size(p.kernelShape),n="value += _X(x);",a="";p.countIncludePad?a+=`value /= float(${c});`:a+=`value /= float(${c} - pad);`;let e=`
        ${Vn(t[0].dims,p,n,a,"0.0")}
      `;return{...r,output:{dims:l,type:t[0].type,textureType:0},shaderSource:e}},sc=(t,r,o)=>{qe(r);let s={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${o.countIncludePad}`};return[t.run({...s,get:()=>Ln(r,s,!0,o)},r)]},uc=t=>{let r=t.attributes.getInt("count_include_pad",0)!==0;return X({autoPad:"",ceilMode:0,countIncludePad:r,kernelShape:[],strides:[],pads:[]})},lc=(t,r,o)=>{qe(r);let s={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:o.cacheKey};return[t.run({...s,get:()=>Rn(r,s,!1,o)},r)]},pc=t=>{let r=t.attributes.getString("auto_pad","NOTSET"),o=t.attributes.getInt("ceil_mode",0),s=t.attributes.getInts("kernel_shape"),p=t.attributes.getInts("strides",[]),l=t.attributes.getInts("pads",[]),c=t.attributes.getInt("storage_order",0),n=t.attributes.getInts("dilations",[]);if(c!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return X({autoPad:r,ceilMode:o,countIncludePad:!1,kernelShape:s,strides:p,pads:l,storageOrder:c,dilations:n})},Rn=(t,r,o,s)=>{let[p,l]=Bn(t,s,o),c=`
      value = max(_X(x), value);
    `,n="",a=`
      ${Vn(t[0].dims,p,c,n,"-1e5")}
    `;return{...r,output:{dims:l,type:t[0].type,textureType:0},shaderSource:a}},Bn=(t,r,o)=>{let s=t[0].dims.slice(),p=Object.hasOwnProperty.call(r,"dilations"),l=r.kernelShape.slice(),c=r.strides.slice(),n=p?r.dilations.slice():[],a=r.pads.slice();Hr.adjustPoolAttributes(o,s,l,c,n,a);let e=Hr.computePoolOutputShape(o,s,c,n,l,a,r.autoPad),u=Object.assign({},r);return p?Object.assign(u,{kernelShape:l,strides:c,pads:a,dilations:n,cacheKey:r.cacheKey}):Object.assign(u,{kernelShape:l,strides:c,pads:a,cacheKey:r.cacheKey}),[u,e]},ru={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},jn={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},cc=(t,r)=>(qe(r),[t.run({...jn,get:()=>Rn(r,jn,!0,ru)},r)]),qe=t=>{if(!t||t.length!==1)throw new Error("Pool ops requires 1 input.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type.")},Vn=(t,r,o,s,p)=>{let l=t.length;if(r.kernelShape.length<=2){let c=r.kernelShape[r.kernelShape.length-1],n=r.strides[r.strides.length-1],a=r.pads[r.pads.length/2-1],e=r.pads[r.pads.length-1],u=t[l-1],i="",d="",h="";if(a+e!==0?i=`
          for (int i = 0; i < ${c}; i++) {
            x[${l} - 1] = indices[${l} - 1] * ${n} - ${a} + i;
            if (x[${l} - 1] < 0 || x[${l} - 1] >= ${u}) {
              pad++;
              continue;
            }
            ${o}
          }`:i=`
          for (int i = 0; i < ${c}; i++) {
            x[${l} - 1] = indices[${l} - 1] * ${n} - ${a} + i;
            ${o}
          }`,r.kernelShape.length===2){let m=r.kernelShape[r.kernelShape.length-2],b=r.strides[r.strides.length-2],x=r.pads[r.pads.length/2-2],E=r.pads[r.pads.length-2],w=t[l-2];x+E!==0?d=`
            for (int j = 0; j < ${m}; j++) {
              x[${l} - 2] = indices[${l} - 2] * ${b} - ${x} + j;
              if (x[${l} - 2] < 0 || x[${l} - 2] >= ${w}) {
                pad+= ${c};
                continue;
              }
          `:d=`
            for (int j = 0; j < ${m}; j++) {
              x[${l} - 2] = indices[${l} - 2] * ${b} - ${x} + j;
            `,h=`
          }
        `}return`
        float process(int indices[${l}]) {
          int x[${l}];
          copyVec(indices, x);

          float value = ${p};
          int pad = 0;
          ${d}
          ${i}
          ${h}
          ${s}
          return value;
        }
      `}else{let c=C.size(r.kernelShape),n=C.computeStrides(r.kernelShape),a=n.length,e=r.pads.length,u=nu(a),i=We(t,"inputDims"),d=We(r.pads,"pads"),h=We(n,"kernelStrides"),m=We(r.strides,"strides"),b=r.pads.reduce((E,w)=>E+w),x="";return b?x=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${o}
          }`:x=`
          }
          ${o}
        `,`
        ${u}
        float process(int indices[${l}]) {
          int x[${l}];
          copyVec(indices, x);
          int offset[${a}];
          int pads[${e}];
          int inputDims[${l}];
          int kernelStrides[${a}];
          int strides[${a}];
          ${d}
          ${i}
          ${m}
          ${h}

          float value = ${p};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${c}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${l} - ${a}; j < ${l}; j++) {
              x[j] = indices[j] * strides[j - ${l} + ${a}]
                + offset[j - ${l} + ${a}] - pads[j - 2];
              ${x}
          }
          ${s}

          return value;
        }
      `}},We=(t,r)=>{let o="";for(let s=0;s<t.length;s++)o+=`
      ${r}[${s}] = ${t[s]};
    `;return o},nu=t=>`
  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {
    if (${t} == 0) {
      return;
    }
    for (int i = 0; i < ${t} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${t} - 1] = offset;
  }`}),Jt,te,ou,iu,dc,hc,fc,gc,mc,bc,yc,_g=I(()=>{"use strict";lt(),tn(),U(),V(),Jt=(t,r,o,s,p)=>{iu(r);let l={name:s,inputNames:["A"],inputTypes:[0]};return[t.run({...l,cacheHint:o.cacheKey,get:()=>ou(t,r,o,s,p,l)},r)]},te=t=>{let r=t.attributes.getInts("axes",[]),o=t.attributes.getInt("keepdims",1)===1;return X({axes:r,keepDims:o})},ou=(t,r,o,s,p,l)=>{let c=[],n=r[0].dims.length||1,a=[],e=C.normalizeAxes(o.axes,r[0].dims.length),u=p(r,e),i=u[1];for(let h=0;h<r[0].dims.length;h++)e.indexOf(h)>=0||e.length===0?(o.keepDims&&c.push(1),i=`
          for(int j${h} = 0; j${h} < ${r[0].dims[h]}; j${h}++) {
            inputIdx[${h}] = j${h};
            ${i}
          }`):(a.push(`inputIdx[${h}] = outputIdx[${c.length}];`),c.push(r[0].dims[h]));let d=`
      float process(int outputIdx[${c.length||1}]) {
        float value;                 // final result
        int inputIdx[${n}];      // addressing input data
        ${a.join(`
`)}
        ${u[0]}       // init ops for reduce max/min
        ${i}
        ${u[2]}       // final computation for reduce mean
        return value;
      }`;return{...l,output:{dims:c,type:r[0].type,textureType:0},shaderSource:d}},iu=t=>{if(!t||t.length!==1)throw new Error("Reduce op requires 1 input.");if(wr.indexOf(t[0].type)===-1)throw new Error("Invalid input type.")},dc=(t,r,o)=>Jt(t,r,o,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),hc=(t,r,o)=>Jt(t,r,o,"ReduceMean",(s,p)=>{let l=1;for(let c=0;c<s[0].dims.length;c++)(p.indexOf(c)>=0||p.length===0)&&(l*=s[0].dims[c]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${l}.;`]}),fc=(t,r,o)=>Jt(t,r,o,"ReduceMax",(s,p)=>{let l=[];for(let c=0;c<s[0].dims.length;c++)(p.indexOf(c)>=0||p.length===0)&&l.push(`inputIdx[${c}] = 0;`);return[`${l.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),gc=(t,r,o)=>Jt(t,r,o,"ReduceMin",(s,p)=>{let l=[];for(let c=0;c<s[0].dims.length;c++)(p.indexOf(c)>=0||p.length===0)&&l.push(`inputIdx[${c}] = 0;`);return[`${l.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),mc=(t,r,o)=>Jt(t,r,o,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),bc=(t,r,o)=>Jt(t,r,o,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),yc=(t,r,o)=>Jt(t,r,o,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),wc,Sg=I(()=>{"use strict";U(),wc=(t,r)=>{let o=C.calculateReshapedDims(r[0].dims,r[1].integerData);return t.session.pack?[t.reshapePacked(r[0],o)]:[t.reshapeUnpacked(r[0],o)]}}),Mn,Do,vc,xc,pr,au,No,Wr,Tc=I(()=>{"use strict";lt(),Y(),V(),Mn={name:"Upsample",inputNames:["X"],inputTypes:[0]},Do=(t,r,o)=>(No(r,o),[t.run({...Mn,cacheHint:o.cacheKey,get:()=>au(t,r,o)},r)]),vc=t=>pr(t,7),xc=t=>pr(t,9),pr=(t,r)=>{let o=r>=10,s=t.attributes.getString("mode","nearest");if(s!=="nearest"&&s!=="linear"&&(r<11||s!=="cubic"))throw new Error(`unrecognized mode: ${s}`);let p=[];r<9&&(p=t.attributes.getFloats("scales"),Wr(p,s,o));let l=t.attributes.getFloat("extrapolation_value",0),c=r>10?t.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(c)===-1)throw new Error(`coordinate_transform_mode '${c}' is not supported`);let n=c==="tf_crop_and_resize",a=n,e=s==="nearest"&&r>=11?t.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(e)===-1)throw new Error(`nearest_mode '${e}' is not supported`);let u=t.attributes.getFloat("cubic_coeff_a",-.75),i=t.attributes.getInt("exclude_outside",0)!==0;if(i&&s!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let d=r<11?!0:s==="nearest"&&c==="asymmetric"&&e==="floor",h=0,m=0,b=0;return r>10?t.inputs.length>2?(h=1,m=2,b=3):(m=1,b=2):r===9&&(m=1),X({opset:r,isResize:o,mode:s,scales:p,extrapolationValue:l,coordinateTransformMode:c,useExtrapolation:a,needRoiInput:n,nearestMode:e,cubicCoefficientA:u,excludeOutside:i,useNearest2xOptimization:d,roiInputIdx:h,scalesInputIdx:m,sizesInputIdx:b})},au=(t,r,o)=>{let s=j(t.session.backend.glContext.version),[p,l]=t.calculateTextureWidthAndHeight(r[0].dims,0),c=r[0].dims.map((b,x)=>Math.floor(b*o.scales[x])),[n,a]=t.calculateTextureWidthAndHeight(c,0),e=c.length,u=new Array(e),i=new Array(e),d=`
      int output_pitches[${e}];
      int input_pitches[${e}];
      `;for(let b=e-1;b>=0;b--)u[b]=b===e-1?1:u[b+1]*c[b+1],i[b]=b===e-1?1:i[b+1]*r[0].dims[b+1],d+=`
        output_pitches[${b}] = ${u[b]};
        input_pitches[${b}] = ${i[b]};
        `;let h=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${p}, ${l});
        float value = getColorAsFloat(${s.texture2D}(X, coords));
        return value;
      }
      `,m=o.mode==="nearest"?`
    ${h}
    float process(int indices[${e}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${n}, ${a});

      ${d}

      int d, m;
      for (int dim = 0; dim < ${e}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:e===4?`
    ${h}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${n}, ${a});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${r[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${h}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${n}, ${a});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${r[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...Mn,output:{dims:c,type:r[0].type,textureType:0},shaderSource:m,variables:[{name:"scales",type:"int",arrayLength:o.scales.length,data:o.scales.map(b=>Math.ceil(b))}]}},No=(t,r)=>{if(!t||r.opset<9&&t.length!==1||r.opset>=9&&r.opset<11&&t.length!==2||r.opset>=11&&t.length<2)throw new Error("invalid inputs.");if(r.scales.length>0&&t[0].dims.length!==r.scales.length)throw new Error("Invalid input shape.");if(t[0].type==="string")throw new Error("Invalid input tensor types.")},Wr=(t,r,o)=>{if(o){for(let s of t)if(s<=0)throw new Error("Scale value should be greater than 0.")}else for(let s of t)if(s<1)throw new Error("Scale value should be greater than or equal to 1.");if((r==="linear"||r==="cubic")&&t.length!==2&&(t.length!==4||t[0]!==1||t[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?"Resize":"Upsample"} opeartor.`)}}),Cr,ko,_c,Sc,su,uu,lu,pu,Og=I(()=>{"use strict";Y(),V(),qt(),Ne(),Tc(),Cr={name:"Resize",inputNames:["A"],inputTypes:[2]},ko=(t,r,o)=>(No(r,o),[t.run({...Cr,cacheHint:o.cacheKey,get:()=>su(t,r,o)},r)]),_c=t=>pr(t,10),Sc=t=>pr(t,11),su=(t,r,o)=>{let s=j(t.session.backend.glContext.version),[p,l]=uu(r,o);if(p.every(w=>w===1)&&o.coordinateTransformMode!=="tf_crop_and_resize")return{...Cr,output:{dims:l,type:r[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${s.texture2D}(X, TexCoords);
                    ${s.output} = v;
                }`};let c=l.length;if(c<2)throw new Error(`output dimension should be at least 2, but got ${c}`);let n=l[c-2],a=l[c-1],e=r[0].dims;if(c!==e.length)throw new Error(`output dimension should match input ${e.length}, but got ${c}`);let u=e[c-2],i=e[c-1],d=p[c-2],h=p[c-1],m="";if(o.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${o.mode}'`);switch(o.coordinateTransformMode){case"asymmetric":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${a}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${n}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${a}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${n}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${a}.0 - 1.0, ${n}.0 - 1.0, ${a}.0 - 1.0,
                            ${n}.0 - 1.0);
                        vec4 original = vec4(${i}.0 - 1.0, ${u}.0 - 1.0, ${i}.0 - 1.0,
                            ${u}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o.coordinateTransformMode}'`)}let b=re(c),x=br(),E=`
            const vec2 inputWH = vec2(${u}.0, ${i}.0);
            const vec4 scaleWHWH = vec4(float(${d}), float(${h}), float(${d}), float(${h}));
            ${x}
            ${m}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${b} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${n-1};
                bool hasNextCol = rc.z < ${a-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s.output} = vec4(newValue);
            }
        `;return{...Cr,output:{dims:l,type:r[0].type,textureType:2},hasMain:!0,shaderSource:E}},uu=(t,r)=>{let o=t[0].dims,s=r.scales,p;if(s.length===0){let c=t[r.scalesInputIdx];if(c&&c.size!==0){if(t[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");s=lu(c,r.mode,r.isResize)}else{let n=t[r.sizesInputIdx];if(!n||n.size===0)throw new Error("Either scales or sizes MUST be provided as input.");p=Array.from(n.integerData),s=pu(p,o,r.mode,r.isResize)}}else if(t[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let l=p||o.map((c,n)=>Math.floor(c*s[n]));return[s,l]},lu=(t,r,o)=>{let s=Array.from(t.floatData);return Wr(s,r,o),s},pu=(t,r,o,s)=>{let p=r.length,l=new Array(p);for(let c=0,n=p;c<n;c++)if(r[c]===0){if(t[c]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");l[c]=1}else l[c]=t[c]/r[c];return Wr(l,o,s),l}}),Oc,cu,Eg=I(()=>{"use strict";De(),Oc=(t,r)=>(cu(r),[new Pt([r[0].dims.length],"int32",void 0,void 0,new Int32Array(r[0].dims))]),cu=t=>{if(!t||t.length!==1)throw new Error("Shape requires 1 input.")}}),Lr,Ec,Ic,zn,du,Pc,hu,fu,Ig=I(()=>{"use strict";lt(),tn(),U(),V(),Lr={name:"Slice",inputNames:["A"],inputTypes:[0]},Ec=(t,r,o)=>(du(r),[t.run({...Lr,cacheHint:o.cacheKey,get:()=>zn(t,r[0],o)},r)]),Ic=t=>{let r=t.attributes.getInts("starts"),o=t.attributes.getInts("ends"),s=t.attributes.getInts("axes",[]);return X({starts:r,ends:o,axes:s})},zn=(t,r,o)=>{let s=o.axes.length===0?r.dims.slice(0).map((u,i)=>i):o.axes,p=C.normalizeAxes(s,r.dims.length),l=o.starts.map((u,i)=>u>r.dims[p[i]]-1?r.dims[p[i]]:C.normalizeAxis(u,r.dims[p[i]])),c=o.ends.map((u,i)=>u>r.dims[p[i]]-1?r.dims[p[i]]:C.normalizeAxis(u,r.dims[p[i]])),n=r.dims.slice(),a=[];for(let u=0;u<p.length;u++)n[p[u]]=c[u]-l[u],l[u]>0&&a.push(`outputIdx[${p[u]}] += ${l[u]};`);let e=`
      float process(int outputIdx[${n.length}]) {
        ${a.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Lr,output:{dims:n,type:r.type,textureType:0},shaderSource:e}},du=t=>{if(!t||t.length!==1)throw new Error("Slice requires 1 input.");if(wr.indexOf(t[0].type)===-1)throw new Error("Invalid input type.")},Pc=(t,r)=>{fu(r);let o=hu(t,r);return[t.run({...Lr,cacheHint:o.cacheKey,get:()=>zn(t,r[0],o)},[r[0]])]},hu=(t,r)=>{if(!t.session.isInitializer(r[1].dataId)||!t.session.isInitializer(r[2].dataId)||r.length>=4&&!t.session.isInitializer(r[3].dataId)||r.length>=5&&!t.session.isInitializer(r[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(r.length>=5&&r[4].integerData.some(c=>c!==1))throw new Error("currently non-1 steps is not supported for Slice");let o=Array.from(r[1].integerData),s=Array.from(r[2].integerData),p=r.length>=4?Array.from(r[3].integerData):[],l=`${p};${o};${s}`;return{starts:o,ends:s,axes:p,cacheKey:l}},fu=t=>{if(!t||t.length<3||t.length>5)throw new Error("Invalid input number.");if(t[1].type!=="int32"||t[1].dims.length!==1)throw new Error("Invalid input type.");if(t[2].type!=="int32"||t[2].dims.length!==1)throw new Error("Invalid input type.");if(t.length>=4&&(t[3].type!=="int32"||t[3].dims.length!==1))throw new Error("Invalid input type.");if(t.length>=5&&(t[4].type!=="int32"||t[4].dims.length!==1))throw new Error("Invalid input type.")}}),Un,Gn,Hn,Ac,$c,Dc,Nc,qn,gu,mu,bu,Wn,Pg=I(()=>{"use strict";lt(),U(),Y(),V(),ti(),Un={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Gn={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Hn={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Ac=(t,r,o)=>{Wn(r);let s=r[0].dims.slice(),p=C.normalizeAxis(o.axis,s.length),l=C.sizeToDimension(s,p),c=C.sizeFromDimension(s,p);return qn(t,r,o,l,c)},$c=t=>X({axis:t.attributes.getInt("axis",1)}),Dc=t=>X({axis:t.attributes.getInt("axis",-1)}),Nc=(t,r,o)=>{Wn(r);let s=r[0].dims.slice(),p=C.normalizeAxis(o.axis,s.length),l=s.length,c=p!==l-1,n=[],a=[],e=[],u;c&&(a=Array.from({length:l}).map((m,b)=>b),a[p]=l-1,a[l-1]=p,a.map(m=>n.push(s[m])),u=X({perm:a}),e=fr(t,r,u));let i=c?C.sizeToDimension(n,l-1):C.sizeToDimension(s,l-1),d=c?C.sizeFromDimension(n,l-1):C.sizeFromDimension(s,l-1),h=qn(t,c?e:r,o,i,d);return c?fr(t,h,u):h},qn=(t,r,o,s,p)=>{let l=gu(t,r[0],s,p,[s]),c=t.run({...Un,cacheHint:o.cacheKey,get:()=>l},r),n=mu(t,r[0],s,p,l.output.dims,[s]),a=t.run({...Gn,cacheHint:o.cacheKey,get:()=>n},[r[0],c]),e=bu(t,r[0],s,p,l.output.dims,n.output.dims);return[t.run({...Hn,cacheHint:o.cacheKey,get:()=>e},[r[0],c,a])]},gu=(t,r,o,s,p)=>{let[l,c]=t.calculateTextureWidthAndHeight(r.dims,0),n=p.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(p.length!==1)throw new Error("Dimensionality of the output should be 1");if(p[0]!==o)throw new Error("Shape of the output should be equal to logical row count");let a=j(t.session.backend.glContext.version),e=`
      float process(int[${n}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float max = getColorAsFloat(${a.texture2D}(A, offsetToCoords(logical_row_start_offset, ${l},
        ${c} )));
        for(int i=1; i<${s}; ++i)
        {
          float current = getColorAsFloat(${a.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${l}, ${c})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Un,output:{dims:p,type:r.type,textureType:0},shaderSource:e}},mu=(t,r,o,s,p,l)=>{let[c,n]=t.calculateTextureWidthAndHeight(r.dims,0),a=l.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(l.length!==1)throw new Error("Dimensionality of the output should be 1");if(l[0]!==o)throw new Error("Shape of the output should be equal to logical row count");if(p.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(p[0]!==o)throw new Error("Shape of the intermediate results should be equal to logical row count");let e=j(t.session.backend.glContext.version),u=`
      float process(int[${a}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${s}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${e.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${c}, ${n}))) - max);
        }

        return norm_factor;
      }`;return{...Gn,output:{dims:l,type:r.type,textureType:0},shaderSource:u}},bu=(t,r,o,s,p,l)=>{let[c,n]=t.calculateTextureWidthAndHeight(r.dims,0),a=r.dims.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(p.length!==1||l.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(p[0]!==o||l[0]!==o)throw new Error("Shape of the intermediate results should be equal to logical row count");let e=`
      float process(int[${a}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${c}, ${n});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${s};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Hn,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:e}},Wn=t=>{if(!t||t.length!==1)throw new Error("Softmax requires 1 input.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type")}}),Xn,kc,Fc,yu,wu,vu,Ag=I(()=>{"use strict";lt(),U(),V(),Xn={name:"Split",inputNames:["A"],inputTypes:[0]},kc=(t,r,o)=>{vu(r);let s=C.normalizeAxis(o.axis,r[0].dims.length),p=yu(t,r,s,o),l=[];for(let c=0;c<p;++c)l.push(t.run({...Xn,cacheHint:`${o.cacheKey};${c}`,get:()=>wu(t,r[0],o,s,c)},r));return l},Fc=t=>{let r=t.attributes.getInt("axis",0),o=t.attributes.getInts("split",[]),s=t.outputs.length;return X({axis:r,split:o,numOutputs:s})},yu=(t,r,o,s)=>{let[,p]=bo.splitShape(r[0].dims,o,s.split,s.numOutputs);return p.length},wu=(t,r,o,s,p)=>{let[l,c]=bo.splitShape(r.dims,s,o.split,o.numOutputs),n=c[p],a=l[p],e=`
      float process(int indices[${a.length}]) {
        indices[${s}] += ${n};
        return _A(indices);
      }
    `;return{...Xn,cacheHint:`${o.cacheKey}:${p}`,output:{dims:a,type:r.type,textureType:0},shaderSource:e}},vu=t=>{if(!t||t.length!==1)throw new Error("Split requires one input.");if(t[0].type!=="int8"&&t[0].type!=="uint8"&&t[0].type!=="int16"&&t[0].type!=="uint16"&&t[0].type!=="int32"&&t[0].type!=="uint32"&&t[0].type!=="float32"&&t[0].type!=="float64"&&t[0].type!=="bool")throw new Error("Invalid input type.")}}),Fo,Cc,Lc,xu,Tu,$g=I(()=>{"use strict";U(),Fo=(t,r,o)=>{xu(r);let s=C.squeezeShape(r[0].dims,o);return[t.reshapeUnpacked(r[0],s)]},Cc=(t,r)=>(Tu(r),Fo(t,[r[0]],Array.from(r[1].integerData))),Lc=t=>t.attributes.getInts("axes"),xu=t=>{if(!t||t.length!==1)throw new Error("Squeeze requires 1 input.");if(t[0].type==="string")throw new Error("invalid input tensor types.")},Tu=t=>{if(!t||t.length!==2)throw new Error("Squeeze requires 2 inputs.");if(t[1].type!=="int32")throw new Error("Invalid input type.")}}),Rc,_u,Su,Dg=I(()=>{"use strict";Y(),V(),Rc=(t,r)=>{Su(r);let o={name:"Sum",inputNames:r.map((s,p)=>`X${p}`),inputTypes:new Array(r.length).fill(0)};return[t.run({...o,get:()=>_u(t,r,o)},r)]},_u=(t,r,o)=>{let s=j(t.session.backend.glContext.version),p=r[0].dims.slice(),l=`
      void main() {
        vec4 result = ${r.map((c,n)=>`${s.texture2D}(X${n},TexCoords)`).join(" + ")};
        ${s.output} = result;
      }
    `;return{...o,output:{dims:p,type:r[0].type,textureType:0},hasMain:!0,shaderSource:l}},Su=t=>{if(!t||t.length===0)throw new Error("Sum requires inputs.");let r=t[0].dims.length;for(let o=1;o<t.length;o++){if(r!==t[o].dims.length)throw new Error("Input shapes are mismatched.");for(let s=0;s<r;s++)if(t[0].dims[s]!==t[o].dims[s])throw new Error("Input shapes are not matched.")}if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("Invalid input type.");for(let o=1;o<t.length;o++)if(t[0].type!==t[o].type)throw new Error("Input types are not matched.")}}),Bc,Ou,Eu,Ng=I(()=>{"use strict";tn(),V(),Bc=(t,r)=>{Eu(r);let o={name:"Tile",inputNames:["A"],inputTypes:[0]};return[t.run({...o,get:()=>Ou(t,r,o)},r)]},Ou=(t,r,o)=>{let s=r[0].dims.slice(),p=new Array(s.length),l=[];for(let a=0;a<s.length;a++)p[a]=s[a]*r[1].numberData[a],l.push(`inputIdx[${a}] = int(mod(float(outputIdx[${a}]), ${s[a]}.));`);let c=p.length,n=`
      float process(int outputIdx[${c}]) {
        int inputIdx[${c}];
        ${l.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...o,output:{dims:p,type:r[0].type,textureType:0},shaderSource:n}},Eu=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 input.");if(t[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(t[1].dims[0]!==t[0].dims.length)throw new Error("Invalid input shape.");if(wr.indexOf(t[0].type)===-1)throw new Error("Invalid input type.");if(t[1].type!=="int32"&&t[1].type!=="int16")throw new Error("Invalid repeat type.")}}),Co,jc,Vc,Iu,Pu,kg=I(()=>{"use strict";U(),Co=(t,r,o)=>{Iu(r);let s=C.unsqueezeShape(r[0].dims,o);return[t.reshapeUnpacked(r[0],s)]},jc=(t,r)=>(Pu(r),Co(t,[r[0]],Array.from(r[1].integerData))),Vc=t=>t.attributes.getInts("axes"),Iu=t=>{if(!t||t.length!==1)throw new Error("Unsqueeze requires 1 input.");if(t[0].type==="string")throw new Error("invalid input tensor types.")},Pu=t=>{if(!t||t.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(t[1].type!=="int32")throw new Error("Invalid input type.")}}),Mc,Fg=I(()=>{"use strict";xf(),Cf(),Lf(),Bf(),Qo(),cg(),dg(),hg(),fg(),gg(),mg(),bg(),vg(),Jo(),xg(),Tg(),_g(),Sg(),Og(),Eg(),Ig(),Pg(),Ag(),$g(),Dg(),Ng(),ti(),Ep(),kg(),Tc(),Mc=[["Abs","","6+",np],["Acos","","7+",op],["Add","","7+",Rl],["And","","7+",Bl],["Asin","","7+",ip],["Atan","","7+",ap],["AveragePool","","7+",ic,ac],["BatchNormalization","","7+",kl,Fl],["Cast","","6+",Kl,Zl],["Ceil","","6+",lp],["Clip","","6-10",So,sp],["Clip","","11+",up],["Concat","","4+",Yl,Ql],["Conv","","1+",Io,Po],["ConvTranspose","","1+",jp,Vp],["Cos","","7+",pp],["Div","","7+",jl],["Dropout","","7+",Oo],["DepthToSpace","","1+",zp,Up],["Equal","","7+",Vl],["Elu","","6+",cp,dp],["Exp","","6+",hp],["Flatten","","1+",Gp,Hp],["Floor","","6+",fp],["FusedConv","com.microsoft","1+",Io,Po],["Gather","","1+",qp,Wp],["Gemm","","7-10",Ao,Xp],["Gemm","","11+",Ao,Kp],["GlobalAveragePool","","1+",sc,uc],["GlobalMaxPool","","1+",cc],["Greater","","7+",Ml],["Identity","","1+",Oo],["ImageScaler","","1+",Zp,Jp],["InstanceNormalization","","6+",Yp,Qp],["LeakyRelu","","6+",gp,mp],["Less","","7+",zl],["LRN","","1+",tc,ec],["Log","","6+",bp],["MatMul","","1+",Dp,Np],["MaxPool","","1+",lc,pc],["Mul","","7+",Ul],["Neg","","6+",yp],["Not","","1+",wp],["Or","","7+",Gl],["Pad","","2-10",$o,rc],["Pad","","11+",nc,oc],["Pow","","7+",Hl],["PRelu","","7+",ql],["ReduceLogSum","","1+",bc,te],["ReduceMax","","1+",fc,te],["ReduceMean","","1+",hc,te],["ReduceMin","","1+",gc,te],["ReduceProd","","1+",mc,te],["ReduceSum","","1-12",dc,te],["ReduceSumSquare","","1+",yc,te],["Relu","","6+",vp],["Reshape","","5+",wc],["Resize","","10",ko,_c],["Resize","","11+",ko,Sc],["Shape","","1+",Oc],["Sigmoid","","6+",xp],["Sin","","7+",Tp],["Slice","","10+",Pc],["Slice","","1-9",Ec,Ic],["Softmax","","1-12",Ac,$c],["Softmax","","13+",Nc,Dc],["Split","","2-12",kc,Fc],["Sqrt","","6+",_p],["Squeeze","","1-12",Fo,Lc],["Squeeze","","13+",Cc],["Sub","","7+",Wl],["Sum","","6+",Rc],["Tan","","7+",Sp],["Tanh","","6+",Op],["Tile","","6+",Bc],["Transpose","","1+",fr,Mp],["Upsample","","7-8",Do,vc],["Upsample","","9",Do,xc],["Unsqueeze","","1-12",Co,Vc],["Unsqueeze","","13+",jc],["Xor","","7+",Xl]]});function Cg(t){let r={},o;for(;(o=Lo.exec(t))!==null;){let s=o[3].split(",").map(p=>{let l=p.trim().split(" ");return l&&l.length===2?{type:l[0],name:l[1]}:null}).filter(p=>p!==null);r[o[2]]={params:s,body:o[4]}}for(let s in r){let p=zc.replace("__FUNC__",s),l=new RegExp(p,"gm");for(;(o=l.exec(t))!==null;){let c=o[1],n=o[2],a=o[3].split(","),e=c?`${c} ${n};`:"",u=r[s].body,i="";r[s].params.forEach((h,m)=>{h&&(i+=`${h.type} ${h.name} = ${a[m]};
`)}),u=`${i}
 ${u}`,u=u.replace("return",`${n} = `);let d=`
      ${e}
      {
        ${u}
      }
      `;t=t.replace(o[0],d)}}return t=t.replace(Lo,""),t}var Lo,zc,Lg=I(()=>{"use strict";Lo=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,zc="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function rr(t,r){let o=[],s=[],p=r!=null&&Array.isArray(r)&&r.length===0,l=r==null||p?null:Rg(r,t).sort(),c=0;for(let n=0;n<t.length;++n){if(l!=null){if(l[c]===n&&t[n]!==1)throw new Error(`Can't squeeze axis ${n} since its dim '${t[n]}' is not 1`);(l[c]==null||l[c]>n)&&t[n]===1&&(o.push(t[n]),s.push(n)),l[c]<=n&&c++}t[n]!==1&&(o.push(t[n]),s.push(n))}return{newShape:o,keptDims:s}}function Rg(t,r){let o=r.length;return t=t==null?r.map((s,p)=>p):[].concat(t),Gr(t.every(s=>s>=-o&&s<o),()=>`All values in axis param must be in range [-${o}, ${o}) but got axis ${t}`),Gr(t.every(Bg),()=>`All values in axis param must be integers but got axis ${t}`),t.map(s=>s<0?o+s:s)}function Bg(t){return t%1===0}function jg(t){if(t.length===0)return 1;let r=t[0];for(let o=1;o<t.length;o++)r*=t[o];return r}function Au(t){let r=Math.ceil(Math.sqrt(t));return[r,Math.ceil(t/r)]}var Uc,Gc=I(()=>{"use strict";Rt(),U(),Uc=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,r){let o=this.computeTexture(t,r);return r&&r.isPacked&&(o[0]/=2,o[1]/=2),r&&r.reverseWH?[o[1],o[0]]:o}computeTexture(t,r){let o=r&&r.isPacked;if(t.length===0)return o?[2,2]:[1,1];let s=this.maxTextureSize;if(r&&r.breakAxis!==void 0){let c=r.breakAxis>=t.length?1:t.slice(r.breakAxis).reduce((a,e)=>a*e),n=r.breakAxis<=0?1:t.slice(0,r.breakAxis).reduce((a,e)=>a*e);if(c>s||n>s)tt.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${r.breakAxis}`);else return[c,n]}let p=t.slice(0);o&&(s=s*2,p=p.map((c,n)=>n>=p.length-2?p[n]%2===0?p[n]:p[n]+1:p[n]),p.length===1&&(p=[2,p[0]])),p.length!==2&&(p=rr(p).newShape);let l=jg(p);return p.length<=1&&l<=s?[1,l]:p.length===2&&p[0]<=s&&p[1]<=s?p:p.length===3&&p[0]*p[1]<=s&&p[2]<=s?[p[0]*p[1],p[2]]:p.length===3&&p[0]<=s&&p[1]*p[2]<=s?[p[0],p[1]*p[2]]:p.length===4&&p[0]*p[1]*p[2]<=s&&p[3]<=s?[p[0]*p[1]*p[2],p[3]]:p.length===4&&p[0]<=s&&p[1]*p[2]*p[3]<=s?[p[0],p[1]*p[2]*p[3]]:o?Au(l/4).map(c=>c*2):Au(l)}}}),Hc,Vg=I(()=>{"use strict";U(),ne(),Y(),Gc(),qt(),Hc=class extends ke{constructor(t){super(t)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let t="offsetToCoords";return{offsetToCoords:new D(`
      vec2 ${t}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let t="coordsToOffset";return{coordsToOffset:new D(`
      int ${t}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let t=this.context.outputTextureLayout;return t.isPacked?this.getPackedOutputSamplingSnippet(t):this.getUnpackedOutputSamplingSnippet(t)}getPackedOutputSamplingSnippet(t){let r=t.unpackedShape,o=[t.width,t.height],s={},p="getOutputCoords";switch(r.length){case 0:s[p]=this.getOutputScalarCoords();break;case 1:s[p]=this.getOutputPacked1DCoords(r,o);break;case 2:s[p]=this.getOutputPacked2DCoords(r,o);break;case 3:s[p]=this.getOutputPacked3DCoords(r,o);break;default:s[p]=this.getOutputPackedNDCoords(r,o)}let l=`
      void setOutput(vec4 val) {
        ${j(this.context.glContext.version).output} = val;
      }
    `,c="floatTextureSetRGBA";return s[c]=new D(l),s}getUnpackedOutputSamplingSnippet(t){let r=t.unpackedShape,o=[t.width,t.height],s={},p="getOutputCoords";switch(r.length){case 0:s[p]=this.getOutputScalarCoords();break;case 1:s[p]=this.getOutputUnpacked1DCoords(r,o);break;case 2:s[p]=this.getOutputUnpacked2DCoords(r,o);break;case 3:s[p]=this.getOutputUnpacked3DCoords(r,o);break;case 4:s[p]=this.getOutputUnpacked4DCoords(r,o);break;case 5:s[p]=this.getOutputUnpacked5DCoords(r,o);break;case 6:s[p]=this.getOutputUnpacked6DCoords(r,o);break;default:throw new Error(`Unsupported output dimensionality: ${r.length}`)}let l=`
        void setOutput(float val) {
          ${j(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,c="floatTextureSetR";return s[c]=new D(l),s}getOutputScalarCoords(){return new D(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(t,r){let o=r,s="";return o[0]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${o[1]}.0);
          }
        `,new D(s)):o[1]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${o[0]}.0);
          }
        `,new D(s)):(s=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${o[0]}, ${o[1]}));
          return 2 * (resTexRC.y * ${o[0]} + resTexRC.x);
        }
      `,new D(s))}getOutputPacked2DCoords(t,r){let o="";if(Qe.arraysEqual(t,r))return o=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${r[0]}, ${r[1]}));
        }
      `,new D(o);let s=r,p=Math.ceil(t[1]/2);return o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));

          int index = resTexRC.y * ${s[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${p}) * 2;
          int c = 2 * (index / ${p});

          return ivec2(r, c);
        }
      `,new D(o)}getOutputPacked3DCoords(t,r){let o=[r[0],r[1]],s=Math.ceil(t[2]/2),p=s*Math.ceil(t[1]/2),l=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          int b = index / ${p};
          index -= b * ${p};

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec3(b, r, c);
        }
      `;return new D(l)}getOutputPackedNDCoords(t,r){let o=[r[0],r[1]],s=Math.ceil(t[t.length-1]/2),p=s*Math.ceil(t[t.length-2]/2),l=p,c="",n="b, r, c";for(let e=2;e<t.length-1;e++)l*=t[t.length-e-1],c=`
      int b${e} = index / ${l};
      index -= b${e} * ${l};
    `+c,n=`b${e}, `+n;let a=`
      ivec${t.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${o[0]}, ${o[1]}));
        int index = resTexRC.y * ${o[0]} + resTexRC.x;

        ${c}

        int b = index / ${p};
        index -= b * ${p};

        // reverse r and c order for packed texture
        int r = imod(index, ${s}) * 2;
        int c = 2 * (index / ${s});

        return ivec${t.length}(${n});
      }
    `;return new D(a)}getOutputUnpacked1DCoords(t,r){let o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          return resTexRC.y * ${r[0]} + resTexRC.x;
        }
      `;return new D(o)}getOutputUnpacked2DCoords(t,r){let o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          int r = index / ${t[1]};
          int c = index - r * ${t[1]};
          return ivec2(r, c);
        }
      `;return new D(o)}getOutputUnpacked3DCoords(t,r){let o="",s=t.length,p=null;s<2&&(p=[]),p=new Array(s-1),p[s-2]=t[s-1];for(let n=s-3;n>=0;--n)p[n]=p[n+1]*t[n+1];let l=["r","c","d"],c=p.map((n,a)=>{let e=`int ${l[a]} = index / ${n}`,u=a===p.length-1?`int ${l[a+1]} = index - ${l[a]} * ${n}`:`index -= ${l[a]} * ${n}`;return`${e}; ${u};`}).join("");return o=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${c}
          return ivec3(r, c, d);
        }
      `,new D(o)}getOutputUnpacked4DCoords(t,r){let o="",s=t.length,p=null;s<2&&(p=[]),p=new Array(s-1),p[s-2]=t[s-1];for(let n=s-3;n>=0;--n)p[n]=p[n+1]*t[n+1];let l=["r","c","d","d2"],c=p.map((n,a)=>{let e=`int ${l[a]} = index / ${n}`,u=a===p.length-1?`int ${l[a+1]} = index - ${l[a]} * ${n}`:`index -= ${l[a]} * ${n}`;return`${e}; ${u};`}).join("");return o=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${c}
          return ivec4(r, c, d, d2);
        }
      `,new D(o)}getOutputUnpacked5DCoords(t,r){let o="",s=t.length,p=null;s<2&&(p=[]),p=new Array(s-1),p[s-2]=t[s-1];for(let n=s-3;n>=0;--n)p[n]=p[n+1]*t[n+1];let l=["r","c","d","d2","d3"],c=p.map((n,a)=>{let e=`int ${l[a]} = index / ${n}`,u=a===p.length-1?`int ${l[a+1]} = index - ${l[a]} * ${n}`:`index -= ${l[a]} * ${n}`;return`${e}; ${u};`}).join("");return o=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${c}
          return ivec5(r, c, d, d2, d3);
        }
      `,new D(o)}getOutputUnpacked6DCoords(t,r){let o="",s=t.length,p=null;s<2&&(p=[]),p=new Array(s-1),p[s-2]=t[s-1];for(let n=s-3;n>=0;--n)p[n]=p[n+1]*t[n+1];let l=["r","c","d","d2","d3","d4"],c=p.map((n,a)=>{let e=`int ${l[a]} = index / ${n}`,u=a===p.length-1?`int ${l[a+1]} = index - ${l[a]} * ${n}`:`index -= ${l[a]} * ${n}`;return`${e}; ${u};`}).join("");return o=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${r[0]}, ${r[1]}));
         int index = resTexRC.y * ${r[0]} + resTexRC.x;
         ${c}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new D(o)}getCommonUtilFuncs(){let t={},r="uvFromFlat";t[r]=new D(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),r="packedUVfrom1D",t[r]=new D(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom2D",t[r]=new D(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom3D",t[r]=new D(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="sampleTexture";let o=j(this.context.glContext.version);return t[r]=new D(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${o.texture2D}(textureSampler, uv).r;
        }`),t}getInputsSamplingSnippets(){let t={},r=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((o,s)=>{let p=this.context.inputTextureLayouts[s],l=In(o);p.isPacked?t[l]=this.getPackedSamplerFromInput(l,o,p):t[l]=this.getUnpackedSamplerFromInput(l,o,p);let c=af(o);p.unpackedShape.length<=r.unpackedShape.length&&(p.isPacked?t[c]=this.getPackedSamplerAtOutputCoords(c,p,r,o):t[c]=this.getUnpackedSamplerAtOutputCoords(c,p,r,o))}),t}getPackedSamplerAtOutputCoords(t,r,o,s){let p=r.unpackedShape,l=o.unpackedShape,c=In(s),n=p.length,a=l.length,e=Mt.getBroadcastDims(p,l),u=re(a),i=a-n,d,h=$e();n===0?d="":a<2&&e.length>=1?d="coords = 0;":d=e.map($=>`coords.${h[$+i]} = 0;`).join(`
`);let m="";a<2&&n>0?m="coords":m=p.map(($,F)=>`coords.${h[F+i]}`).join(", ");let b="return outputValue;",x=C.size(p)===1,E=C.size(l)===1;if(n===1&&!x&&!E)b=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(x&&!E)a===1?b=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:b=`
          return vec4(outputValue.x);
        `;else if(e.length){let $=n-2,F=n-1;e.indexOf($)>-1&&e.indexOf(F)>-1?b="return vec4(outputValue.x);":e.indexOf($)>-1?b="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":e.indexOf(F)>-1&&(b="return vec4(outputValue.xx, outputValue.zz);")}let w=`
        int lastDim = coords.${h[a-1]};
        coords.${h[a-1]} = coords.${h[a-2]};
        coords.${h[a-2]} = lastDim;
      `,S=`
      vec4 ${t}() {
        ${u} coords = getOutputCoords();
        ${w}
        ${d}
        vec4 outputValue = ${c}(${m});
        ${b}
      }
    `;return new D(S,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(t,r,o,s){let p=[o.width,o.height],l=[r.width,r.height],c=r.unpackedShape.length,n=o.unpackedShape.length,a=r.unpackedShape,e=o.unpackedShape,u=In(s);if(c===n&&Qe.arraysEqual(l,p)){let w=`
          float ${t}() {
            return sampleTexture(${s}, TexCoords);
          }
        `;return new D(w,["coordinates.sampleTexture"])}let i=re(n),d=Mt.getBroadcastDims(a,e),h=n-c,m,b=$e();c===0?m="":n<2&&d.length>=1?m="coords = 0;":m=d.map(w=>`coords.${b[w+h]} = 0;`).join(`
`);let x="";n<2&&c>0?x="coords":x=r.unpackedShape.map((w,S)=>`coords.${b[S+h]}`).join(", ");let E=`
        float ${t}() {
          ${i} coords = getOutputCoords();
          ${m}
          return ${u}(${x});
        }
      `;return new D(E,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(t,r,o){switch(o.unpackedShape.length){case 0:return this.getPackedSamplerScalar(t,r);case 1:return this.getPackedSampler1D(t,r,o);case 2:return this.getPackedSampler2D(t,r,o);case 3:return this.getPackedSampler3D(t,r,o);default:return this.getPackedSamplerND(t,r,o)}}getUnpackedSamplerFromInput(t,r,o){let s=o.unpackedShape;switch(s.length){case 0:return this.getUnpackedSamplerScalar(t,r,o);case 1:return this.getUnpackedSampler1D(t,r,o);case 2:return this.getUnpackedSampler2D(t,r,o);case 3:return this.getUnpackedSampler3D(t,r,o);case 4:return this.getUnpackedSampler4D(t,r,o);case 5:return this.getUnpackedSampler5D(t,r,o);case 6:return this.getUnpackedSampler6D(t,r,o);default:throw new Error(`Unsupported dimension ${s.length}-D`)}}getPackedSamplerScalar(t,r){let o=j(this.context.glContext.version),s=`
          vec4 ${t}() {
            return ${o.texture2D}(${r}, halfCR);
          }
        `;return new D(s)}getPackedSampler1D(t,r,o){let s=[o.width,o.height],p=[s[1],s[0]],l=j(this.context.glContext.version),c=`vec4 ${t}(int index) {
      vec2 uv = packedUVfrom1D(
      ${p[0]}, ${p[1]}, index);
      return ${l.texture2D}(${r}, uv);
    }`;return new D(c,["coordinates.packedUVfrom1D"])}getPackedSampler2D(t,r,o){let s=o.unpackedShape,p=[o.width,o.height],l=j(this.context.glContext.version),c=p[0],n=p[1];if(p!=null&&Qe.arraysEqual(s,p)){let i=`vec4 ${t}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${c}.0);
        return ${l.texture2D}(${r}, uv);
      }`;return new D(i)}let a=p,e=Math.ceil(s[1]/2),u=`vec4 ${t}(int row, int col) {
      vec2 uv = packedUVfrom2D(${a[1]}, ${a[0]}, ${e}, row, col);
      return ${l.texture2D}(${r}, uv);
    }`;return new D(u,["coordinates.packedUVfrom2D"])}getPackedSampler3D(t,r,o){let s=o.unpackedShape,p=[o.width,o.height],l=[p[0],p[1]],c=j(this.context.glContext.version);if(s[0]===1){let d=s.slice(1),h=[1,2],m=Ue(s,d),b=["b","row","col"],x=JSON.parse(JSON.stringify(o));x.unpackedShape=m;let E=this.getPackedSamplerFromInput(t,r,x),w=`${E.routineBody}
      vec4 ${t}(int b, int row, int col) {
        return ${t}(${Ge(b,h)});
      } `;return new D(w,E.dependencies)}let n=l[0],a=l[1],e=Math.ceil(s[2]/2),u=e*Math.ceil(s[1]/2),i=`vec4 ${t}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${a}, ${n}, ${u}, ${e}, b, row, col);
      return ${c.texture2D}(${r}, uv);}`;return new D(i,["coordinates.packedUVfrom3D"])}getPackedSamplerND(t,r,o){let s=o.unpackedShape,p=s.length,l=[o.width,o.height],c=j(this.context.glContext.version),n=[l[0],l[1]],a=n[1],e=n[0],u=Math.ceil(s[p-1]/2),i=u*Math.ceil(s[p-2]/2),d="int b, int row, int col",h=`b * ${i} + (row / 2) * ${u} + (col / 2)`;for(let b=2;b<p-1;b++)d=`int b${b}, `+d,i*=s[p-b-1],h=`b${b} * ${i} + `+h;let m=`vec4 ${t}(${d}) {
      int index = ${h};
      int texR = index / ${e};
      int texC = index - texR * ${e};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${e}, ${a});
      return ${c.texture2D}(${r}, uv);
    }`;return new D(m)}getUnpackedSamplerScalar(t,r,o){let[s,p]=[o.width,o.height];if(s===1&&p===1){let c=`
          float ${t}() {
            return sampleTexture(${r}, halfCR);
          }
        `;return new D(c,["coordinates.sampleTexture"])}let l=`
        float ${t}() {
          int offset_${r} = coordsToOffset(TexCoords, ${s}, ${p});
          vec2 uv = uvFromFlat(${s}, ${p}, offset_${r});
          return sampleTexture(${r}, uv);
        }
      `;return new D(l,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(t,r,o){let s=o.width,p=o.height;if(p===1&&s===1){let c=`
        float ${t}(int index) {
          return sampleTexture(${r}, halfCR);
        }
      `;return new D(c,["coordinates.sampleTexture"])}if(p===1){let c=`
          float ${t}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${s}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new D(c,["coordinates.sampleTexture"])}if(s===1){let c=`
          float ${t}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${p}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new D(c,["coordinates.sampleTexture"])}let l=`
        float ${t}(int index) {
          vec2 uv = uvFromFlat(${s}, ${p}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new D(l,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(t,r,o){let s=o.unpackedShape,p=[o.height,o.width];if(p!=null&&Qe.arraysEqual(s,p)){let i=p[1],d=p[0],h=`
          float ${t}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${i}.0, ${d}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new D(h,["coordinates.sampleTexture"])}let{newShape:l,keptDims:c}=rr(s),n=l;if(n.length<s.length){let i=Ue(s,n),d=JSON.parse(JSON.stringify(o));d.unpackedShape=i;let h=["col","row"],m=`
          ${this.getUnpackedSamplerFromInput(t,r,d).routineBody}
          float ${t}(int row, int col) {
            return ${t}(${Ge(h,c)});
          }
        `;return new D(m,["coordinates.sampleTexture"])}let a=p[1],e=p[0];if(e===1){let i=`
          float ${t}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${a}, ${e});
            float index = dot(vec3(row, col, offset_${r}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${a}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new D(i,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(a===1){let i=`
          float ${t}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${a}, ${e});
            float index = dot(vec3(row, col, offset_${r}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${e}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new D(i,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let u=`
        float ${t}(int row, int col) {
          int index = col * ${s[1]} + row;
          vec2 uv = uvFromFlat(${a}, ${e}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new D(u,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(t,r,o){let s=o.unpackedShape,p=s[1]*s[2],l=s[2],{newShape:c,keptDims:n}=rr(s),a=c;if(a.length<s.length){let d=Ue(s,a),h=["batch","col","row"],m=JSON.parse(JSON.stringify(o));m.unpackedShape=d;let b=this.getUnpackedSamplerFromInput(t,r,m),x=n.reverse(),E=`
          ${b.routineBody}
          float ${t}(int batch, int row, int col) {
            return ${t}(${Ge(h,x)});
          }
        `;return new D(E,b.dependencies)}let e=o.width,u=o.height,i=`
          float ${t}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${p} + col * ${l} + row;
            vec2 uv = uvFromFlat(${e}, ${u}, index);
            return sampleTexture(${r}, uv);
          }
      `;return new D(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(t,r,o){let s=o.unpackedShape,p=s[3],l=s[2]*p,c=s[1]*l,n=o.width,a=o.height,e=`
        float ${t}(int row, int col, int depth, int depth2) {
          int index = row * ${c} + col * ${l} +
              depth2 * ${p} + depth;
          vec2 uv = uvFromFlat(${n}, ${a}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new D(e,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(t,r,o){let s=o.unpackedShape,p=s[4],l=s[3]*p,c=s[2]*l,n=s[1]*c,{newShape:a,keptDims:e}=rr(s);if(a.length<s.length){let h=Ue(s,a),m=["row","col","depth","depth2","depth3"],b=JSON.parse(JSON.stringify(o));b.unpackedShape=h;let x=`
          ${this.getUnpackedSamplerFromInput(t,r,b).routineBody}
          float ${t}(int row, int col, int depth, int depth2, int depth3) {
            return ${t}(${Ge(m,e)});
          }
        `;return new D(x,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let u=o.width,i=o.height,d=`
        float ${t}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${n} + col * ${c} + depth * ${l} +
          depth3 * ${p} + depth2;
          vec2 uv = uvFromFlat(${u}, ${i}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new D(d,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(t,r,o){let s=o.unpackedShape,p=s[5],l=s[4]*p,c=s[3]*l,n=s[2]*c,a=s[1]*n,{newShape:e,keptDims:u}=rr(s);if(e.length<s.length){let m=Ue(s,e),b=["row","col","depth","depth2","depth3","depth4"],x=JSON.parse(JSON.stringify(o));x.unpackedShape=m;let E=`
            ${this.getUnpackedSamplerFromInput(t,r,x).routineBody}
            float ${t}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${t}(${Ge(b,u)});
            }
          `;return new D(E,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let i=o.width,d=o.height,h=`
          float ${t}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${a} + col * ${n} + depth * ${c} +
            depth2 * ${l} + depth3 * ${p} + depth4;
            vec2 uv = uvFromFlat(${i}, ${d}, index);
            return sampleTexture(${r}, uv);
          }
        `;return new D(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let t=this.context.outputTextureLayout,r=t.shape.length,o=t.strides,s=t.width,p=t.height,l=[];for(let n=0;n<r-1;++n)l.push(`
        c[${n}] = offset / ${o[n]};`),l.push(`
        offset -= c[${n}] * ${o[n]};`);l.push(`
        c[${r-1}] = offset;`);let c=`
      void toVec(vec2 texCoords, out int c[${r}]) {
        int offset = coordsToOffset(texCoords, ${s}, ${p});
        ${l.join("")}
      }
      void toVec(int offset, out int c[${r}]) {
        ${l.join("")}
      }
    `;return{toVec:new D(c,["coordinates.coordsToOffset"])}}valueFrom(){let t={};return this.context.programInfo.inputNames.forEach((r,o)=>{let s=this.context.inputTextureLayouts[o],p=(s.unpackedShape.length>0?s.unpackedShape:s.shape).length,l=`_${r}`;t[l]=new D(this.getValueFromSingle(r,p,s.width,s.height,!1),[`shapeUtils.indicesToOffset${l}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),l=l+"_T",t[l]=new D(this.getValueFromSingle(r,p,s.width,s.height,!0),[`shapeUtils.indicesToOffset${l}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),t}getValueFromSingle(t,r,o,s,p){let l=`_${t}`;p&&(l=l+"_T");let c=j(this.context.glContext.version);return`
        float ${l}(int m[${r}]) {
          int offset = indicesToOffset${l}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${s});
          float value = getColorAsFloat(${c.texture2D}(${t}, coords));
          return value;
        }
        `}getPackedValueFrom(t,r,o,s,p){let l=`_${t}_Pack`;p&&(l=l+"_T");let c=j(this.context.glContext.version);return`
        vec4 ${l}(int m[${r}]) {
          int offset = indicesToOffset_${t}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${s});
          return ${c.texture2D}(${t}, coords);
        }
        `}}}),qc,Mg=I(()=>{"use strict";ne(),qc=class Ro extends ke{constructor(r){super(r)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new D(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new D(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let r=Ro.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new D(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${r}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let r=Ro.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new D(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${r}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let r=new ArrayBuffer(4),o=new Uint32Array(r),s=new Uint8Array(r);if(o[0]=3735928559,s[0]===239)return!0;if(s[0]===222)return!1;throw new Error("unknown endianness")}}}),Wc,zg=I(()=>{"use strict";ne(),Y(),Wc=class extends ke{constructor(t){super(t)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let t=j(this.context.glContext.version);return{setFragColor:new D(`
        void setFragColor(float value) {
            ${t.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new D(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),Xc,Ug=I(()=>{"use strict";ne(),Xc=class nr extends ke{constructor(r){super(r)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let r=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((s,p)=>{let l=this.context.inputTextureLayouts[p].unpackedShape;if(l.length<=r){let c=l.length,n=r-c,a=`bcastIndices_${s}`,e="";for(let i=0;i<c;++i)e+=`
          realIndices[${i}] = int( mod(float(bcastedIndices[${n+i}]), ${l[i]}.0) );
          `;let u=`
        void ${a} (int bcastedIndices[${r}], out int realIndices[${c}]) {
          ${e}
        }
        `;o[a]=new D(u)}}),o}bcastMatmulIndex(){let r=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((s,p)=>{let l=this.context.inputTextureLayouts[p].shape;if(!(l.length<2||l.length>r)){let c=l.length,n=r-c,a=`bcastMatmulIndices_${s}`,e="";for(let i=0;i<c-2;++i)e+=`
          realIndices[${i}] = int( mod(float(bcastedIndices[${n+i}]), ${l[i]}.0) );
          `;let u=`
        void ${a}(int bcastedIndices[${r}], out int realIndices[${c}]) {
          ${e}
          realIndices[${c-1}] = bcastedIndices[${r-1}];
          realIndices[${c-2}] = bcastedIndices[${r-2}];
        }
        `;o[a]=new D(u)}}),o}indicesToOffset(){let r={};return this.context.programInfo.inputNames.forEach((o,s)=>{let p=this.context.inputTextureLayouts[s].shape,l=this.context.inputTextureLayouts[s].strides,c=p.length,n=`indicesToOffset_${o}`;r[n]=new D(nr.indexToOffsetSingle(n,c,l)),n=`indicesToOffset_${o}_T`,r[n]=new D(nr.indexToOffsetSingle(n,c,l.slice().reverse()))}),r}static indexToOffsetSingle(r,o,s){let p="";for(let l=o-1;l>=0;--l)p+=`
        offset += indices[${l}] * ${s[l]};
        `;return`
      int ${r}(int indices[${o}]) {
        int offset = 0;
        ${p}
        return offset;
      }
      `}offsetToIndices(){let r={};return this.context.programInfo.inputNames.forEach((o,s)=>{let p=this.context.inputTextureLayouts[s].shape,l=this.context.inputTextureLayouts[s].strides,c=p.length,n=`offsetToIndices_${o}`;r[n]=new D(nr.offsetToIndicesSingle(n,c,l)),n=`offsetToIndices_${o}_T`,r[n]=new D(nr.offsetToIndicesSingle(n,c,l.slice().reverse()))}),r}static offsetToIndicesSingle(r,o,s){let p=[];for(let l=0;l<o-1;++l)p.push(`
      indices[${l}] = offset / ${s[l]};`),p.push(`
        offset -= indices[${l}] * ${s[l]};`);return p.push(`
      indices[${o-1}] = offset;`),`
      void ${r}(int offset, out int indices[${o}]) {
        ${p.join("")}
      }
      `}incrementIndices(){let r={};return this.context.programInfo.inputNames.forEach((o,s)=>{let p=this.context.inputTextureLayouts[s].shape,l=p.length,c=`incrementIndices_${o}`,n="";for(let e=0;e<l;++e)n+=`
        shape[${e}] = ${p[e]};`;let a=`
        void ${c}(int axis, out int indices[${l}]) {
          int shape[${l}];
          ${n};
          for(int i = ${l} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;r[c]=new D(a)}),r}}}),Kc,Gg=I(()=>{"use strict";ne(),Kc=class extends ke{constructor(t){super(t)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let t=this.context.outputTextureLayout.shape.length,r={add:"+=",sub:"-=",mul:"*=",div:"/="},o={};for(let s in r){let p=`${s}Vec`,l="";for(let n=0;n<t;++n)l+=`
          dest[${n}] ${r[s]} src[${n}];
          `;let c=`
        void ${p}(int src[${t}], out int dest[${t}]) {
          ${l}
        }
        `;o[p]=new D(c)}return o}copyVec(){let t=this.context.outputTextureLayout.shape.length,r="";for(let s=0;s<t;++s)r+=`
        dest[${s}] = src[${s}];
        `;let o=`
      void copyVec(int src[${t}], out int dest[${t}]) {
        ${r}
      }
      `;return{copyVec:new D(o)}}setVecItem(){let t=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index =${t} + index;
        if (index == 0)
            m[0] = value;
        `;for(let s=1;s<t-1;++s)r+=`
        else if (index == ${s})
            m[${s}] = value;
            `;r+=`
        else
            m[${t-1}] = value;
        `;let o=`
      void setVecItem(out int m[${t}], int index, int value) {
        ${r}
      }
        `;return{setVecItem:new D(o)}}getVecItem(){let t=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index = ${t} + index;
        if (index == 0)
            return m[0];
      `;for(let s=1;s<t-1;++s)r+=`
        else if (index == ${s})
            return m[${s}];
      `;r+=`
        else
            return m[${t-1}];
        `;let o=`
      int getVecItem(int m[${t}], int index) {
        ${r}
      }
    `;return{getVecItem:new D(o)}}}}),Bo,Hg=I(()=>{"use strict";Vg(),Mg(),zg(),Ug(),Gg(),Bo={encoding:qc,fragcolor:Wc,vec:Kc,shapeUtils:Xc,coordinates:Hc}}),Zc,qg=I(()=>{"use strict";ne(),Lg(),Hg(),Y(),Zc=class{constructor(t,r,o,s){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new Cl(t,r,o,s),Object.keys(Bo).forEach(l=>{let c=new Bo[l](this.context);this.libs[l]=c});let p=this.glslLibRoutineDependencyGraph;for(let l in this.libs){let c=this.libs[l].getFunctions();for(let n in c){let a=l+"."+n,e;p[a]?(e=p[a],e.routineBody=c[n].routineBody):(e=new _o(a,c[n].routineBody),p[a]=e);let u=c[n].dependencies;if(u)for(let i=0;i<u.length;++i)if(p[u[i]])e.addDependency(p[u[i]]);else{let d=new _o(u[i]);p[u[i]]=d,e.addDependency(d)}}}}preprocess(){let t=this.context.programInfo,r=t.shaderSource;return this.context.programInfo.hasMain||(r=`${r}
      ${of(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),r=Cg(r),`${nf(this.context.glContext.version)}
    ${this.getUniforms(t.inputNames,t.variables)}
    ${this.getImports(r)}
    ${r}`}getImports(t){let r=this.selectGlslLibRoutinesToBeIncluded(t);if(r.length===0)return"";let o="";for(let s=0;s<r.length;++s)if(r[s].routineBody)o+=r[s].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${r[s].name}`);return o}selectGlslLibRoutinesToBeIncluded(t){let r=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(o=>{let s=o.split(".")[1];t.indexOf(s)!==-1&&r.push(this.glslLibRoutineDependencyGraph[o])}),Ll.returnOrderedNodes(r)}getUniforms(t,r){let o=[];if(t)for(let s of t)o.push(`uniform sampler2D ${s};`);if(r)for(let s of r)o.push(`uniform ${s.type} ${s.name}${s.arrayLength?`[${s.arrayLength}]`:""};`);return o.join(`
`)}}}),Jc,Wg=I(()=>{"use strict";zt(),Rt(),qg(),Y(),Jc=class{constructor(t,r,o){this.profiler=t,this.glContext=r,this.textureLayoutStrategy=o,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o){this.profiler.event("op",`ProgramManager.run ${t.programInfo.name??"unknown kernel"}`,()=>{let s=this.glContext.gl,p=t.program;s.useProgram(p);try{this.bindOutput(o),this.attributesBound||this.bindAttributes(t.attribLocations),this.bindUniforms(t.uniformLocations,t.programInfo.variables??[],r)}catch(l){throw tt.error("ProgramManager",t.programInfo.shaderSource),l}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(t=>this.glContext.deleteProgram(t.program))}build(t,r,o){return this.profiler.event("backend","ProgramManager.build",()=>{let s=new Zc(this.glContext,t,r,o),p=s.preprocess(),l=this.compile(p);return{programInfo:t,program:l,uniformLocations:this.getUniformLocations(l,s.context.programInfo.inputNames,s.context.programInfo.variables),attribLocations:this.getAttribLocations(l)}})}compile(t){if(!this.vertexShader){tt.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let s=rf(this.glContext.version);this.vertexShader=this.glContext.compileShader(s,this.glContext.gl.VERTEX_SHADER)}B.debug&&tt.verbose("ProrgramManager",`FragShader:
${t}
`);let r=this.glContext.compileShader(t,this.glContext.gl.FRAGMENT_SHADER),o=this.glContext.createProgram(this.vertexShader,r);return this.glContext.deleteShader(r),o}bindOutput(t){let r=t.width,o=t.height;tt.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${r}/${o}, shape=${t.shape}, type=${t.tensor.type}`),this.glContext.attachFramebuffer(t.texture,r,o)}bindAttributes(t){let r=t.position,o=t.textureCoord;this.glContext.setVertexAttributes(r,o),this.attributesBound=!0}bindUniforms(t,r,o){let s=this.glContext.gl,p=0;for(let{name:l,type:c,location:n,arrayLength:a}of t){let e=r.find(u=>u.name===l)?.data;if(c!=="sampler2D"&&!e)throw new Error(`variable '${l}' does not have data defined in program info`);switch(c){case"sampler2D":this.bindTexture(o[p],n,p),p++;break;case"float":a?s.uniform1fv(n,e):s.uniform1f(n,e);break;case"int":a?s.uniform1iv(n,e):s.uniform1i(n,e);break;default:throw new Error(`Uniform not implemented: ${c}`)}}}bindTexture(t,r,o){this.glContext.bindTextureToUniform(t.texture,o,r)}getAttribLocations(t){return{position:this.getAttribLocation(t,"position"),textureCoord:this.getAttribLocation(t,"textureCoord")}}getUniformLocations(t,r,o){let s=[];if(r)for(let p of r)s.push({name:p,type:"sampler2D",location:this.getUniformLocation(t,p)});if(o)for(let p of o)s.push({...p,location:this.getUniformLocation(t,p.name)});return s}getUniformLocation(t,r){let o=this.glContext.gl.getUniformLocation(t,r);if(o===null)throw new Error(`Uniform ${r} not found.`);return o}getAttribLocation(t,r){return this.glContext.gl.getAttribLocation(t,r)}}}),Yc,Xg=I(()=>{"use strict";Rt(),qr(),Yc=class{constructor(t,r,o,s){this.glContext=t,this.layoutStrategy=r,this.profiler=o,this.config=s,this.pendingRead=new Map,s.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(t,r,o,s){let p=this.toEncoderType(t),l=this.glContext.getEncoder(p,r.channels||1,s);if(r.isPacked&&s===1)throw new Error("not implemented");let c=r.width,n=r.height,a,e;if(this.config.reuseTextures){a=`${c}x${n}_${l.format}_${l.internalFormat}_${l.textureType}`,e=this.inUseTextures.get(a),e||(e=[],this.inUseTextures.set(a,e));let i=this.idleTextures.get(a);if(i&&i.length>0){let d=i.pop();return e.push(d),s===1&&this.glContext.updateTexture(d,c,n,l,this.toTextureData(t,o)),d}}tt.verbose("TextureManager",`Creating new texture of size ${r.width}x${r.height}`);let u=this.glContext.allocateTexture(c,n,l,this.toTextureData(t,o));return this.config.reuseTextures&&(e.push(u),this.textureLookup.set(u,a)),u}readTexture(t,r,o){return o||(o=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let s=t.shape.reduce((l,c)=>l*c)*o,p=this.glContext.readTexture(t.texture,t.width,t.height,s,this.toEncoderType(r),o);return this.toTensorData(r,p)})}async readTextureAsync(t,r,o){let s=t.tensor.dataId;if(o||(o=1),this.pendingRead.has(s)){let p=this.pendingRead.get(s);return new Promise(l=>p?.push(l))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(s,[]);let p=t.shape.reduce((a,e)=>a*e)*o;await this.glContext.createAndWaitForFence();let l=this.glContext.readTexture(t.texture,t.width,t.height,p,this.toEncoderType(r),o),c=this.toTensorData(r,l),n=this.pendingRead.get(s);return this.pendingRead.delete(s),n?.forEach(a=>a(c)),c})}readUint8TextureAsFloat(t){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let r=t.shape.reduce((s,p)=>s*p),o=this.glContext.readTexture(t.texture,t.width,t.height,r*4,"byte",4);return new Float32Array(o.buffer,o.byteOffset,r)})}releaseTexture(t,r){let o;if(this.config.reuseTextures&&(o=this.textureLookup.get(t.texture),o)){r&&this.textureLookup.delete(o);let s=this.inUseTextures.get(o);if(s){let p=s.indexOf(t.texture);if(p!==-1){s.splice(p,1);let l=this.idleTextures.get(o);l||(l=[],this.idleTextures.set(o,l)),l.push(t.texture)}}}(!o||r)&&(tt.verbose("TextureManager",`Deleting texture of size ${t.width}x${t.height}`),this.glContext.deleteTexture(t.texture))}toTensorData(t,r){switch(t){case"int16":return r instanceof Int16Array?r:Int16Array.from(r);case"int32":return r instanceof Int32Array?r:Int32Array.from(r);case"int8":return r instanceof Int8Array?r:Int8Array.from(r);case"uint16":return r instanceof Uint16Array?r:Uint16Array.from(r);case"uint32":return r instanceof Uint32Array?r:Uint32Array.from(r);case"uint8":case"bool":return r instanceof Uint8Array?r:Uint8Array.from(r);case"float32":return r instanceof Float32Array?r:Float32Array.from(r);case"float64":return r instanceof Float64Array?r:Float64Array.from(r);default:throw new Error(`TensorData type ${t} is not supported`)}}toTextureData(t,r){if(r)return r instanceof Float32Array?r:new Float32Array(r)}toEncoderType(t){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),Qc,Kg=I(()=>{"use strict";Rt(),Rh(),vf(),Fg(),Wg(),Gc(),Xg(),Qc=class{constructor(t,r){this.backend=t,this.context=r,this.layoutStrategy=new Uc(t.glContext.maxTextureSize),this.programManager=new Jc(this.context.profiler,t.glContext,this.layoutStrategy),this.textureManager=new Yc(t.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:t.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=t.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Nl(this)}onGraphInitialized(t){let r=t.getValues().filter(o=>o.from===-1&&o.tensor).map(o=>o.tensor.dataId);this.initializers=new Set(r)}isInitializer(t){return this.initializers?this.initializers.has(t):!1}addInitializer(t){this.initializers.add(t)}getTextureData(t,r){return r?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,r,o=!1){tt.verbose("WebGLSessionHandler","Storing Texture data in cache"),o?this.packedTextureDataCache.set(t,r):this.unpackedTextureDataCache.set(t,r)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(t=>this.textureManager.releaseTexture(t,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(t=>this.textureManager.releaseTexture(t,!0)),this.unpackedTextureDataCache=new Map}resolve(t,r,o){let s=Ch(t,r,Mc);return{impl:s.opImpl,context:s.opInit?s.opInit(t,o):t}}}});function Zg(t){let r=0;for(;r<t.length&&t[r]();++r);return r-1}var jo,Jg=I(()=>{"use strict";zt(),qr(),qr(),qt(),jo=class{constructor(t,r){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=t,this.version=r,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(t,r,o,s){let p=this.gl,l=p.createTexture();p.bindTexture(p.TEXTURE_2D,l),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MIN_FILTER,p.NEAREST),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MAG_FILTER,p.NEAREST),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_S,p.CLAMP_TO_EDGE),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_T,p.CLAMP_TO_EDGE);let c=s?o.encode(s,t*r):null;return p.texImage2D(p.TEXTURE_2D,0,o.internalFormat,t,r,0,o.format,o.textureType,c),this.checkError(),l}updateTexture(t,r,o,s,p){let l=this.gl;l.bindTexture(l.TEXTURE_2D,t);let c=s.encode(p,r*o);l.texSubImage2D(l.TEXTURE_2D,0,0,0,r,o,s.format,s.textureType,c),this.checkError()}attachFramebuffer(t,r,o){let s=this.gl;s.bindTexture(s.TEXTURE_2D,t),s.bindFramebuffer(s.FRAMEBUFFER,this.framebuffer),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,t,0),this.checkError(),s.viewport(0,0,r,o),s.scissor(0,0,r,o)}readTexture(t,r,o,s,p,l){let c=this.gl;l||(l=1),this.frameBufferBound||this.attachFramebuffer(t,r,o);let n=this.getEncoder(p,l),a=n.allocate(r*o);return c.bindTexture(c.TEXTURE_2D,t),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,t,0),c.readPixels(0,0,r,o,c.RGBA,n.textureType,a),this.checkError(),n.decode(a,s)}isFramebufferReady(){return!0}getActiveTexture(){let t=this.gl;return`TEXTURE${t.getParameter(this.gl.ACTIVE_TEXTURE)-t.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(t,r){let o=this.gl;o.vertexAttribPointer(t,3,o.FLOAT,!1,20,0),o.enableVertexAttribArray(t),r!==-1&&(o.vertexAttribPointer(r,2,o.FLOAT,!1,20,12),o.enableVertexAttribArray(r)),this.checkError()}createProgram(t,r){let o=this.gl,s=o.createProgram();return o.attachShader(s,t),o.attachShader(s,r),o.linkProgram(s),s}compileShader(t,r){let o=this.gl,s=o.createShader(r);if(!s)throw new Error(`createShader() returned null with type ${r}`);if(o.shaderSource(s,t),o.compileShader(s),o.getShaderParameter(s,o.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${o.getShaderInfoLog(s)}
Shader source:
${t}`);return s}deleteShader(t){this.gl.deleteShader(t)}bindTextureToUniform(t,r,o){let s=this.gl;s.activeTexture(s.TEXTURE0+r),this.checkError(),s.bindTexture(s.TEXTURE_2D,t),this.checkError(),s.uniform1i(o,r),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(B.debug){let t=this.gl,r=t.getError(),o="";switch(r){case t.NO_ERROR:return;case t.INVALID_ENUM:o="INVALID_ENUM";break;case t.INVALID_VALUE:o="INVALID_VALUE";break;case t.INVALID_OPERATION:o="INVALID_OPERATION";break;case t.INVALID_FRAMEBUFFER_OPERATION:o="INVALID_FRAMEBUFFER_OPERATION";break;case t.OUT_OF_MEMORY:o="OUT_OF_MEMORY";break;case t.CONTEXT_LOST_WEBGL:o="CONTEXT_LOST_WEBGL";break;default:o=`Unknown WebGL Error: ${r.toString(16)}`}throw new Error(o)}}deleteTexture(t){this.gl.deleteTexture(t)}deleteProgram(t){this.gl.deleteProgram(t)}getEncoder(t,r,o=0){if(this.version===2)return new Al(this.gl,r);switch(t){case"float":return o===1||this.isRenderFloat32Supported?new xo(this.gl,r):new xo(this.gl,r,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new $l(this.gl,r);default:throw new Error(`Invalid dataType: ${t}`)}}clearActiveTextures(){let t=this.gl;for(let r=0;r<this.maxTextureImageUnits;++r)t.activeTexture(t.TEXTURE0+r),t.bindTexture(t.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(this.framebuffer),t.bindBuffer(t.ARRAY_BUFFER,null),t.deleteBuffer(this.vertexbuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let t=this.gl,r=t.createBuffer();if(!r)throw new Error("createBuffer() returned null");let o=this.createDefaultGeometry();return t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,o,t.STATIC_DRAW),this.checkError(),r}createFramebuffer(){let t=this.gl.createFramebuffer();if(!t)throw new Error("createFramebuffer returned null");return t}queryVitalParameters(){let t=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let t=this.gl,r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);let o=this.version===2?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,o,1,1,0,t.RGBA,t.FLOAT,null);let s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);let p=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(s),p}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let t=this.gl,r,o,s,p,l;try{r=t.createTexture(),o=t.createFramebuffer(),t.bindTexture(t.TEXTURE_2D,r);let c=this.version===2?t.RGBA32F:t.RGBA;return t.texImage2D(t.TEXTURE_2D,0,c,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0),t.enable(t.BLEND),s=t.createShader(t.VERTEX_SHADER),!s||(t.shaderSource(s,"void main(){}"),t.compileShader(s),p=t.createShader(t.FRAGMENT_SHADER),!p)||(t.shaderSource(p,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),t.compileShader(p),l=t.createProgram(),!l)?!1:(t.attachShader(l,s),t.attachShader(l,p),t.linkProgram(l),t.useProgram(l),t.drawArrays(t.POINTS,0,1),t.getError()===t.NO_ERROR)}finally{t.disable(t.BLEND),l&&t.deleteProgram(l),s&&t.deleteShader(s),p&&t.deleteShader(p),o&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(o)),r&&(t.bindTexture(t.TEXTURE_2D,null),t.deleteTexture(r))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let t=this.gl,r=this.disjointTimerQueryWebgl2Extension,o=t.createQuery();return t.beginQuery(r.TIME_ELAPSED_EXT,o),o}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let t=this.gl,r=this.disjointTimerQueryWebgl2Extension;t.endQuery(r.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(t){let r=!1,o=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let s=this.gl,p=this.disjointTimerQueryWebgl2Extension;r=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE),o=s.getParameter(p.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return r&&!o}getTimerResult(t){let r=0;if(this.version===2){let o=this.gl;r=o.getQueryParameter(t,o.QUERY_RESULT),o.deleteQuery(t)}else throw new Error("WebGL1 profiling currently not supported");return r/1e6}async waitForQueryAndGetTime(t){return await Ia(()=>this.isTimerResultAvailable(t)),this.getTimerResult(t)}async createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let r,o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),s===null?r=()=>!0:r=()=>{let p=o.clientWaitSync(s,0,0);return p===o.ALREADY_SIGNALED||p===o.CONDITION_SATISFIED},{query:s,isFencePassed:r}}async pollFence(t){return new Promise(r=>{this.addItemToPoll(()=>t.isFencePassed(),()=>r())})}pollItems(){let t=Zg(this.itemsToPoll.map(r=>r.isDoneFn));for(let r=0;r<=t;++r){let{resolveFn:o}=this.itemsToPoll[r];o()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}async addItemToPoll(t,r){this.itemsToPoll.push({isDoneFn:t,resolveFn:r}),!(this.itemsToPoll.length>1)&&await Ia(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function td(t){let r;if((!t||t==="webgl2")&&"webgl2"in ge?r=ge.webgl2:(!t||t==="webgl")&&"webgl"in ge&&(r=ge.webgl),!r)try{let s=Qg();r=$u(s,t)}catch{let s=Yg();r=$u(s,t)}t=t||r.version===1?"webgl":"webgl2";let o=r.gl;return ge[t]=r,o.isContextLost()?(delete ge[t],td(t)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),r)}function $u(t,r){let o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},s,p=o;if((!r||r==="webgl2")&&(s=t.getContext("webgl2",p),s))try{return new jo(s,2)}catch(l){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${l}`)}if((!r||r==="webgl")&&(s=t.getContext("webgl",p)||t.getContext("experimental-webgl",p),s))try{return new jo(s,1)}catch(l){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${l}`)}throw new Error("WebGL is not supported")}function Yg(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let t=document.createElement("canvas");return t.width=1,t.height=1,t}function Qg(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var ge,tm=I(()=>{"use strict";Rt(),Jg(),ge={}}),ed,em=I(()=>{"use strict";zt(),Rt(),Kg(),tm(),ed=class{get contextId(){return B.webgl.contextId}set contextId(t){B.webgl.contextId=t}get matmulMaxBatchSize(){return B.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(t){B.webgl.matmulMaxBatchSize=t}get textureCacheMode(){return B.webgl.textureCacheMode}set textureCacheMode(t){B.webgl.textureCacheMode=t}get pack(){return B.webgl.pack}set pack(t){B.webgl.pack=t}get async(){return B.webgl.async}set async(t){B.webgl.async=t}initialize(){try{return this.glContext=td(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),tt.setWithEnv(B),B.webgl.context||Object.defineProperty(B.webgl,"context",{value:this.glContext.gl}),tt.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(t){return tt.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${t}`),!1}}createSessionHandler(t){return new Qc(this,t)}dispose(){this.glContext.dispose()}}});async function rd(t){if(t){let r=typeof t=="string"?[t]:t;for(let o of r){let s=ri.get(o);if(s)return s;let p=await rm(o);if(p)return p}}else return rd(["webgl"]);throw new Error("no available backend to use")}async function rm(t){let r=nd;if(typeof r[t]<"u"&&nm(r[t])){let o=r[t],s=o.initialize();if(typeof s=="object"&&"then"in s&&(s=await s),s)return ri.set(t,o),o}}function nm(t){let r=t;return"initialize"in r&&typeof r.initialize=="function"&&"createSessionHandler"in r&&typeof r.createSessionHandler=="function"&&"dispose"in r&&typeof r.dispose=="function"}var ri,nd,om=I(()=>{"use strict";em(),ri=new Map,nd={webgl:new ed}}),Du,od,im=I(()=>{"use strict";Rt(),Du=class{constructor(t,r){this.op=t,this.node=r}},od=class{constructor(t,r,o){this.graph=t,this.profiler=o,this.initialize(r)}initialize(t){this.profiler.event("session","ExecutionPlan.initialize",()=>{let r=this.graph.getNodes();if(r.length!==t.length)throw new Error("The size of nodes and OPs do not match.");this._ops=t.map((o,s)=>new Du(o,r[s])),this.reset(),this._starter=[],this._ops.forEach((o,s)=>{let p=!0;for(let l of o.node.inputs)if(!this._values[l]&&this.graph.getInputIndices().indexOf(l)===-1){p=!1;break}p&&this._starter.push(s)})})}reset(){this._values=this.graph.getValues().map(t=>t.tensor)}async execute(t,r){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let o=t.createInferenceHandler(),s=this.graph.getInputIndices();if(r.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${r.length} expected: ${s.length}`);r.forEach((e,u)=>{let i=s[u];this._values[i]=e});let p=this._starter.slice(0),l=this.graph.getValues(),c=this.graph.getNodes(),n=0;for(;n<p.length;){let e=p[n++],u=this._ops[e],i=u.node.inputs.map(b=>this._values[b]);if(i.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${u.node}`);let d=i;tt.verbose("ExecPlan",`Running op:${u.node.name} (${d.map((b,x)=>`'${u.node.inputs[x]}': ${b.type}[${b.dims.join(",")}]`).join(", ")})`);let h=await this.profiler.event("node",u.node.name,async()=>u.op.impl(o,d,u.op.context));if(h.length!==u.node.outputs.length)throw new Error("the size of output does not match model definition.");h.forEach((b,x)=>{let E=u.node.outputs[x];if(this._values[E])throw new Error(`output [${E}] already has value: op:${u.node.name}`);this._values[E]=b});let m=new Set;h.forEach((b,x)=>{let E=u.node.outputs[x];for(let w of l[E].to){let S=c[w],$=!0;for(let F of S.inputs)if(!this._values[F]){$=!1;break}$&&m.add(w)}}),p.push(...m)}let a=[];for(let e=0;e<this.graph.getOutputIndices().length;e++){let u=this.graph.getOutputIndices()[e],i=this._values[u];if(i===void 0)throw new Error(`required output [${u}] does not have value`);u===0?await i.getData():i.data,a.push(i)}return tt.verbose("ExecPlan","disposing of inferenceHandler"),o.dispose(),a})}}}),R,Ot,Vo,am=I(()=>{"use strict";Yr(),R=Ie(mr()),De(),U(),Ot=H.experimental.fbs,Vo=class or{constructor(r){if(this._attributes=new Map,r!=null){for(let o of r)o instanceof R.onnx.AttributeProto?this._attributes.set(o.name,[or.getValue(o),or.getType(o)]):o instanceof Ot.Attribute&&this._attributes.set(o.name(),[or.getValue(o),or.getType(o)]);if(this._attributes.size<r.length)throw new Error("duplicated attribute names")}}set(r,o,s){this._attributes.set(r,[s,o])}delete(r){this._attributes.delete(r)}getFloat(r,o){return this.get(r,"float",o)}getInt(r,o){return this.get(r,"int",o)}getString(r,o){return this.get(r,"string",o)}getTensor(r,o){return this.get(r,"tensor",o)}getFloats(r,o){return this.get(r,"floats",o)}getInts(r,o){return this.get(r,"ints",o)}getStrings(r,o){return this.get(r,"strings",o)}getTensors(r,o){return this.get(r,"tensors",o)}get(r,o,s){let p=this._attributes.get(r);if(p===void 0){if(s!==void 0)return s;throw new Error(`required attribute not found: ${r}`)}if(p[1]!==o)throw new Error(`type mismatch: expected ${o} but got ${p[1]}`);return p[0]}static getType(r){let o=r instanceof R.onnx.AttributeProto?r.type:r.type();switch(o){case R.onnx.AttributeProto.AttributeType.FLOAT:return"float";case R.onnx.AttributeProto.AttributeType.INT:return"int";case R.onnx.AttributeProto.AttributeType.STRING:return"string";case R.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case R.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case R.onnx.AttributeProto.AttributeType.INTS:return"ints";case R.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case R.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${R.onnx.AttributeProto.AttributeType[o]}`)}}static getValue(r){let o=r instanceof R.onnx.AttributeProto?r.type:r.type();if(o===R.onnx.AttributeProto.AttributeType.GRAPH||o===R.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let s=this.getValueNoCheck(r);if(o===R.onnx.AttributeProto.AttributeType.INT&&Vt.isLong(s))return Vt.longToNumber(s);if(o===R.onnx.AttributeProto.AttributeType.INTS){let p=s,l=new Array(p.length);for(let c=0;c<p.length;c++){let n=p[c];l[c]=Vt.longToNumber(n)}return l}if(o===R.onnx.AttributeProto.AttributeType.TENSOR)return r instanceof R.onnx.AttributeProto?Pt.fromProto(s):Pt.fromOrtTensor(s);if(o===R.onnx.AttributeProto.AttributeType.TENSORS){if(r instanceof R.onnx.AttributeProto)return s.map(p=>Pt.fromProto(p));if(r instanceof Ot.Attribute)return s.map(p=>Pt.fromOrtTensor(p))}return o===R.onnx.AttributeProto.AttributeType.STRING&&r instanceof R.onnx.AttributeProto?mo(s):o===R.onnx.AttributeProto.AttributeType.STRINGS&&r instanceof R.onnx.AttributeProto?s.map(mo):s}static getValueNoCheck(r){return r instanceof R.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(r):this.getValueNoCheckFromOrtFormat(r)}static getValueNoCheckFromOnnxFormat(r){switch(r.type){case R.onnx.AttributeProto.AttributeType.FLOAT:return r.f;case R.onnx.AttributeProto.AttributeType.INT:return r.i;case R.onnx.AttributeProto.AttributeType.STRING:return r.s;case R.onnx.AttributeProto.AttributeType.TENSOR:return r.t;case R.onnx.AttributeProto.AttributeType.GRAPH:return r.g;case R.onnx.AttributeProto.AttributeType.FLOATS:return r.floats;case R.onnx.AttributeProto.AttributeType.INTS:return r.ints;case R.onnx.AttributeProto.AttributeType.STRINGS:return r.strings;case R.onnx.AttributeProto.AttributeType.TENSORS:return r.tensors;case R.onnx.AttributeProto.AttributeType.GRAPHS:return r.graphs;default:throw new Error(`unsupported attribute type: ${R.onnx.AttributeProto.AttributeType[r.type]}`)}}static getValueNoCheckFromOrtFormat(r){switch(r.type()){case Ot.AttributeType.FLOAT:return r.f();case Ot.AttributeType.INT:return r.i();case Ot.AttributeType.STRING:return r.s();case Ot.AttributeType.TENSOR:return r.t();case Ot.AttributeType.GRAPH:return r.g();case Ot.AttributeType.FLOATS:return r.floatsArray();case Ot.AttributeType.INTS:{let o=[];for(let s=0;s<r.intsLength();s++)o.push(r.ints(s));return o}case Ot.AttributeType.STRINGS:{let o=[];for(let s=0;s<r.stringsLength();s++)o.push(r.strings(s));return o}case Ot.AttributeType.TENSORS:{let o=[];for(let s=0;s<r.tensorsLength();s++)o.push(r.tensors(s));return o}default:throw new Error(`unsupported attribute type: ${Ot.AttributeType[r.type()]}`)}}}}),Kn,Xe,Mo,Ht,Zn,Nu,sm=I(()=>{"use strict";am(),Yr(),Kn=Ie(mr()),De(),U(),Xe=H.experimental.fbs,Mo={from:(t,r)=>new Nu(t,r)},Ht=class{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=Et.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}},Zn=class{constructor(t,r){t instanceof Kn.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new Vo(t.attribute)):t instanceof Xe.Node&&(this.name=r??t.name(),this.opType=t.opType(),this.attributes=new Vo(Et.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Nu=class{constructor(t,r){if(!t)throw new TypeError("graph is empty");this.buildGraph(t),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof Kn.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else if(t instanceof Xe.Graph)this.buildGraphFromOrtFormat(t);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(t){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let o=new Map;if(!t.input)throw new Error("missing information in graph: input");let s=[];for(let p of t.input){if(r.has(p.name))throw new Error(`duplicated input name: ${p.name}`);let l=this._allData.push(new Ht(p))-1;r.set(p.name,l),s.push(p.name)}if(!t.initializer)throw new Error("missing information in graph: initializer");for(let p of t.initializer){let l=r.get(p.name);if(l===void 0){let c=new Ht;c.type={shape:{dims:Et.tensorDimsFromProto(p.dims)},tensorType:Et.tensorDataTypeFromProto(p.dataType)},l=this._allData.push(c)-1,r.set(p.name,l)}this._allData[l]._from=-1,this._allData[l].tensor=Pt.fromProto(p)}for(let p=0;p<this._allData.length;p++)this._allData[p].tensor||(this._allInputIndices.push(p),this._allInputNames.push(s[p]));if(!t.output)throw new Error("missing information in graph: output");for(let p of t.output){if(r.has(p.name))throw new Error(`duplicated output name: ${p.name}`);let l=this._allData.push(new Ht(p))-1;r.set(p.name,l),this._allOutputIndices.push(l),this._allOutputNames.push(p.name)}if(!t.node)throw new Error("missing information in graph: node");for(let p of t.node){if(!p.name)for(let c=0;;c++){let n=`unnamed_${p.opType}_${c}`;if(!o.has(n)){p.name=n;break}}if(o.has(p.name))throw new Error(`duplicated node name: ${p.name}`);let l=this._nodes.push(new Zn(p))-1;o.set(p.name,l)}for(let p=0;p<this._nodes.length;p++){let l=this._nodes[p],c=t.node[p];if(!c.output)throw new Error(`missing output for node: ${c.name}`);for(let n of c.output){let a=r.get(n);if(typeof a>"u"&&(a=this._allData.push(new Ht)-1,r.set(n,a)),l.outputs.push(a),this._allData[a]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${a}`);if(this._allData[a]._from=p,c.opType==="Constant"){if(!c.attribute||c.attribute.length!==1||!c.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!c.output||c.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");l.outputs.pop(),l.executeNode=!1,this._allData[a]._from=-1,this._allData[a].tensor=Pt.fromProto(c.attribute[0].t)}}}for(let p=0;p<this._nodes.length;p++){let l=this._nodes[p],c=t.node[p];if(!c.input)throw new Error(`missing input for node: ${c.name}`);for(let n of c.input){let a=r.get(n);if(typeof a>"u"){if(n===""&&(c.input.length===3||c.input.length===4)&&c.opType==="Resize")continue;throw new Error(`unrecognized input '${n}' for node: ${c.name}`)}l.inputs.push(a),this._allData[a]._to.push(p)}}return!0}buildGraphFromOrtFormat(t){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let o=new Map,s=[];for(let p=0;p<t.inputsLength();p++){let l=t.inputs(p);if(r.has(l))throw new Error(`duplicated input name: ${l}`);for(let c=0;c<t.nodeArgsLength();c++)if(t.nodeArgs(c)?.name()===l){let n=new Ht;if(t.nodeArgs(c)?.type()?.valueType()!==Xe.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let a=t.nodeArgs(c).type().value(new Xe.TensorTypeAndShape),e=Et.tensorDataTypeFromProto(a.elemType()),u=a.shape(),i=[];for(let h=0;h<u.dimLength();h++)i.push(Vt.longToNumber(u.dim(h).value().dimValue()));n.type={shape:{dims:i},tensorType:e};let d=this._allData.push(n)-1;r.set(l,d),s.push(l)}}for(let p=0;p<t.initializersLength();p++){let l=t.initializers(p),c=r.get(l.name());if(c===void 0){let n=new Ht,a=Et.tensorDimsFromORTFormat(l),e=Et.tensorDataTypeFromProto(l.dataType());n.type={shape:{dims:a},tensorType:e},c=this._allData.push(n)-1,r.set(l.name(),c)}this._allData[c]._from=-1,this._allData[c].tensor=Pt.fromOrtTensor(l)}for(let p=0;p<this._allData.length;p++)this._allData[p].tensor||(this._allInputIndices.push(p),this._allInputNames.push(s[p]));for(let p=0;p<t.outputsLength();p++){let l=t.outputs(p);if(r.has(l))throw new Error(`duplicated output name: ${l}`);let c=this._allData.push(new Ht)-1;r.set(l,c),this._allOutputIndices.push(c),this._allOutputNames.push(l)}if(!t.nodes)throw new Error("missing information in graph: node");for(let p=0;p<t.nodesLength();p++){let l=t.nodes(p),c=l.name();if(!c)for(let a=0;c=`unnamed_${l.opType()}_${a}`,!!o.has(c);a++);if(o.has(c))throw new Error(`duplicated node name: ${c}`);let n=this._nodes.push(new Zn(l,c))-1;o.set(c,n)}for(let p=0;p<this._nodes.length;p++){let l=this._nodes[p],c=t.nodes(p);if(c==null)throw new Error(`No node exists at index ${p}`);if(c?.outputsLength()===0)throw new Error(`missing output for node: ${c.name}`);for(let n=0;n<c?.outputsLength();n++){let a=c?.outputs(n),e=r.get(a);if(typeof e>"u"&&(e=this._allData.push(new Ht)-1,r.set(a,e)),l.outputs.push(e),this._allData[e]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${e}`);if(this._allData[e]._from=p,c.opType()==="Constant"){if(c.attributesLength()!==1||!c.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(c.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");l.outputs.pop(),l.executeNode=!1,this._allData[e]._from=-1,this._allData[e].tensor=Pt.fromOrtTensor(c.attributes(0).t())}}}for(let p=0;p<this._nodes.length;p++){let l=this._nodes[p],c=t.nodes(p);if(c.inputsLength()===0)throw new Error(`missing input for node: ${c.name}`);for(let n=0;n<c.inputsLength();n++){let a=c.inputs(n),e=r.get(a);if(typeof e>"u")throw new Error(`unrecognized input '${a}' for node: ${c.name()}`);l.inputs.push(e),this._allData[e]._to.push(p)}}}checkIsAcyclic(){let t=new Set;this._allInputIndices.forEach(s=>{this._allData[s]._to.forEach(p=>{t.add(p)})});let r=Array.from(t),o=new Array(this._nodes.length).fill("white");for(;r.length>0;){let s=r.pop();o[s]==="gray"?o[s]="black":(r.push(s),o[s]="gray",this._nodes[s].outputs.forEach(p=>{let l=this._allData[p];if(typeof l.tensor<"u")throw new Error("node outputs should not be initialized");if(l._from!==s)throw new Error("from property of the Value object doesn't match index of Node being processed");l._to.forEach(c=>{if(o[c]==="gray")throw new Error("model graph is cyclic");o[c]==="white"&&r.push(c)})}))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0,r=new Array(this._nodes.length,0),o=0;for(let s=0;s<this._nodes.length;s++)r[s]=o,this._nodes[s].executeNode?(o!==s&&(this._nodes[o]=this._nodes[s]),o++):this._nodes[s].outputs.forEach(p=>{this._allData[p]._from=-2});this._nodes.splice(o,this._nodes.length-o);for(let s=0;s<this._allData.length;s++){let p=this._allData[s];p._from!==void 0&&p._from!==-1&&p._from!==-2&&(p._from=r[p._from]);for(let l=0;l<p._to.length;l++)if(p._to[l]>=0)p._to[l]=r[p._to[l]];else throw new Error("Trying to update a removed node")}t=0;for(let s=0;s<this._allData.length;s++){if(this._allData[s].from===-2&&this._allOutputIndices.indexOf(s+t)===-1){t++,this._allData.splice(s,1),s--;continue}if(t>0){let p=-1;this._allData[s].from!==void 0&&this._allData[s].from!==-1?(p=this._nodes[this._allData[s].from].outputs.indexOf(s+t),p!==-1&&(this._nodes[this._allData[s].from].outputs[p]=s)):(p=this._allInputIndices.indexOf(s+t),p!==-1&&(this._allInputIndices[p]=s)),this._allData[s].to.forEach(l=>{p=this._nodes[l].inputs.indexOf(s+t),p!==-1&&(this._nodes[l].inputs[p]=s)}),this._allData[s].to.length===0&&(p=this._allOutputIndices.indexOf(s+t),p!==-1&&(this._allOutputIndices[p]=s))}}}deleteNode(t){let r=this._nodes[t];if(r.outputs.length>1){for(let c=1;c<r.outputs.length;c++)if(this._allData[r.outputs[c]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let o=r.inputs[0],s=r.outputs[0],p=this._allData[s].to;for(let c=0;c<r.inputs.length;c++){let n=this._allData[r.inputs[c]].to.indexOf(t);if(n===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[c]].to.splice(n,1)}this._allData[s]._to=[];let l=this._allOutputIndices.indexOf(s);if(l!==-1&&(this._allOutputIndices[l]=o),p&&p.length>0)for(let c of p){let n=this._nodes[c].inputs.indexOf(s);if(n===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[c].inputs[n]=o,this._allData[o].to.push(c)}}removeAllDropoutNodes(){let t=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let t of this._nodes)if(t.opType==="Conv"){let r=this._allData[t.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let o=this._nodes[r[0]];if(o.opType==="Clip")if(o.inputs.length===1)try{t.attributes.set("activation_params","floats",[o.attributes.getFloat("min"),o.attributes.getFloat("max")])}catch{t.attributes.set("activation_params","floats",[dr,hr])}else if(o.inputs.length>=3&&this._allData[o.inputs[1]].tensor!==void 0&&this._allData[o.inputs[2]].tensor!==void 0)t.attributes.set("activation_params","floats",[this._allData[o.inputs[1]].tensor.floatData[0],this._allData[o.inputs[2]].tensor.floatData[0]]);else continue;t.attributes.set("activation","string",o.opType),this.deleteNode(r[0])}}}}}),ku,Fu,id,um=I(()=>{"use strict";Ko(),sm(),Yr(),ku=Ie(mr()),U(),Fu=H.experimental.fbs,id=class{constructor(){}load(t,r,o){let s;if(!o)try{this.loadFromOnnxFormat(t,r);return}catch(p){if(o!==void 0)throw p;s=p}try{this.loadFromOrtFormat(t,r)}catch(p){throw o!==void 0?p:new Error(`Failed to load model as ONNX format: ${s}
as ORT format: ${p}`)}}loadFromOnnxFormat(t,r){let o=ku.onnx.ModelProto.decode(t);if(Vt.longToNumber(o.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=o.opsetImport.map(s=>({domain:s.domain,version:Vt.longToNumber(s.version)})),this._graph=Mo.from(o.graph,r)}loadFromOrtFormat(t,r){let o=new T.ByteBuffer(t),s=Fu.InferenceSession.getRootAsInferenceSession(o).model();if(Vt.longToNumber(s.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let p=0;p<s.opsetImportLength();p++){let l=s.opsetImport(p);this._opsets.push({domain:l?.domain(),version:Vt.longToNumber(l.version())})}this._graph=Mo.from(s.graph(),r)}get graph(){return this._graph}get opsets(){return this._opsets}}}),ad,lm=I(()=>{"use strict";om(),im(),Rt(),um(),ad=class{constructor(t={}){this._initialized=!1,this.backendHint=t.backendHint,this.profiler=bl.create(t.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(t,r,o){await this.profiler.event("session","Session.loadModel",async()=>{let s=await rd(this.backendHint);if(this.sessionHandler=s.createSessionHandler(this.context),this._model=new id,typeof t=="string"){let p=t.endsWith(".ort");{let l=await(await fetch(t)).arrayBuffer();this.initialize(new Uint8Array(l),p)}}else if(ArrayBuffer.isView(t))this.initialize(t);else{let p=new Uint8Array(t,r||0,o||t.byteLength);this.initialize(p)}})}initialize(t,r){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let o=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(t,o,r),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new od(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(t){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let r=this.normalizeAndValidateInputs(t),o=await this._executionPlan.execute(this.sessionHandler,r);return this.createOutput(o)})}normalizeAndValidateInputs(t){let r=this._model.graph.getInputNames();if(Array.isArray(t)){if(t.length!==r.length)throw new Error(`incorrect input array length: expected ${r.length} but got ${t.length}`)}else{if(t.size!==r.length)throw new Error(`incorrect input map size: expected ${r.length} but got ${t.size}`);let o=new Array(t.size),s=0;for(let p=0;p<r.length;++p){let l=t.get(r[p]);if(!l)throw new Error(`missing input tensor for: '${name}'`);o[s++]=l}t=o}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let o=this._model.graph.getInputIndices(),s=this._model.graph.getValues(),p=new Array(o.length);for(let l=0;l<o.length;++l){let c=s[o[l]];p[l]=c.type.shape.dims,this.context.graphInputTypes.push(c.type.tensorType),this.context.graphInputDims.push(t[l].dims)}this.validateInputTensorDims(p,t,!0)}else this.validateInputTensorDims(this.context.graphInputDims,t,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,t),t}validateInputTensorTypes(t,r){for(let o=0;o<r.length;o++){let s=t[o],p=r[o].type;if(s!==p)throw new Error(`input tensor[${o}] check failed: expected type '${s}' but got ${p}`)}}validateInputTensorDims(t,r,o){for(let s=0;s<r.length;s++){let p=t[s],l=r[s].dims;if(!this.compareTensorDims(p,l,o))throw new Error(`input tensor[${s}] check failed: expected shape '[${p.join(",")}]' but got [${l.join(",")}]`)}}compareTensorDims(t,r,o){if(t.length!==r.length)return!1;for(let s=0;s<t.length;++s)if(t[s]!==r[s]&&(!o||t[s]!==0))return!1;return!0}createOutput(t){let r=this._model.graph.getOutputNames();if(t.length!==r.length)throw new Error("expected number of outputs do not match number of generated outputs");let o=new Map;for(let s=0;s<r.length;++s)o.set(r[s],t[s]);return o}initializeOps(t){let r=t.getNodes();this._ops=new Array(r.length);for(let o=0;o<r.length;o++)this._ops[o]=this.sessionHandler.resolve(r[o],this._model.opsets,t)}}}),sd,pm=I(()=>{"use strict";zt(),De(),sd=class{constructor(t){this.session=t,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(t,r,o){let s=new Map;for(let c in t)if(Object.hasOwnProperty.call(t,c)){let n=t[c];s.set(c,new Pt(n.dims,n.type,void 0,void 0,n.data))}let p=await this.session.run(s),l={};return p.forEach((c,n)=>{l[n]=new ft(c.type,c.data,c.dims)}),l}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),ud={};gr(ud,{onnxjsBackend:()=>ld});var Cu,ld,cm=I(()=>{"use strict";lm(),pm(),Cu=class{async init(){}async createInferenceSessionHandler(t,r){let o=new ad(r);return typeof t=="string"?await o.loadModel(t):await o.loadModel(t),new sd(o)}},ld=new Cu}),ni=I(()=>{"use strict"}),pd={};gr(pd,{default:()=>cd});var Jn,Yn,cd,dm=I(()=>{"use strict";Sd(),Ce(),en(),Jn="ort-wasm-proxy-worker",Yn=globalThis.self?.name===Jn,Yn&&(self.onmessage=t=>{let{type:r,in:o}=t.data;try{switch(r){case"init-wasm":oi(o.wasm).then(()=>{li(o).then(()=>{postMessage({type:r})},s=>{postMessage({type:r,err:s})})},s=>{postMessage({type:r,err:s})});break;case"init-ep":{let{epName:s,env:p}=o;pi(p,s).then(()=>{postMessage({type:r})},l=>{postMessage({type:r,err:l})});break}case"copy-from":{let{buffer:s}=o,p=Kr(s);postMessage({type:r,out:p});break}case"create":{let{model:s,options:p}=o;ci(s,p).then(l=>{postMessage({type:r,out:l})},l=>{postMessage({type:r,err:l})});break}case"release":di(o),postMessage({type:r});break;case"run":{let{sessionId:s,inputIndices:p,inputs:l,outputIndices:c,options:n}=o;hi(s,p,l,c,new Array(c.length).fill(null),n).then(a=>{a.some(e=>e[3]!=="cpu")?postMessage({type:r,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:r,out:a},gi([...l,...a]))},a=>{postMessage({type:r,err:a})});break}case"end-profiling":fi(o),postMessage({type:r});break;default:}}catch(s){postMessage({type:r,err:s})}}),cd=Yn?null:t=>new Worker(t??Oe,{type:"module",name:Jn})}),dd={};gr(dd,{default:()=>hd});var Qn,to,hd,hm=I(()=>{"use strict";to=(Qn=zr.url,async function(t={}){function r(){return yt.buffer!=wt.buffer&&it(),wt}function o(){return yt.buffer!=wt.buffer&&it(),G}function s(){return yt.buffer!=wt.buffer&&it(),Wt}function p(){return yt.buffer!=wt.buffer&&it(),Tr}function l(){return yt.buffer!=wt.buffer&&it(),ve}var c,n,a=Object.assign({},t),e=new Promise((f,g)=>{c=f,n=g}),u=typeof window=="object",i=typeof importScripts=="function",d=i&&self.name=="em-pthread";a.mountExternalData=(f,g)=>{f.startsWith("./")&&(f=f.substring(2)),(a.Ua||(a.Ua=new Map)).set(f,g)},a.unmountExternalData=()=>{delete a.Ua};var h,m,b=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor,x=Object.assign({},a),E="./this.program",w=(f,g)=>{throw g},S="";(u||i)&&(i?S=self.location.href:typeof document<"u"&&document.currentScript&&(S=document.currentScript.src),Qn&&(S=Qn),S=S.startsWith("blob:")?"":S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1),i&&(m=f=>{var g=new XMLHttpRequest;return g.open("GET",f,!1),g.responseType="arraybuffer",g.send(null),new Uint8Array(g.response)}),h=(f,g,y)=>{var v=new XMLHttpRequest;v.open("GET",f,!0),v.responseType="arraybuffer",v.onload=()=>{v.status==200||v.status==0&&v.response?g(v.response):y()},v.onerror=y,v.send(null)});var $,F=console.log.bind(console),bt=console.error.bind(console),pt=F,Z=bt;if(Object.assign(a,x),x=null,d){let f=function(g){try{var y=g.data,v=y.cmd;if(v==="load"){let _=[];self.onmessage=P=>_.push(P),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let P of _)f(P);self.onmessage=f};for(let P of y.handlers)a[P]&&!a[P].proxy||(a[P]=(...N)=>{postMessage({Za:"callHandler",kb:P,args:N})},P=="print"&&(pt=a[P]),P=="printErr"&&(Z=a[P]));yt=y.wasmMemory,it(),At(y.wasmModule)}else if(v==="run"){fn(y.pthread_ptr,0,0,1,0,0),ln(y.pthread_ptr),Rd(),Si(),vr||=!0;try{Bd(y.start_routine,y.arg)}catch(_){if(_!="unwind")throw _}}else v==="cancel"?_e()&&$r(-1):y.target!=="setimmediate"&&(v==="checkMailbox"?vr&&Ir():v&&(Z(`worker: received unknown command ${v}`),Z(y)))}catch(_){throw la(),_}};var Le=f,At,vr=!1;Z=function(...g){g=g.join(" "),console.error(g)},self.alert=function(...g){postMessage({Za:"alert",text:g.join(" "),nb:_e()})},a.instantiateWasm=(g,y)=>new Promise(v=>{At=_=>{_=new WebAssembly.Instance(_,yi()),y(_),v()}}),self.onunhandledrejection=g=>{throw g.reason||g},self.onmessage=f}a.wasmBinary&&($=a.wasmBinary);var yt,xr,Ut,wt,G,Wt,Tr,xt,ve,ot=!1;function it(){var f=yt.buffer;a.HEAP8=wt=new Int8Array(f),a.HEAP16=new Int16Array(f),a.HEAPU8=G=new Uint8Array(f),a.HEAPU16=new Uint16Array(f),a.HEAP32=Wt=new Int32Array(f),a.HEAPU32=Tr=new Uint32Array(f),a.HEAPF32=new Float32Array(f),a.HEAPF64=ve=new Float64Array(f),a.HEAP64=xt=new BigInt64Array(f),a.HEAPU64=new BigUint64Array(f)}if(!d){if(!((yt=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof b))throw Z("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");it()}var oe=[],Xt=[],_r=[],ie=0,Ct=null,Tt=null;function ae(){if(--ie==0&&(Ct!==null&&(clearInterval(Ct),Ct=null),Tt)){var f=Tt;Tt=null,f()}}function et(f){throw Z(f="Aborted("+f+")"),ot=!0,Ut=1,f=new WebAssembly.RuntimeError(f+". Build with -sASSERTIONS for more info."),n(f),f}var at,Gt=f=>f.startsWith("data:application/octet-stream;base64,"),Re=f=>f.startsWith("file://");function Sr(f){if(f==at&&$)return new Uint8Array($);if(m)return m(f);throw"both async and sync fetching of the wasm failed"}function bi(f,g,y){return function(v){if(!$&&(u||i)){if(typeof fetch=="function"&&!Re(v))return fetch(v,{credentials:"same-origin"}).then(_=>{if(!_.ok)throw`failed to load wasm binary file at '${v}'`;return _.arrayBuffer()}).catch(()=>Sr(v));if(h)return new Promise((_,P)=>{h(v,N=>_(new Uint8Array(N)),P)})}return Promise.resolve().then(()=>Sr(v))}(f).then(v=>WebAssembly.instantiate(v,g)).then(y,v=>{Z(`failed to asynchronously prepare wasm: ${v}`),et(v)})}function yi(){return{a:{j:Ld,b:Vd,E:Ai,g:Ni,V:ki,A:Li,C:Ri,W:Bi,T:ji,L:Vi,S:Mi,o:zi,B:Ui,y:Gi,U:Hi,z:qi,_:Md,Z:zd,P:Ud,w:Gd,F:Hd,k:qd,O:ln,Y:Wd,I:Xd,J:Kd,K:Zd,G:Ki,H:Zi,v:Jd,q:Yd,l:Qd,p:th,e:eh,X:rh,x:nh,d:Ji,f:oh,i:ih,u:ah,t:sh,s:uh,Q:ta,R:ea,D:un,h:ra,n:na,M:oa,m:ia,a:yt,r:sn,N:ua,c:ch}}}var wi={837620:(f,g,y,v,_)=>{if(a===void 0||!a.Ua)return 1;if((f=je(f>>>0)).startsWith("./")&&(f=f.substring(2)),!(f=a.Ua.get(f)))return 2;if(v>>>=0,(g>>>=0)+(y>>>=0)>f.byteLength)return 3;try{let P=f.subarray(g,g+y);switch(_){case 0:o().set(P,v>>>0);break;case 1:a.mb(v,P);break;default:return 4}return 0}catch{return 4}},838303:()=>typeof wasmOffsetConverter<"u"};function Ld(){return typeof wasmOffsetConverter<"u"}function on(f){this.name="ExitStatus",this.message=`Program terminated with exit(${f})`,this.status=f}var an=f=>{f.terminate(),f.onmessage=()=>{}},vi=f=>{Kt.length==0&&(Ei(),Oi(Kt[0]));var g=Kt.pop();if(!g)return 6;se.push(g),Bt[f.Ra]=g,g.Ra=f.Ra;var y={cmd:"run",start_routine:f.cb,arg:f.ab,pthread_ptr:f.Ra};return g.postMessage(y,f.ib),0},Be=0,J=(f,g,...y)=>{for(var v=2*y.length,_=bn(),P=mn(8*v),N=P>>>3,K=0;K<y.length;K++){var ct=y[K];typeof ct=="bigint"?(xt[N+2*K]=1n,xt[N+2*K+1]=ct):(xt[N+2*K]=0n,l()[N+2*K+1>>>0]=ct)}return f=pa(f,0,v,P,g),Dr(_),f};function sn(f){if(d)return J(0,1,f);if(Ut=f,!(0<Be)){for(var g of se)an(g);for(g of Kt)an(g);Kt=[],se=[],Bt=[],ot=!0}w(f,new on(f))}function xi(f){if(d)return J(1,0,f);un(f)}var un=f=>{if(Ut=f,d)throw xi(f),"unwind";sn(f)},Kt=[],se=[],Ti=[],Bt={},_i=f=>{var g=f.Ra;delete Bt[g],Kt.push(f),se.splice(se.indexOf(f),1),f.Ra=0,gn(g)};function Si(){Ti.forEach(f=>f())}var Oi=f=>new Promise(g=>{f.onmessage=_=>{var P=(_=_.data).cmd;if(_.targetThread&&_.targetThread!=_e()){var N=Bt[_.targetThread];N?N.postMessage(_,_.transferList):Z(`Internal error! Worker sent a message "${P}" to target pthread ${_.targetThread}, but that thread no longer exists!`)}else P==="checkMailbox"?Ir():P==="spawnThread"?vi(_):P==="cleanupThread"?_i(Bt[_.thread]):P==="killThread"?(_=_.thread,P=Bt[_],delete Bt[_],an(P),gn(_),se.splice(se.indexOf(P),1),P.Ra=0):P==="cancelThread"?Bt[_.thread].postMessage({cmd:"cancel"}):P==="loaded"?(f.loaded=!0,g(f)):P==="alert"?alert(`Thread ${_.threadId}: ${_.text}`):_.target==="setimmediate"?f.postMessage(_):P==="callHandler"?a[_.handler](..._.args):P&&Z(`worker sent an unknown command ${P}`)},f.onerror=_=>{throw Z(`worker sent an error! ${_.filename}:${_.lineno}: ${_.message}`),_};var y,v=[];for(y of[])a.hasOwnProperty(y)&&v.push(y);f.postMessage({cmd:"load",handlers:v,wasmMemory:yt,wasmModule:xr})});function Ei(){var f=new Worker(new URL(zr.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});Kt.push(f)}var Ii,Or=f=>{for(;0<f.length;)f.shift()(a)},Rd=()=>{var f=_e(),g=p()[f+52>>>2>>>0];f=p()[f+56>>>2>>>0],da(g,g-f),Dr(g)},Er=[],Bd=(f,g)=>{Be=0;var y=Er[f];y||(f>=Er.length&&(Er.length=f+1),Er[f]=y=Ii.get(f)),f=y(g),0<Be?Ut=f:$r(f)};class jd{constructor(g){this.Xa=g-24}}function Vd(f,g,y){var v=new jd(f>>>=0);throw g>>>=0,y>>>=0,p()[v.Xa+16>>>2>>>0]=0,p()[v.Xa+4>>>2>>>0]=g,p()[v.Xa+8>>>2>>>0]=y,f}function Pi(f,g,y,v){return d?J(2,1,f,g,y,v):Ai(f,g,y,v)}function Ai(f,g,y,v){if(f>>>=0,g>>>=0,y>>>=0,v>>>=0,b===void 0)return Z("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var _=[];return d&&_.length===0?Pi(f,g,y,v):(f={cb:y,Ra:f,ab:v,ib:_},d?(f.Za="spawnThread",postMessage(f,_),0):vi(f))}var $i=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Di=(f,g,y)=>{var v=(g>>>=0)+y;for(y=g;f[y]&&!(y>=v);)++y;if(16<y-g&&f.buffer&&$i)return $i.decode(f.buffer instanceof b?f.slice(g,y):f.subarray(g,y));for(v="";g<y;){var _=f[g++];if(128&_){var P=63&f[g++];if((224&_)==192)v+=String.fromCharCode((31&_)<<6|P);else{var N=63&f[g++];65536>(_=(240&_)==224?(15&_)<<12|P<<6|N:(7&_)<<18|P<<12|N<<6|63&f[g++])?v+=String.fromCharCode(_):(_-=65536,v+=String.fromCharCode(55296|_>>10,56320|1023&_))}}else v+=String.fromCharCode(_)}return v},je=(f,g)=>(f>>>=0)?Di(o(),f,g):"";function Ni(f,g,y){return d?J(3,1,f,g,y):0}function ki(f,g){if(d)return J(4,1,f,g)}var Fi=f=>{for(var g=0,y=0;y<f.length;++y){var v=f.charCodeAt(y);127>=v?g++:2047>=v?g+=2:55296<=v&&57343>=v?(g+=4,++y):g+=3}return g},Ci=(f,g,y,v)=>{if(!(0<v))return 0;var _=y>>>=0;v=y+v-1;for(var P=0;P<f.length;++P){var N=f.charCodeAt(P);if(55296<=N&&57343>=N&&(N=65536+((1023&N)<<10)|1023&f.charCodeAt(++P)),127>=N){if(y>=v)break;g[y++>>>0]=N}else{if(2047>=N){if(y+1>=v)break;g[y++>>>0]=192|N>>6}else{if(65535>=N){if(y+2>=v)break;g[y++>>>0]=224|N>>12}else{if(y+3>=v)break;g[y++>>>0]=240|N>>18,g[y++>>>0]=128|N>>12&63}g[y++>>>0]=128|N>>6&63}g[y++>>>0]=128|63&N}}return g[y>>>0]=0,y-_},Ve=(f,g,y)=>Ci(f,o(),g,y);function Li(f,g){if(d)return J(5,1,f,g)}function Ri(f,g,y){if(d)return J(6,1,f,g,y)}function Bi(f,g,y){return d?J(7,1,f,g,y):0}function ji(f,g){if(d)return J(8,1,f,g)}function Vi(f,g,y){if(d)return J(9,1,f,g,y)}function Mi(f,g,y,v){if(d)return J(10,1,f,g,y,v)}function zi(f,g,y,v){if(d)return J(11,1,f,g,y,v)}function Ui(f,g,y,v){if(d)return J(12,1,f,g,y,v)}function Gi(f){if(d)return J(13,1,f)}function Hi(f,g){if(d)return J(14,1,f,g)}function qi(f,g,y){if(d)return J(15,1,f,g,y)}var Md=()=>{et("")},zd=()=>1;function Ud(f){fn(f>>>0,!i,1,!u,131072,!1),Si()}function ln(f){f>>>=0,typeof Atomics.jb=="function"&&(Atomics.jb(s(),f>>>2,f).value.then(Ir),f+=128,Atomics.store(s(),f>>>2,1))}var Ir=()=>{var f=_e();if(f&&(ln(f),f=ca,!ot))try{if(f(),!(0<Be))try{d?$r(Ut):un(Ut)}catch(g){g instanceof on||g=="unwind"||w(1,g)}}catch(g){g instanceof on||g=="unwind"||w(1,g)}};function Gd(f,g){(f>>>=0)==g>>>0?setTimeout(Ir):d?postMessage({targetThread:f,cmd:"checkMailbox"}):(f=Bt[f])&&f.postMessage({cmd:"checkMailbox"})}var pn=[];function Hd(f,g,y,v,_){for(g>>>=0,v/=2,pn.length=v,y=_>>>0>>>3,_=0;_<v;_++)pn[_]=xt[y+2*_]?xt[y+2*_+1]:l()[y+2*_+1>>>0];return(g?wi[g]:dh[f])(...pn)}function qd(f){f>>>=0,d?postMessage({cmd:"cleanupThread",thread:f}):_i(Bt[f])}function Wd(f){}function Xd(f,g){f=-9007199254740992>f||9007199254740992<f?NaN:Number(f),g>>>=0,f=new Date(1e3*f),s()[g>>>2>>>0]=f.getUTCSeconds(),s()[g+4>>>2>>>0]=f.getUTCMinutes(),s()[g+8>>>2>>>0]=f.getUTCHours(),s()[g+12>>>2>>>0]=f.getUTCDate(),s()[g+16>>>2>>>0]=f.getUTCMonth(),s()[g+20>>>2>>>0]=f.getUTCFullYear()-1900,s()[g+24>>>2>>>0]=f.getUTCDay(),f=(f.getTime()-Date.UTC(f.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[g+28>>>2>>>0]=f}var xe=f=>f%4==0&&(f%100!=0||f%400==0),Wi=[0,31,60,91,121,152,182,213,244,274,305,335],Xi=[0,31,59,90,120,151,181,212,243,273,304,334];function Kd(f,g){f=-9007199254740992>f||9007199254740992<f?NaN:Number(f),g>>>=0,f=new Date(1e3*f),s()[g>>>2>>>0]=f.getSeconds(),s()[g+4>>>2>>>0]=f.getMinutes(),s()[g+8>>>2>>>0]=f.getHours(),s()[g+12>>>2>>>0]=f.getDate(),s()[g+16>>>2>>>0]=f.getMonth(),s()[g+20>>>2>>>0]=f.getFullYear()-1900,s()[g+24>>>2>>>0]=f.getDay();var y=(xe(f.getFullYear())?Wi:Xi)[f.getMonth()]+f.getDate()-1|0;s()[g+28>>>2>>>0]=y,s()[g+36>>>2>>>0]=-60*f.getTimezoneOffset(),y=new Date(f.getFullYear(),6,1).getTimezoneOffset();var v=new Date(f.getFullYear(),0,1).getTimezoneOffset();f=0|(y!=v&&f.getTimezoneOffset()==Math.min(v,y)),s()[g+32>>>2>>>0]=f}function Zd(f){f>>>=0;var g=new Date(s()[f+20>>>2>>>0]+1900,s()[f+16>>>2>>>0],s()[f+12>>>2>>>0],s()[f+8>>>2>>>0],s()[f+4>>>2>>>0],s()[f>>>2>>>0],0),y=s()[f+32>>>2>>>0],v=g.getTimezoneOffset(),_=new Date(g.getFullYear(),6,1).getTimezoneOffset(),P=new Date(g.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(P,_);return 0>y?s()[f+32>>>2>>>0]=+(_!=P&&N==v):0<y!=(N==v)&&(_=Math.max(P,_),g.setTime(g.getTime()+6e4*((0<y?N:_)-v))),s()[f+24>>>2>>>0]=g.getDay(),y=(xe(g.getFullYear())?Wi:Xi)[g.getMonth()]+g.getDate()-1|0,s()[f+28>>>2>>>0]=y,s()[f>>>2>>>0]=g.getSeconds(),s()[f+4>>>2>>>0]=g.getMinutes(),s()[f+8>>>2>>>0]=g.getHours(),s()[f+12>>>2>>>0]=g.getDate(),s()[f+16>>>2>>>0]=g.getMonth(),s()[f+20>>>2>>>0]=g.getYear(),f=g.getTime(),BigInt(isNaN(f)?-1:f/1e3)}function Ki(f,g,y,v,_,P,N){return d?J(16,1,f,g,y,v,_,P,N):-52}function Zi(f,g,y,v,_,P){if(d)return J(17,1,f,g,y,v,_,P)}function Jd(f,g,y,v){f>>>=0,g>>>=0,y>>>=0,v>>>=0;var _=new Date().getFullYear(),P=new Date(_,0,1),N=new Date(_,6,1);_=P.getTimezoneOffset();var K=N.getTimezoneOffset(),ct=Math.max(_,K);p()[f>>>2>>>0]=60*ct,s()[g>>>2>>>0]=+(_!=K),P=(f=gt=>gt.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(P),N=f(N),K<_?(Ve(P,y,17),Ve(N,v,17)):(Ve(P,v,17),Ve(N,y,17))}var cn=[];function Yd(f,g,y){f>>>=0,g>>>=0,y>>>=0,cn.length=0;for(var v;v=o()[g++>>>0];){var _=v!=105;y+=(_&=v!=112)&&y%8?4:0,cn.push(v==112?p()[y>>>2>>>0]:v==106?xt[y>>>3]:v==105?s()[y>>>2>>>0]:l()[y>>>3>>>0]),y+=_?8:4}return wi[f](...cn)}var Qd=()=>{},th=()=>Date.now();function eh(f,g){return Z(je(f>>>0,g>>>0))}var Ji,rh=()=>{throw Be+=1,"unwind"};function nh(){return 4294901760}Ji=()=>performance.timeOrigin+performance.now();var oh=()=>navigator.hardwareConcurrency;function ih(){return et("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function ah(f){f>>>=0;var g=o().length;if(f<=g||4294901760<f)return!1;for(var y=1;4>=y;y*=2){var v=g*(1+.2/y);v=Math.min(v,f+100663296);var _=Math;v=Math.max(f,v);t:{_=(_.min.call(_,4294901760,v+(65536-v%65536)%65536)-yt.buffer.byteLength+65535)/65536;try{yt.grow(_),it();var P=1;break t}catch{}P=void 0}if(P)return!0}return!1}var Pr=()=>(et("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Te={},Yi=f=>{f.forEach(g=>{var y=Pr();y&&(Te[y]=g)})};function sh(){var f=Error().stack.toString().split(`
`);return f[0]=="Error"&&f.shift(),Yi(f),Te.$a=Pr(),Te.bb=f,Te.$a}function uh(f,g,y){if(f>>>=0,g>>>=0,Te.$a==f)var v=Te.bb;else(v=Error().stack.toString().split(`
`))[0]=="Error"&&v.shift(),Yi(v);for(var _=3;v[_]&&Pr()!=f;)++_;for(f=0;f<y&&v[f+_];++f)s()[g+4*f>>>2>>>0]=Pr();return f}var dn,hn={},Qi=()=>{if(!dn){var f,g={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:E||"./this.program"};for(f in hn)hn[f]===void 0?delete g[f]:g[f]=hn[f];var y=[];for(f in g)y.push(`${f}=${g[f]}`);dn=y}return dn};function ta(f,g){if(d)return J(18,1,f,g);f>>>=0,g>>>=0;var y=0;return Qi().forEach((v,_)=>{var P=g+y;for(_=p()[f+4*_>>>2>>>0]=P,P=0;P<v.length;++P)r()[_++>>>0]=v.charCodeAt(P);r()[_>>>0]=0,y+=v.length+1}),0}function ea(f,g){if(d)return J(19,1,f,g);f>>>=0,g>>>=0;var y=Qi();p()[f>>>2>>>0]=y.length;var v=0;return y.forEach(_=>v+=_.length+1),p()[g>>>2>>>0]=v,0}function ra(f){return d?J(20,1,f):52}function na(f,g,y,v){return d?J(21,1,f,g,y,v):52}function oa(f,g,y,v){return d?J(22,1,f,g,y,v):70}var lh=[null,[],[]];function ia(f,g,y,v){if(d)return J(23,1,f,g,y,v);g>>>=0,y>>>=0,v>>>=0;for(var _=0,P=0;P<y;P++){var N=p()[g>>>2>>>0],K=p()[g+4>>>2>>>0];g+=8;for(var ct=0;ct<K;ct++){var gt=o()[N+ct>>>0],vt=lh[f];gt===0||gt===10?((f===1?pt:Z)(Di(vt,0)),vt.length=0):vt.push(gt)}_+=K}return p()[v>>>2>>>0]=_,0}var aa=[31,29,31,30,31,30,31,31,30,31,30,31],sa=[31,28,31,30,31,30,31,31,30,31,30,31],ph=(f,g)=>{r().set(f,g>>>0)};function ua(f,g,y,v){function _(O,z,rt){for(O=typeof O=="number"?O.toString():O||"";O.length<z;)O=rt[0]+O;return O}function P(O,z){return _(O,z,"0")}function N(O,z){function rt(ma){return 0>ma?-1:0<ma?1:0}var ue;return(ue=rt(O.getFullYear()-z.getFullYear()))===0&&(ue=rt(O.getMonth()-z.getMonth()))===0&&(ue=rt(O.getDate()-z.getDate())),ue}function K(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function ct(O){var z=O.Sa;for(O=new Date(new Date(O.Ta+1900,0,1).getTime());0<z;){var rt=O.getMonth(),ue=(xe(O.getFullYear())?aa:sa)[rt];if(!(z>ue-O.getDate())){O.setDate(O.getDate()+z);break}z-=ue-O.getDate()+1,O.setDate(1),11>rt?O.setMonth(rt+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1))}return rt=new Date(O.getFullYear()+1,0,4),z=K(new Date(O.getFullYear(),0,4)),rt=K(rt),0>=N(z,O)?0>=N(rt,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}f>>>=0,g>>>=0,y>>>=0,v>>>=0;var gt=p()[v+40>>>2>>>0];for(var vt in v={gb:s()[v>>>2>>>0],fb:s()[v+4>>>2>>>0],Va:s()[v+8>>>2>>>0],Ya:s()[v+12>>>2>>>0],Wa:s()[v+16>>>2>>>0],Ta:s()[v+20>>>2>>>0],Qa:s()[v+24>>>2>>>0],Sa:s()[v+28>>>2>>>0],ob:s()[v+32>>>2>>>0],eb:s()[v+36>>>2>>>0],hb:gt?je(gt):""},y=je(y),gt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})y=y.replace(new RegExp(vt,"g"),gt[vt]);var fa="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ga="January February March April May June July August September October November December".split(" ");for(vt in gt={"%a":O=>fa[O.Qa].substring(0,3),"%A":O=>fa[O.Qa],"%b":O=>ga[O.Wa].substring(0,3),"%B":O=>ga[O.Wa],"%C":O=>P((O.Ta+1900)/100|0,2),"%d":O=>P(O.Ya,2),"%e":O=>_(O.Ya,2," "),"%g":O=>ct(O).toString().substring(2),"%G":ct,"%H":O=>P(O.Va,2),"%I":O=>((O=O.Va)==0?O=12:12<O&&(O-=12),P(O,2)),"%j":O=>{for(var z=0,rt=0;rt<=O.Wa-1;z+=(xe(O.Ta+1900)?aa:sa)[rt++]);return P(O.Ya+z,3)},"%m":O=>P(O.Wa+1,2),"%M":O=>P(O.fb,2),"%n":()=>`
`,"%p":O=>0<=O.Va&&12>O.Va?"AM":"PM","%S":O=>P(O.gb,2),"%t":()=>"	","%u":O=>O.Qa||7,"%U":O=>P(Math.floor((O.Sa+7-O.Qa)/7),2),"%V":O=>{var z=Math.floor((O.Sa+7-(O.Qa+6)%7)/7);if(2>=(O.Qa+371-O.Sa-2)%7&&z++,z)z==53&&((rt=(O.Qa+371-O.Sa)%7)==4||rt==3&&xe(O.Ta)||(z=1));else{z=52;var rt=(O.Qa+7-O.Sa-1)%7;(rt==4||rt==5&&xe(O.Ta%400-1))&&z++}return P(z,2)},"%w":O=>O.Qa,"%W":O=>P(Math.floor((O.Sa+7-(O.Qa+6)%7)/7),2),"%y":O=>(O.Ta+1900).toString().substring(2),"%Y":O=>O.Ta+1900,"%z":O=>{var z=0<=(O=O.eb);return O=Math.abs(O)/60,(z?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.hb,"%%":()=>"%"},y=y.replace(/%%/g,"\0\0"),gt)y.includes(vt)&&(y=y.replace(new RegExp(vt,"g"),gt[vt](v)));return vt=function(O){var z=Array(Fi(O)+1);return Ci(O,z,0,z.length),z}(y=y.replace(/\0\0/g,"%")),vt.length>g?0:(ph(vt,f),vt.length-1)}function ch(f,g,y,v){return ua(f>>>0,g>>>0,y>>>0,v>>>0)}d||function(){for(var f=a.numThreads-1;f--;)Ei();oe.unshift(()=>{ie++,function(g){d?g():Promise.all(Kt.map(Oi)).then(g)}(()=>ae())})}();var dh=[sn,xi,Pi,Ni,ki,Li,Ri,Bi,ji,Vi,Mi,zi,Ui,Gi,Hi,qi,Ki,Zi,ta,ea,ra,na,oa,ia],k=function(){function f(y,v){return k=y.exports,k=function(){var _=k,P=K=>()=>K()>>>0,N=K=>ct=>K(ct)>>>0;return(_=Object.assign({},_)).Ba=P(_.Ba),_.Ca=N(_.Ca),_.emscripten_main_runtime_thread_id=P(_.emscripten_main_runtime_thread_id),_.Oa=N(_.Oa),_.Pa=P(_.Pa),_}(),Ti.push(k.Ea),Ii=k.Fa,Xt.unshift(k.$),xr=v,ae(),k}var g=yi();if(ie++,a.instantiateWasm)try{return a.instantiateWasm(g,f)}catch(y){Z(`Module.instantiateWasm callback failed with error: ${y}`),n(y)}return at||=a.locateFile?Gt("ort-wasm-simd-threaded.wasm")?"ort-wasm-simd-threaded.wasm":a.locateFile?a.locateFile("ort-wasm-simd-threaded.wasm",S):S+"ort-wasm-simd-threaded.wasm":new URL("ort-wasm-simd-threaded.wasm",zr.url).href,function(y,v){var _=at;return $||typeof WebAssembly.instantiateStreaming!="function"||Gt(_)||Re(_)||typeof fetch!="function"?bi(_,y,v):fetch(_,{credentials:"same-origin"}).then(P=>WebAssembly.instantiateStreaming(P,y).then(v,function(N){return Z(`wasm streaming compile failed: ${N}`),Z("falling back to ArrayBuffer instantiation"),bi(_,y,v)}))}(g,function(y){f(y.instance,y.module)}).catch(n),{}}();a._OrtInit=(f,g)=>(a._OrtInit=k.aa)(f,g),a._OrtGetLastError=(f,g)=>(a._OrtGetLastError=k.ba)(f,g),a._OrtCreateSessionOptions=(f,g,y,v,_,P,N,K,ct,gt)=>(a._OrtCreateSessionOptions=k.ca)(f,g,y,v,_,P,N,K,ct,gt),a._OrtAppendExecutionProvider=(f,g)=>(a._OrtAppendExecutionProvider=k.da)(f,g),a._OrtAddFreeDimensionOverride=(f,g,y)=>(a._OrtAddFreeDimensionOverride=k.ea)(f,g,y),a._OrtAddSessionConfigEntry=(f,g,y)=>(a._OrtAddSessionConfigEntry=k.fa)(f,g,y),a._OrtReleaseSessionOptions=f=>(a._OrtReleaseSessionOptions=k.ga)(f),a._OrtCreateSession=(f,g,y)=>(a._OrtCreateSession=k.ha)(f,g,y),a._OrtReleaseSession=f=>(a._OrtReleaseSession=k.ia)(f),a._OrtGetInputOutputCount=(f,g,y)=>(a._OrtGetInputOutputCount=k.ja)(f,g,y),a._OrtGetInputName=(f,g)=>(a._OrtGetInputName=k.ka)(f,g),a._OrtGetOutputName=(f,g)=>(a._OrtGetOutputName=k.la)(f,g),a._OrtFree=f=>(a._OrtFree=k.ma)(f),a._OrtCreateTensor=(f,g,y,v,_,P)=>(a._OrtCreateTensor=k.na)(f,g,y,v,_,P),a._OrtGetTensorData=(f,g,y,v,_)=>(a._OrtGetTensorData=k.oa)(f,g,y,v,_),a._OrtReleaseTensor=f=>(a._OrtReleaseTensor=k.pa)(f),a._OrtCreateRunOptions=(f,g,y,v)=>(a._OrtCreateRunOptions=k.qa)(f,g,y,v),a._OrtAddRunConfigEntry=(f,g,y)=>(a._OrtAddRunConfigEntry=k.ra)(f,g,y),a._OrtReleaseRunOptions=f=>(a._OrtReleaseRunOptions=k.sa)(f),a._OrtCreateBinding=f=>(a._OrtCreateBinding=k.ta)(f),a._OrtBindInput=(f,g,y)=>(a._OrtBindInput=k.ua)(f,g,y),a._OrtBindOutput=(f,g,y,v)=>(a._OrtBindOutput=k.va)(f,g,y,v),a._OrtClearBoundOutputs=f=>(a._OrtClearBoundOutputs=k.wa)(f),a._OrtReleaseBinding=f=>(a._OrtReleaseBinding=k.xa)(f),a._OrtRunWithBinding=(f,g,y,v,_)=>(a._OrtRunWithBinding=k.ya)(f,g,y,v,_),a._OrtRun=(f,g,y,v,_,P,N,K)=>(a._OrtRun=k.za)(f,g,y,v,_,P,N,K),a._OrtEndProfiling=f=>(a._OrtEndProfiling=k.Aa)(f);var _e=()=>(_e=k.Ba)();a._malloc=f=>(a._malloc=k.Ca)(f),a._free=f=>(a._free=k.Da)(f);var Ar,fn=(f,g,y,v,_,P)=>(fn=k.Ga)(f,g,y,v,_,P),la=()=>(la=k.Ha)(),pa=(f,g,y,v,_)=>(pa=k.Ia)(f,g,y,v,_),gn=f=>(gn=k.Ja)(f),$r=f=>($r=k.Ka)(f),ca=()=>(ca=k.La)(),da=(f,g)=>(da=k.Ma)(f,g),Dr=f=>(Dr=k.Na)(f),mn=f=>(mn=k.Oa)(f),bn=()=>(bn=k.Pa)();function ha(){0<ie||(d?(c(a),d||Or(Xt),startWorker(a)):(Or(oe),0<ie||Ar||(Ar=!0,a.calledRun=!0,ot||(d||Or(Xt),c(a),d||Or(_r)))))}return a.___start_em_js=838360,a.___stop_em_js=838421,a.stackSave=()=>bn(),a.stackRestore=f=>Dr(f),a.stackAlloc=f=>mn(f),a.UTF8ToString=je,a.stringToUTF8=Ve,a.lengthBytesUTF8=Fi,Tt=function f(){Ar||ha(),Ar||(Tt=f)},ha(),e}),hd=to,globalThis.self?.name==="em-pthread"&&to()}),Oe,Lu,Ru,Bu,eo,fd,ju,gd,en=I(()=>{"use strict";ni(),Oe=zr.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),Lu=typeof location>"u"?void 0:location.origin,Ru=(t,r)=>{try{let o=r??Oe;return(o?new URL(t,o):new URL(t)).origin===Lu}catch{return!1}},Bu=async t=>{let r=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},eo=(dm(),Ur(pd)).default,fd=async()=>{if(!Oe)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Ru(Oe))return[void 0,eo()];let t=await Bu(Oe);return[t,eo(t)]},ju=(hm(),Ur(dd)).default,gd=async(t,r,o)=>[void 0,ju]}),ro,Rr,Ke,no,Vu,Mu,oi,ht,Ce=I(()=>{"use strict";en(),Rr=!1,Ke=!1,no=!1,Vu=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Mu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},oi=async t=>{if(Rr)return Promise.resolve();if(Ke)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(no)throw new Error("previous call to 'initializeWebAssembly()' failed.");Ke=!0;let r=t.initTimeout,o=t.numThreads;if(!Mu())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=Vu();o>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+o+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=o=1);let p=t.wasmPaths,l=typeof p=="string"?p:void 0,c=p?.mjs,n=c?.href??c,a=p?.wasm,e=a?.href??a,u=t.wasmBinary,[i,d]=await gd(n,l,o>1),h=!1,m=[];if(r>0&&m.push(new Promise(b=>{setTimeout(()=>{h=!0,b()},r)})),m.push(new Promise((b,x)=>{let E={numThreads:o};u?E.wasmBinary=u:(e||l)&&(E.locateFile=(w,S)=>e??(l??S)+w),d(E).then(w=>{Ke=!1,Rr=!0,ro=w,b(),i&&URL.revokeObjectURL(i)},w=>{Ke=!1,no=!0,x(w)})})),await Promise.race(m),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},ht=()=>{if(Rr&&ro)return ro;throw new Error("WebAssembly is not initialized yet.")}}),ut,Xr,st,ii=I(()=>{"use strict";Ce(),ut=(t,r)=>{let o=ht(),s=o.lengthBytesUTF8(t)+1,p=o._malloc(s);return o.stringToUTF8(t,p,s),r.push(p),p},Xr=(t,r,o,s)=>{if(typeof t=="object"&&t!==null){if(o.has(t))throw new Error("Circular reference in options");o.add(t)}Object.entries(t).forEach(([p,l])=>{let c=r?r+p:p;if(typeof l=="object")Xr(l,c+".",o,s);else if(typeof l=="string"||typeof l=="number")s(c,l.toString());else if(typeof l=="boolean")s(c,l?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof l}`)})},st=t=>{let r=ht(),o=r.stackSave();try{let s=r.stackAlloc(8);r._OrtGetLastError(s,s+4);let p=r.HEAP32[s/4],l=r.HEAPU32[s/4+1],c=l?r.UTF8ToString(l):"";throw new Error(`${t} ERROR_CODE: ${p}, ERROR_MESSAGE: ${c}`)}finally{r.stackRestore(o)}}}),md,fm=I(()=>{"use strict";Ce(),ii(),md=t=>{let r=ht(),o=0,s=[],p=t||{};try{if(t?.logSeverityLevel===void 0)p.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)p.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(p.terminate=!1);let l=0;return t?.tag!==void 0&&(l=ut(t.tag,s)),o=r._OrtCreateRunOptions(p.logSeverityLevel,p.logVerbosityLevel,!!p.terminate,l),o===0&&st("Can't create run options."),t?.extra!==void 0&&Xr(t.extra,"",new WeakSet,(c,n)=>{let a=ut(c,s),e=ut(n,s);r._OrtAddRunConfigEntry(o,a,e)!==0&&st(`Can't set a run config entry: ${c} - ${n}.`)}),[o,s]}catch(l){throw o!==0&&r._OrtReleaseRunOptions(o),s.forEach(c=>r._free(c)),l}}}),zu,Uu,Gu,Hu,bd,gm=I(()=>{"use strict";Ce(),ii(),zu=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},Uu=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},Gu=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let r=t.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(o=>(typeof o=="string"?o:o.name)==="webgpu")&&(t.enableMemPattern=!1)},Hu=(t,r,o)=>{for(let s of r){let p=typeof s=="string"?s:s.name;switch(p){case"webnn":if(p="WEBNN",typeof s!="string"){let c=s?.deviceType;if(c){let n=ut("deviceType",o),a=ut(c,o);ht()._OrtAddSessionConfigEntry(t,n,a)!==0&&st(`Can't set a session config entry: 'deviceType' - ${c}.`)}}break;case"webgpu":if(p="JS",typeof s!="string"){let c=s;if(c?.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);let n=ut("preferredLayout",o),a=ut(c.preferredLayout,o);ht()._OrtAddSessionConfigEntry(t,n,a)!==0&&st(`Can't set a session config entry: 'preferredLayout' - ${c.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${p}`)}let l=ut(p,o);ht()._OrtAppendExecutionProvider(t,l)!==0&&st(`Can't append execution provider: ${p}.`)}},bd=t=>{let r=ht(),o=0,s=[],p=t||{};Gu(p);try{let l=zu(p.graphOptimizationLevel??"all"),c=Uu(p.executionMode??"sequential"),n=typeof p.logId=="string"?ut(p.logId,s):0,a=p.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let e=p.logVerbosityLevel??0;if(!Number.isInteger(e)||e<0||e>4)throw new Error(`log verbosity level is not valid: ${e}`);let u=typeof p.optimizedModelFilePath=="string"?ut(p.optimizedModelFilePath,s):0;if(o=r._OrtCreateSessionOptions(l,!!p.enableCpuMemArena,!!p.enableMemPattern,c,!!p.enableProfiling,0,n,a,e,u),o===0&&st("Can't create session options."),p.executionProviders&&Hu(o,p.executionProviders,s),p.enableGraphCapture!==void 0){if(typeof p.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${p.enableGraphCapture}`);let i=ut("enableGraphCapture",s),d=ut(p.enableGraphCapture.toString(),s);r._OrtAddSessionConfigEntry(o,i,d)!==0&&st(`Can't set a session config entry: 'enableGraphCapture' - ${p.enableGraphCapture}.`)}if(p.freeDimensionOverrides)for(let[i,d]of Object.entries(p.freeDimensionOverrides)){if(typeof i!="string")throw new Error(`free dimension override name must be a string: ${i}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let h=ut(i,s);r._OrtAddFreeDimensionOverride(o,h,d)!==0&&st(`Can't set a free dimension override: ${i} - ${d}.`)}return p.extra!==void 0&&Xr(p.extra,"",new WeakSet,(i,d)=>{let h=ut(i,s),m=ut(d,s);r._OrtAddSessionConfigEntry(o,h,m)!==0&&st(`Can't set a session config entry: ${i} - ${d}.`)}),[o,s]}catch(l){throw o!==0&&r._OrtReleaseSessionOptions(o),s.forEach(c=>r._free(c)),l}}}),ir,yd,ar,wd,vd,ai,si,xd,Td=I(()=>{"use strict";ir=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},yd=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},ar=(t,r)=>{let o=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],s=typeof r=="number"?r:r.reduce((p,l)=>p*l,1);return o>0?Math.ceil(s*o):void 0},wd=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},vd=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},ai=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",si=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool",xd=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}}),ui,_d=I(()=>{"use strict";ni(),ui=async t=>{if(typeof t=="string")if(0)try{}catch(r){}else{let r=await fetch(t);if(!r.ok)throw new Error(`failed to load external data file: ${t}`);let o=r.headers.get("Content-Length"),s=o?parseInt(o,10):0;if(s<1073741824)return new Uint8Array(await r.arrayBuffer());{if(!r.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let p=r.body.getReader(),l;try{l=new ArrayBuffer(s)}catch(n){if(n instanceof RangeError){let a=Math.ceil(s/65536);l=new WebAssembly.Memory({initial:a,maximum:a}).buffer}else throw n}let c=0;for(;;){let{done:n,value:a}=await p.read();if(n)break;let e=a.byteLength;new Uint8Array(l,c,e).set(a),c+=e}return new Uint8Array(l,0,s)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}}),qu,li,pi,de,Wu,Kr,ci,di,oo,hi,fi,gi,Sd=I(()=>{"use strict";fm(),gm(),Td(),Ce(),ii(),_d(),qu=(t,r)=>{ht()._OrtInit(t,r)!==0&&st("Can't initialize onnxruntime.")},li=async t=>{qu(t.wasm.numThreads,vd(t.logLevel))},pi=async(t,r)=>{},de=new Map,Wu=t=>{let r=ht(),o=r.stackSave();try{let s=r.stackAlloc(8);return r._OrtGetInputOutputCount(t,s,s+4)!==0&&st("Can't get session input/output count."),[r.HEAP32[s/4],r.HEAP32[s/4+1]]}finally{r.stackRestore(o)}},Kr=t=>{let r=ht(),o=r._malloc(t.byteLength);if(o===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return r.HEAPU8.set(t,o),[o,t.byteLength]},ci=async(t,r)=>{let o,s,p=ht();Array.isArray(t)?[o,s]=t:t.buffer===p.HEAPU8.buffer?[o,s]=[t.byteOffset,t.byteLength]:[o,s]=Kr(t);let l=0,c=0,n=0,a=[],e=[],u=[];try{if([c,a]=bd(r),r?.externalData&&p.mountExternalData){let w=[];for(let S of r.externalData){let $=typeof S=="string"?S:S.path;w.push(ui(typeof S=="string"?S:S.data).then(F=>{p.mountExternalData($,F)}))}await Promise.all(w)}for(let w of r?.executionProviders??[])if((typeof w=="string"?w:w.name)==="webnn"){if(p.shouldTransferToMLTensor=!1,p.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof w!="string"){let S=w,$=S?.context,F=S?.gpuDevice,bt=S?.deviceType,pt=S?.numThreads,Z=S?.powerPreference;$?p.currentContext=$:F?p.currentContext=await navigator.ml.createContext(F):p.currentContext=await navigator.ml.createContext({deviceType:bt,numThreads:pt,powerPreference:Z})}else p.currentContext=await navigator.ml.createContext();break}l=await p._OrtCreateSession(o,s,c),l===0&&st("Can't create a session."),p.currentContext&&(p.jsepRegisterMLContext(l,p.currentContext),p.currentContext=void 0,p.shouldTransferToMLTensor=!0);let[i,d]=Wu(l),h=!!r?.enableGraphCapture,m=[],b=[],x=[];for(let w=0;w<i;w++){let S=p._OrtGetInputName(l,w);S===0&&st("Can't get an input name."),e.push(S),m.push(p.UTF8ToString(S))}for(let w=0;w<d;w++){let S=p._OrtGetOutputName(l,w);S===0&&st("Can't get an output name."),u.push(S);let $=p.UTF8ToString(S);b.push($)}return de.set(l,[l,e,u,null,h,!1]),[l,m,b]}catch(i){throw e.forEach(d=>p._OrtFree(d)),u.forEach(d=>p._OrtFree(d)),n!==0&&p._OrtReleaseBinding(n),l!==0&&p._OrtReleaseSession(l),i}finally{p._free(o),c!==0&&p._OrtReleaseSessionOptions(c),a.forEach(i=>p._free(i)),p.unmountExternalData?.()}},di=t=>{let r=ht(),o=de.get(t);if(!o)throw new Error(`cannot release session. invalid session id: ${t}`);let[s,p,l,c,n]=o;c&&(n&&r._OrtClearBoundOutputs(c.handle),r._OrtReleaseBinding(c.handle)),r.jsepOnReleaseSession?.(t),p.forEach(a=>r._OrtFree(a)),l.forEach(a=>r._OrtFree(a)),r._OrtReleaseSession(s),de.delete(t)},oo=(t,r,o,s,p,l=!1)=>{if(!t){r.push(0);return}let c=ht(),n=t[0],a=t[1],e=t[3],u,i;if(n==="string"&&(e==="gpu-buffer"||e==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(l&&e!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${p} when enableGraphCapture is true.`);if(e==="gpu-buffer"){let m=t[2].gpuBuffer;i=ar(ir(n),a);let b=c.jsepRegisterBuffer;if(!b)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');u=b(s,p,m,i)}else if(e==="ml-tensor"){let m=t[2].mlTensor;i=ar(ir(n),a);let b=c.jsepRegisterMLTensor;if(!b)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');u=b(m,ir(n),a)}else{let m=t[2];if(Array.isArray(m)){i=4*m.length,u=c._malloc(i),o.push(u);let b=u/4;for(let x=0;x<m.length;x++){if(typeof m[x]!="string")throw new TypeError(`tensor data at index ${x} is not a string`);c.HEAPU32[b++]=ut(m[x],o)}}else i=m.byteLength,u=c._malloc(i),o.push(u),c.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,i),u)}let d=c.stackSave(),h=c.stackAlloc(4*a.length);try{let m=h/4;a.forEach(x=>c.HEAP32[m++]=x);let b=c._OrtCreateTensor(ir(n),u,i,h,a.length,xd(e));b===0&&st(`Can't create tensor for input/output. session=${s}, index=${p}.`),r.push(b)}finally{c.stackRestore(d)}},hi=async(t,r,o,s,p,l)=>{let c=ht(),n=de.get(t);if(!n)throw new Error(`cannot run inference. invalid session id: ${t}`);let a=n[0],e=n[1],u=n[2],i=n[3],d=n[4],h=n[5],m=r.length,b=s.length,x=0,E=[],w=[],S=[],$=[],F=c.stackSave(),bt=c.stackAlloc(m*4),pt=c.stackAlloc(m*4),Z=c.stackAlloc(b*4),Le=c.stackAlloc(b*4);try{c.jsepOnRunStart?.(a),[x,E]=md(l);for(let G=0;G<m;G++)oo(o[G],w,$,t,r[G],d);for(let G=0;G<b;G++)oo(p[G],S,$,t,m+s[G],d);let At=bt/4,vr=pt/4,yt=Z/4,xr=Le/4;for(let G=0;G<m;G++)c.HEAPU32[At++]=w[G],c.HEAPU32[vr++]=e[r[G]];for(let G=0;G<b;G++)c.HEAPU32[yt++]=S[G],c.HEAPU32[xr++]=u[s[G]];let Ut;Ut=await c._OrtRun(a,pt,bt,m,Le,b,Z,x),Ut!==0&&st("failed to call OrtRun().");let wt=[];for(let G=0;G<b;G++){let Wt=c.HEAPU32[Z/4+G];if(Wt===S[G]){wt.push(p[G]);continue}let Tr=c.stackSave(),xt=c.stackAlloc(4*4),ve=!1,ot,it=0;try{c._OrtGetTensorData(Wt,xt,xt+4,xt+8,xt+12)!==0&&st(`Can't access output tensor data on index ${G}.`);let oe=xt/4,Xt=c.HEAPU32[oe++];it=c.HEAPU32[oe++];let _r=c.HEAPU32[oe++],ie=c.HEAPU32[oe++],Ct=[];for(let et=0;et<ie;et++)Ct.push(c.HEAPU32[_r/4+et]);c._OrtFree(_r);let Tt=Ct.reduce((et,at)=>et*at,1);ot=yd(Xt);let ae=i?.outputPreferredLocations[s[G]];if(ot==="string"){if(ae==="gpu-buffer"||ae==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let et=[],at=it/4;for(let Gt=0;Gt<Tt;Gt++){let Re=c.HEAPU32[at++],Sr=Gt===Tt-1?void 0:c.HEAPU32[at]-Re;et.push(c.UTF8ToString(Re,Sr))}wt.push([ot,Ct,et,"cpu"])}else if(ae==="gpu-buffer"&&Tt>0){let et=c.jsepGetBuffer;if(!et)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let at=et(it),Gt=ar(Xt,Tt);if(Gt===void 0||!ai(ot))throw new Error(`Unsupported data type: ${ot}`);ve=!0,wt.push([ot,Ct,{gpuBuffer:at,download:c.jsepCreateDownloader(at,Gt,ot),dispose:()=>{c._OrtReleaseTensor(Wt)}},"gpu-buffer"])}else if(ae==="ml-tensor"&&Tt>0){let et=c.jsepEnsureTensor;if(!et)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(ar(Xt,Tt)===void 0||!si(ot))throw new Error(`Unsupported data type: ${ot}`);let at=await et(it,Xt,Ct,!1);ve=!0,wt.push([ot,Ct,{mlTensor:at,download:c.jsepCreateMLTensorDownloader(it,ot),dispose:()=>{c.jsepReleaseTensorId(it),c._OrtReleaseTensor(Wt)}},"ml-tensor"])}else{let et=wd(ot),at=new et(Tt);new Uint8Array(at.buffer,at.byteOffset,at.byteLength).set(c.HEAPU8.subarray(it,it+at.byteLength)),wt.push([ot,Ct,at,"cpu"])}}finally{c.stackRestore(Tr),ot==="string"&&it&&c._free(it),ve||c._OrtReleaseTensor(Wt)}}return i&&!d&&(c._OrtClearBoundOutputs(i.handle),de.set(t,[a,e,u,i,d,!1])),wt}finally{c.stackRestore(F),w.forEach(At=>c._OrtReleaseTensor(At)),S.forEach(At=>c._OrtReleaseTensor(At)),$.forEach(At=>c._free(At)),x!==0&&c._OrtReleaseRunOptions(x),E.forEach(At=>c._free(At))}},fi=t=>{let r=ht(),o=de.get(t);if(!o)throw new Error("invalid session id");let s=o[0],p=r._OrtEndProfiling(s);p===0&&st("Can't get an profile file name."),r._OrtFree(p)},gi=t=>{let r=[];for(let o of t){let s=o[2];!Array.isArray(s)&&"buffer"in s&&r.push(s.buffer)}return r}}),Yt,$t,Se,Ze,Je,Br,io,jr,he,fe,Xu,Od,Ed,Id,Pd,Ad,$d,Dd,Nd=I(()=>{"use strict";zt(),Sd(),Ce(),en(),Yt=()=>!!B.wasm.proxy&&typeof document<"u",Se=!1,Ze=!1,Je=!1,jr=new Map,he=(t,r)=>{let o=jr.get(t);o?o.push(r):jr.set(t,[r])},fe=()=>{if(Se||!Ze||Je||!$t)throw new Error("worker not ready")},Xu=t=>{switch(t.data.type){case"init-wasm":Se=!1,t.data.err?(Je=!0,io[1](t.data.err)):(Ze=!0,io[0]()),Br&&(URL.revokeObjectURL(Br),Br=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let r=jr.get(t.data.type);t.data.err?r.shift()[1](t.data.err):r.shift()[0](t.data.out);break}default:}},Od=async()=>{if(!Ze){if(Se)throw new Error("multiple calls to 'initWasm()' detected.");if(Je)throw new Error("previous call to 'initWasm()' failed.");if(Se=!0,Yt())return new Promise((t,r)=>{$t?.terminate(),fd().then(([o,s])=>{try{$t=s,$t.onerror=l=>r(l),$t.onmessage=Xu,io=[t,r];let p={type:"init-wasm",in:B};$t.postMessage(p),Br=o}catch(p){r(p)}},r)});try{await oi(B.wasm),await li(B),Ze=!0}catch(t){throw Je=!0,t}finally{Se=!1}}},Ed=async t=>{if(Yt())return fe(),new Promise((r,o)=>{he("init-ep",[r,o]);let s={type:"init-ep",in:{epName:t,env:B}};$t.postMessage(s)});await pi(B,t)},Id=async t=>Yt()?(fe(),new Promise((r,o)=>{he("copy-from",[r,o]);let s={type:"copy-from",in:{buffer:t}};$t.postMessage(s,[t.buffer])})):Kr(t),Pd=async(t,r)=>{if(Yt()){if(r?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return fe(),new Promise((o,s)=>{he("create",[o,s]);let p={type:"create",in:{model:t,options:{...r}}},l=[];t instanceof Uint8Array&&l.push(t.buffer),$t.postMessage(p,l)})}else return ci(t,r)},Ad=async t=>{if(Yt())return fe(),new Promise((r,o)=>{he("release",[r,o]);let s={type:"release",in:t};$t.postMessage(s)});di(t)},$d=async(t,r,o,s,p,l)=>{if(Yt()){if(o.some(c=>c[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(p.some(c=>c))throw new Error("pre-allocated output tensor is not supported for proxy.");return fe(),new Promise((c,n)=>{he("run",[c,n]);let a=o,e={type:"run",in:{sessionId:t,inputIndices:r,inputs:a,outputIndices:s,options:l}};$t.postMessage(e,gi(a))})}else return hi(t,r,o,s,p,l)},Dd=async t=>{if(Yt())return fe(),new Promise((r,o)=>{he("end-profiling",[r,o]);let s={type:"end-profiling",in:t};$t.postMessage(s)});fi(t)}}),ao,Ku,kd,mm=I(()=>{"use strict";zt(),Nd(),Td(),ni(),_d(),ao=(t,r)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${r()}`)}},Ku=t=>{switch(t[3]){case"cpu":return new ft(t[0],t[2],t[1]);case"gpu-buffer":{let r=t[0];if(!ai(r))throw new Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:o,download:s,dispose:p}=t[2];return ft.fromGpuBuffer(o,{dataType:r,dims:t[1],download:s,dispose:p})}case"ml-tensor":{let r=t[0];if(!si(r))throw new Error(`not supported data type: ${r} for deserializing MLTensor tensor`);let{mlTensor:o,download:s,dispose:p}=t[2];return ft.fromMLTensor(o,{dataType:r,dims:t[1],download:s,dispose:p})}default:throw new Error(`invalid data location: ${t[3]}`)}},kd=class{async fetchModelAndCopyToWasmMemory(t){return Id(await ui(t))}async loadModel(t,r){Pe();let o;typeof t=="string"?o=await this.fetchModelAndCopyToWasmMemory(t):o=t,[this.sessionId,this.inputNames,this.outputNames]=await Pd(o,r),Ae()}async dispose(){return Ad(this.sessionId)}async run(t,r,o){Pe();let s=[],p=[];Object.entries(t).forEach(i=>{let d=i[0],h=i[1],m=this.inputNames.indexOf(d);if(m===-1)throw new Error(`invalid input '${d}'`);s.push(h),p.push(m)});let l=[],c=[];Object.entries(r).forEach(i=>{let d=i[0],h=i[1],m=this.outputNames.indexOf(d);if(m===-1)throw new Error(`invalid output '${d}'`);l.push(h),c.push(m)});let n=s.map((i,d)=>ao(i,()=>`input "${this.inputNames[p[d]]}"`)),a=l.map((i,d)=>i?ao(i,()=>`output "${this.outputNames[c[d]]}"`):null),e=await $d(this.sessionId,p,n,c,a,o),u={};for(let i=0;i<e.length;i++)u[this.outputNames[c[i]]]=l[i]??Ku(e[i]);return Ae(),u}startProfiling(){}endProfiling(){Dd(this.sessionId)}}}),Fd={};gr(Fd,{OnnxruntimeWebAssemblyBackend:()=>Uo,initializeFlags:()=>zo,wasmBackend:()=>Cd});var zo,Uo,Cd,bm=I(()=>{"use strict";zt(),Nd(),mm(),en(),zo=()=>{if((typeof B.wasm.initTimeout!="number"||B.wasm.initTimeout<0)&&(B.wasm.initTimeout=0),B.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof B.wasm.proxy!="boolean"&&(B.wasm.proxy=!1),typeof B.wasm.trace!="boolean"&&(B.wasm.trace=!1),typeof B.wasm.numThreads!="number"||!Number.isInteger(B.wasm.numThreads)||B.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)B.wasm.numThreads=1;else{let t=typeof navigator>"u"?yh("node:os").cpus().length:navigator.hardwareConcurrency;B.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},Uo=class{async init(t){zo(),await Od(),await Ed(t)}async createInferenceSessionHandler(t,r){let o=new kd;return await o.loadModel(t,r),Promise.resolve(o)}},Cd=new Uo});zt();zt();zt();var ym="1.20.1",xm=gl;{let t=(cm(),Ur(ud)).onnxjsBackend;cr("webgl",t,-10)}{let t=(bm(),Ur(Fd)).wasmBackend;cr("cpu",t,10),cr("wasm",t,10)}Object.defineProperty(B.versions,"web",{value:ym,enumerable:!0});var rn=class t{constructor(){this.metrics=[]}static getInstance(){return this.instance||(this.instance=new t),this.instance}trackModelPerformance(r){let o=performance.now()-r;this.metrics.push({modelLoadTime:o,inferenceTime:0}),o>5e3&&console.warn("Model loading is taking longer than expected")}getMetrics(){return this.metrics}};var nn=class{constructor(){this.model=null;this.performance=rn.getInstance();this.isInitializing=!1}async initialize(){if(this.model)return!0;if(this.isInitializing)return!1;this.isInitializing=!0;let r=performance.now();try{return this.model=await Jr.create("models/detector.onnx",{executionProviders:["wasm"],graphOptimizationLevel:"all"}),this.performance.trackModelPerformance(r),!0}catch(o){return console.error("Failed to initialize model:",o),!1}finally{this.isInitializing=!1}}async analyzeContent(r){this.model||await this.initialize();let o=Math.random()*.5+.3,s=Math.min(.9,o+.1);return{trustScore:{score:o,confidence:s,timestamp:Date.now()},factChecks:[],warnings:r.length<100?["Content too short for reliable analysis"]:[]}}};var mi=class{constructor(){this.analyzing=!1;this.badge=null;this.detector=new nn,this.initialize()}async initialize(){this.createLoadingBadge(),await this.detector.initialize(),this.setupMessageListener(),await this.analyzeCurrentPage()}createLoadingBadge(){this.badge=document.createElement("div"),this.badge.id="truthguard-badge",this.badge.className="truthguard-badge",this.badge.textContent="Analyzing...",document.body.appendChild(this.badge)}setupMessageListener(){chrome.runtime.onMessage.addListener((r,o,s)=>{if(r.type==="GET_ANALYSIS")return this.analyzeCurrentPage().then(s),!0})}async analyzeCurrentPage(){if(this.analyzing)return null;this.analyzing=!0,this.updateBadgeState("analyzing");try{let r=this.getPageContent(),o=await this.detector.analyzeContent(r);return this.updateUI(o),o}catch(r){return console.error("Analysis failed:",r),this.updateBadgeState("error"),null}finally{this.analyzing=!1}}getPageContent(){let r=document.querySelector("article");if(r)return r.textContent||"";let o=document.querySelector("main");return o?o.textContent||"":document.body.textContent||""}updateBadgeState(r){if(this.badge)switch(r){case"analyzing":this.badge.textContent="Analyzing...",this.badge.style.backgroundColor="#FFC107";break;case"error":this.badge.textContent="Error",this.badge.style.backgroundColor="#F44336";break;case"ready":break}}updateUI(r){if(!this.badge)return;let o=Math.round(r.trustScore.score*100);this.badge.style.backgroundColor=this.getScoreColor(r.trustScore.score),this.badge.textContent=`${o}%`}getScoreColor(r){return r>=.8?"#4CAF50":r>=.6?"#FFC107":"#F44336"}};new mi;})();
/*! Bundled license information:

onnxruntime-web/dist/ort.bundle.min.mjs:
  (*!
   * ONNX Runtime Web v1.20.1
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

onnxruntime-web/dist/ort.bundle.min.mjs:
  (*! Bundled license information:
  
  long/index.js:
    (**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     *)
  *)
*/
